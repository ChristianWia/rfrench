#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.4.4\n"

#: fr/datatable-benchmarking.Rmd.tmp:block 1 (code)
msgid ""
"title: \"Benchmarking data.table\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"  markdown::html_format:\n"
"    options:\n"
"      toc: true\n"
"      number_sections: true\n"
"    meta:\n"
"      css: [default, css/toc.css]\n"
"vignette: >\n"
"  %\\VignetteIndexEntry{Benchmarking data.table}\n"
"  %\\VignetteEngine{knitr::knitr}\n"
"  \\usepackage[utf8]{inputenc}\n"
msgstr ""
"title : \"Analyse comparative (benchmark) de data.table\"\n"
"date : \"`r Sys.Date()`\"\n"
"output :\n"
"  markdown::html_format :\n"
"    options :\n"
"      toc : true\n"
"      number_sections : true\n"
"    meta :\n"
"      css : [default, ../css/toc.css]\n"
"vignette : >\n"
"  %\\VignetteIndexEntry{Analyse comparative (benchmark) de data.table}\n"
"  %\\VignetteEngine{knitr::knitr}\n"
"  \\N-usepackage[utf8]{inputenc}\n"

#: fr/datatable-benchmarking.Rmd.tmp:block 3 (paragraph)
#, fuzzy
msgid ""
"This document is meant to guide on measuring performance of `data.table`. "
"Single place to document best practices and traps to avoid."
msgstr ""
"Ce document a pour but de guider la mesure de la performance de `data."
"table`. Un seul endroit pour documenter les meilleures pratiques et les "
"pièges à éviter."

#: fr/datatable-benchmarking.Rmd.tmp:block 4 (header)
#, fuzzy
msgid "fread: clear caches"
msgstr "fread : effacer les caches"

#: fr/datatable-benchmarking.Rmd.tmp:block 5 (paragraph)
#, fuzzy
msgid ""
"Ideally each `fread` call should be run in fresh session with the following "
"commands preceding R execution. This clears OS cache file in RAM and HD "
"cache."
msgstr ""
"Idéalement, chaque appel à `fread` devrait être exécuté dans une nouvelle "
"session avec les commandes suivantes précédant l'exécution de R. Cela "
"permet d'effacer le fichier cache du système d'exploitation dans la RAM et "
"le cache du disque dur."

#: fr/datatable-benchmarking.Rmd.tmp:block 6 (code)
#, fuzzy
msgid ""
"free -g\n"
"sudo sh -c 'echo 3 >/proc/sys/vm/drop_caches'\n"
"sudo lshw -class disk\n"
"sudo hdparm -t /dev/sda\n"
msgstr ""
"free -g\n"
"sudo sh -c 'echo 3 >/proc/sys/vm/drop_caches'\n"
"sudo lshw -class disk\n"
"sudo hdparm -t /dev/sda\n"

#: fr/datatable-benchmarking.Rmd.tmp:block 7 (paragraph)
#, fuzzy
msgid ""
"When comparing `fread` to non-R solutions be aware that R requires values "
"of character columns to be added to *R's global string cache*. This takes "
"time when reading data but later operations benefit since the character "
"strings have already been cached. Consequently, in addition to timing "
"isolated tasks (such as `fread` alone), it's a good idea to benchmark the "
"total time of an end-to-end pipeline of tasks such as reading data, "
"manipulating it, and producing final output."
msgstr ""
"Lorsque l'on compare `fread` à des solutions non-R, il faut savoir que R "
"exige que les valeurs des colonnes de caractères soient ajoutées au *cache "
"global de chaînes de caractères de R. Cela prend du temps lors de la "
"lecture des données. Cela prend du temps lors de la lecture des données, "
"mais les opérations ultérieures en bénéficient puisque les chaînes de "
"caractères ont déjà été mises en cache. Par conséquent, en plus de "
"chronométrer des tâches isolées (comme `fread` seul), c'est une bonne idée "
"d'évaluer le temps total d'un pipeline de bout en bout de tâches telles que "
"la lecture de données, leur manipulation et la production de la sortie "
"finale."

#: fr/datatable-benchmarking.Rmd.tmp:block 8 (header)
#, fuzzy
msgid "subset: threshold for index optimization on compound queries"
msgstr ""
"sous-ensemble : seuil d'optimisation de l'index pour les requêtes composées"

#: fr/datatable-benchmarking.Rmd.tmp:block 9 (paragraph)
#, fuzzy
msgid ""
"Index optimization for compound filter queries will be not be used when "
"cross product of elements provided to filter on exceeds 1e4 elements."
msgstr ""
"L'optimisation de l'index pour les requêtes de filtres composés ne sera pas "
"utilisée lorsque le produit croisé des éléments fournis au filtre dépasse "
"1e4 éléments."

#: fr/datatable-benchmarking.Rmd.tmp:block 10 (code)
#, fuzzy
msgid ""
"DT = data.table(V1=1:10, V2=1:10, V3=1:10, V4=1:10)\n"
"setindex(DT)\n"
"v = c(1L, rep(11L, 9))\n"
"length(v)^4               # cross product of elements in filter\n"
"#[1] 10000                # <= 10000\n"
"DT[V1 %in% v & V2 %in% v & V3 %in% v & V4 %in% v, verbose=TRUE]\n"
"#Optimized subsetting with index 'V1__V2__V3__V4'\n"
"#on= matches existing index, using index\n"
"#Starting bmerge ...done in 0.000sec\n"
"#...\n"
"v = c(1L, rep(11L, 10))\n"
"length(v)^4               # cross product of elements in filter\n"
"#[1] 14641                # > 10000\n"
"DT[V1 %in% v & V2 %in% v & V3 %in% v & V4 %in% v, verbose=TRUE]\n"
"#Subsetting optimization disabled because the cross-product of RHS values "
"exceeds 1e4, causing memory problems.\n"
"#...\n"
msgstr ""
"DT = data.table(V1=1:10, V2=1:10, V3=1:10, V4=1:10)\n"
"setindex(DT)\n"
"v = c(1L, rep(11L, 9))\n"
"length(v)^4 # produit en croix des éléments du filtre\n"
"#[1] 10000 # <= 10000\n"
"DT[V1 %in% v & V2 %in% v & V3 %in% v & V4 %in% v, verbose=TRUE]\n"
"#Optimized subsetting with index 'V1__V2__V3__V4' (Optimisation du sous-"
"ensemble avec l'index 'V1__V2__V3__V4')\n"
"#on= correspond à l'index existant, utilise l'index\n"
"#Démarrage de bmerge ...terminé en 0.000sec\n"
"#...\n"
"v = c(1L, rep(11L, 10))\n"
"length(v)^4 # produit en croix des éléments du filtre\n"
"#[1] 14641 # > 10000\n"
"DT[V1 %in% v & V2 %in% v & V3 %in% v & V4 %in% v, verbose=TRUE]\n"
"#Optimisation de la substitution désactivée car le produit en croix des "
"valeurs RHS dépasse 1e4, ce qui cause des problèmes de mémoire.\n"
"#...\n"

#: fr/datatable-benchmarking.Rmd.tmp:block 11 (header)
#, fuzzy
msgid "subset: index aware benchmarking"
msgstr "sous-ensemble : analyse comparative basée sur l'index"

#: fr/datatable-benchmarking.Rmd.tmp:block 12 (paragraph)
#, fuzzy
msgid ""
"For convenience `data.table` automatically builds an index on fields you "
"use to subset data. It will add some overhead to first subset on particular "
"fields but greatly reduces time to query those columns in subsequent runs. "
"When measuring speed, the best way is to measure index creation and query "
"using an index separately. Having such timings it is easy to decide what is "
"the optimal strategy for your use case. To control usage of index use "
"following options:"
msgstr ""
"Pour des raisons de commodité, `data.table` construit automatiquement un "
"index sur les champs que vous utilisez pour sous-répertorier les données. "
"Cela ajoutera une certaine surcharge au premier sous-ensemble sur des "
"champs particuliers, mais réduira considérablement le temps d'interrogation "
"de ces colonnes dans les exécutions suivantes. La meilleure façon de "
"mesurer la vitesse est de mesurer séparément la création d'un index et les "
"requêtes utilisant un index. Avec de tels temps, il est facile de décider "
"quelle est la stratégie optimale pour votre cas d'utilisation. Pour "
"contrôler l'utilisation de l'index, utilisez les options suivantes :"

#: fr/datatable-benchmarking.Rmd.tmp:block 13 (code)
#, fuzzy
msgid ""
"options(datatable.auto.index=TRUE)\n"
"options(datatable.use.index=TRUE)\n"
msgstr ""
"options(datatable.auto.index=TRUE)\n"
"options(datatable.use.index=TRUE)\n"

#: fr/datatable-benchmarking.Rmd.tmp:block 14 (paragraph)
#, fuzzy
msgid ""
"=====- `use.index=FALSE` will force the query not to use indices even if "
"they exist, but existing keys are still used for optimization.===== =====- "
"`auto.index=FALSE` disables building index automatically when doing subset "
"on non-indexed data, but if indices were created before this option was "
"set, or explicitly by calling `setindex` they still will be used for "
"optimization.====="
msgstr ""
"=====- `use.index=FALSE` forcera la requête à ne pas utiliser les index "
"même s'ils existent, mais les clés existantes sont toujours utilisées pour "
"l'optimisation.===== =====- `auto.index=FALSE` désactive la construction "
"automatique d'index lors d'un sous-ensemble sur des données non indexées, "
"mais si les index ont été créés avant que cette option ne soit définie, ou "
"explicitement en appelant `setindex`, ils seront toujours utilisés pour "
"l'optimisation.====="

#: fr/datatable-benchmarking.Rmd.tmp:block 15 (paragraph)
#, fuzzy
msgid ""
"Two other options control optimization globally, including use of indices:"
msgstr ""
"Deux autres options permettent de contrôler l'optimisation de manière "
"globale, y compris l'utilisation d'indices :"

#: fr/datatable-benchmarking.Rmd.tmp:block 16 (code)
#, fuzzy
msgid ""
"options(datatable.optimize=2L)\n"
"options(datatable.optimize=3L)\n"
msgstr ""
"options(datatable.optimize=2L)\n"
"options(datatable.optimize=3L)\n"

#: fr/datatable-benchmarking.Rmd.tmp:block 17 (paragraph)
#, fuzzy
msgid ""
"`options(datatable.optimize=2L)` will turn off optimization of subsets "
"completely, while `options(datatable.optimize=3L)` will switch it back on. "
"Those options affect many more optimizations and thus should not be used "
"when only control of indices is needed. Read more in `?datatable.optimize`."
msgstr ""
"`options(datatable.optimize=2L)` désactivera complètement l'optimisation "
"des sous-ensembles, tandis que `options(datatable.optimize=3L)` la "
"réactivera. Ces options affectent beaucoup plus d'optimisations et ne "
"devraient donc pas être utilisées lorsque seul le contrôle des indices est "
"nécessaire. Plus d'informations dans `?datatable.optimize`."

#: fr/datatable-benchmarking.Rmd.tmp:block 18 (header)
#, fuzzy
msgid "*by reference* operations"
msgstr "*par référence* opérations"

#: fr/datatable-benchmarking.Rmd.tmp:block 19 (paragraph)
#, fuzzy
msgid ""
"When benchmarking `set*` functions it only makes sense to measure the first "
"run. These functions update their input by reference, so subsequent runs "
"will use the already-processed `data.table`, biasing the results."
msgstr ""
"Lors de l'évaluation des fonctions `set*`, il n'est utile de mesurer que la "
"première exécution. Ces fonctions mettent à jour leur entrée par référence, "
"donc les exécutions suivantes utiliseront le fichier `data.table` déjà "
"traité, ce qui faussera les résultats."

#: fr/datatable-benchmarking.Rmd.tmp:block 20 (paragraph)
#, fuzzy
msgid ""
"Protecting your `data.table` from being updated by reference operations can "
"be achieved using `copy` or `data.table:::shallow` functions. Be aware "
"`copy` might be very expensive as it needs to duplicate whole object. It is "
"unlikely we want to include duplication time in time of the actual task we "
"are benchmarking."
msgstr ""
"Protéger votre `data.table` d'une mise à jour par des opérations de "
"référence peut être réalisé en utilisant les fonctions `copy` ou `data."
"table:::shallow`. Soyez conscient que `copy` peut être très coûteux car il "
"doit dupliquer l'objet entier. Il est peu probable que nous voulions "
"inclure le temps de duplication dans le temps de la tâche réelle que nous "
"benchmarkons."

#: fr/datatable-benchmarking.Rmd.tmp:block 21 (header)
#, fuzzy
msgid "try to benchmark atomic processes"
msgstr "essayer d'étalonner les processus atomiques"

#: fr/datatable-benchmarking.Rmd.tmp:block 22 (paragraph)
#, fuzzy
msgid ""
"If your benchmark is meant to be published it will be much more insightful "
"if you will split it to measure time of atomic processes. This way your "
"readers can see how much time was spent on reading data from source, "
"cleaning, actual transformation, exporting results. Of course if your "
"benchmark is meant to present to present an *end-to-end workflow*, then it "
"makes perfect sense to present the overall timing. Nevertheless, separating "
"out timing of individual steps is useful for understanding which steps are "
"the main bottlenecks of a workflow. There are other cases when atomic "
"benchmarking might not be desirable, for example when *reading a csv*, "
"followed by *grouping*. R requires populating *R's global string cache* "
"which adds extra overhead when importing character data to an R session. On "
"the other hand, the *global string cache* might speed up processes like "
"*grouping*. In such cases when comparing R to other languages it might be "
"useful to include total timing."
msgstr ""
"Si votre analyse comparative est destinée à être publiée, elle sera "
"beaucoup plus utile si vous la divisez pour mesurer la durée des processus "
"atomiques. De cette manière, vos lecteurs pourront voir combien de temps a "
"été consacré à la lecture des données à partir de la source, au nettoyage, "
"à la transformation proprement dite et à l'exportation des résultats. Bien "
"sûr, si votre benchmark est destiné à présenter un *flux de travail de bout "
"en bout*, il est tout à fait logique de présenter le temps global. "
"Néanmoins, la séparation des temps des étapes individuelles est utile pour "
"comprendre quelles étapes sont les principaux goulots d'étranglement d'un "
"flux de travail. Il existe d'autres cas où le benchmarking atomique n'est "
"pas souhaitable, par exemple lors de la *lecture d'un csv*, suivie d'un "
"*regroupement*. R nécessite de remplir le *cache global de chaînes de "
"caractères de R*, ce qui ajoute une surcharge supplémentaire lors de "
"l'importation de données de caractères dans une session R. D'un autre côté, "
"le *cache global de chaînes de caractères* peut accélérer des processus "
"tels que le *regroupement*. Dans de tels cas, lorsque l'on compare R à "
"d'autres langages, il peut être utile d'inclure le temps total."

#: fr/datatable-benchmarking.Rmd.tmp:block 23 (header)
#, fuzzy
msgid "avoid class coercion"
msgstr "éviter la coercition de classe"

#: fr/datatable-benchmarking.Rmd.tmp:block 24 (paragraph)
#, fuzzy
msgid ""
"Unless this is what you truly want to measure you should prepare input "
"objects of the expected class for every tool you are benchmarking."
msgstr ""
"Si ce n'est pas ce que vous voulez vraiment mesurer, vous devez préparer "
"des objets d'entrée de la classe attendue pour chaque outil que vous "
"comparez."

#: fr/datatable-benchmarking.Rmd.tmp:block 25 (header)
#, fuzzy
msgid "avoid `microbenchmark(..., times=100)`"
msgstr "éviter `microbenchmark(..., times=100)`"

#: fr/datatable-benchmarking.Rmd.tmp:block 26 (paragraph)
#, fuzzy
msgid ""
"Repeating a benchmark many times usually does not give the clearest picture "
"for data processing tools. Of course, it makes perfect sense for more "
"atomic calculations, but this is not a good representation of the most "
"common way these tools will actually be used, namely for data processing "
"tasks, which consist of batches of sequentially provided transformations, "
"each run once. Matt once said:"
msgstr ""
"Répéter un benchmark plusieurs fois ne donne généralement pas l'image la "
"plus claire des outils de traitement des données. Bien sûr, c'est "
"parfaitement logique pour les calculs plus atomiques, mais ce n'est pas une "
"bonne représentation de la manière la plus courante dont ces outils seront "
"utilisés, à savoir pour les tâches de traitement des données, qui "
"consistent en des lots de transformations fournies de manière séquentielle, "
"chacune exécutée une fois. Matt a dit un jour :"

#: fr/datatable-benchmarking.Rmd.tmp:block 27 (quote)
#, fuzzy
msgid ""
"I'm very wary of benchmarks measured in anything under 1 second. Much "
"prefer 10 seconds or more for a single run, achieved by increasing data "
"size. A repetition count of 500 is setting off alarm bells. 3-5 runs should "
"be enough to convince on larger data. Call overhead and time to GC affect "
"inferences at this very small scale."
msgstr ""
"Je me méfie beaucoup des repères mesurés en moins d'une seconde. Je préfère "
"de loin 10 secondes ou plus pour une seule exécution, obtenues en "
"augmentant la taille des données. Un nombre de répétitions de 500 tire la "
"sonnette d'alarme. 3 à 5 exécutions devraient suffire à convaincre sur des "
"données plus importantes. Les frais d'appel et le temps nécessaire au GC "
"affectent les déductions à cette très petite échelle."

#: fr/datatable-benchmarking.Rmd.tmp:block 28 (paragraph)
#, fuzzy
msgid ""
"This is very valid. The smaller time measurement is the relatively bigger "
"noise is. Noise generated by method dispatch, package/class initialization, "
"etc. Main focus of benchmark should be on real use case scenarios."
msgstr ""
"Ceci est tout à fait valable. Plus la mesure du temps est petite, plus le "
"bruit est relativement important. Le bruit est généré par l'envoi de "
"méthodes, l'initialisation de paquets/classes, etc. Le benchmark devrait se "
"concentrer sur des scénarios d'utilisation réelle."

#: fr/datatable-benchmarking.Rmd.tmp:block 29 (header)
#, fuzzy
msgid "multithreaded processing"
msgstr "traitement multithread"

#: fr/datatable-benchmarking.Rmd.tmp:block 30 (paragraph)
#, fuzzy
msgid ""
"One of the main factors that is likely to impact timings is the number of "
"threads available to your R session. In recent versions of `data.table`, "
"some functions are parallelized. You can control the number of threads you "
"want to use with `setDTthreads`."
msgstr ""
"L'un des principaux facteurs susceptibles d'influer sur les délais est le "
"nombre de threads disponibles pour votre session R. Dans les versions "
"récentes de `data.table`, certaines fonctions sont parallélisées. Vous "
"pouvez contrôler le nombre de threads que vous voulez utiliser avec "
"`setDTthreads`."

#: fr/datatable-benchmarking.Rmd.tmp:block 31 (code)
#, fuzzy
msgid ""
"setDTthreads(0)    # use all available cores (default)\n"
"getDTthreads()     # check how many cores are currently used\n"
msgstr ""
"setDTthreads(0) # utilise tous les cœurs disponibles (par défaut)\n"
"getDTthreads() # vérifie combien de cœurs sont actuellement utilisés\n"

#: fr/datatable-benchmarking.Rmd.tmp:block 32 (header)
#, fuzzy
msgid "inside a loop prefer `set` instead of `:=`"
msgstr "à l'intérieur d'une boucle, préférez `set` au lieu de `:=`"

#: fr/datatable-benchmarking.Rmd.tmp:block 33 (paragraph)
#, fuzzy
msgid ""
"Unless you are utilizing index when doing *sub-assign by reference* you "
"should prefer `set` function which does not impose overhead of `[.data."
"table` method call."
msgstr ""
"A moins que vous n'utilisiez l'index en faisant *sub-assign by reference*, "
"vous devriez préférer la fonction `set` qui n'impose pas l'overhead de "
"l'appel à la méthode `[.data.table`."

#: fr/datatable-benchmarking.Rmd.tmp:block 34 (code)
#, fuzzy
msgid ""
"DT = data.table(a=3:1, b=letters[1:3])\n"
"setindex(DT, a)\n"
"\n"
"# for (...) {                 # imagine loop here\n"
"\n"
"  DT[a==2L, b := \"z\"]         # sub-assign by reference, uses index\n"
"  DT[, d := \"z\"]              # not sub-assign by reference, not uses "
"index and adds overhead of `[.data.table`\n"
"  set(DT, j=\"d\", value=\"z\")   # no `[.data.table` overhead, but no "
"index yet, till #1196\n"
"\n"
"# }\n"
msgstr ""
"DT = data.table(a=3:1, b=lettres[1:3])\n"
"setindex(DT, a)\n"
"\n"
"# for (...) { # imaginez une boucle ici\n"
"\n"
"  DT[a==2L, b := \"z\"] # sous-affectation par référence, utilise l'index\n"
"  DT[, d := \"z\"] # pas de sous-affectation par référence, n'utilise pas "
"l'index et ajoute la surcharge de `[.data.table`\n"
"  set(DT, j=\"d\", value=\"z\") # pas de surcharge `[.data.table`, mais pas "
"encore d'index, jusqu'à #1196\n"
"\n"
"# }\n"

#: fr/datatable-benchmarking.Rmd.tmp:block 35 (header)
#, fuzzy
msgid "inside a loop prefer `setDT` instead of `data.table()`"
msgstr ""
"à l'intérieur d'une boucle, préférez `setDT` au lieu de `data.table()`"

#: fr/datatable-benchmarking.Rmd.tmp:block 36 (paragraph)
#, fuzzy
msgid ""
"As of now `data.table()` has an overhead, thus inside loops it is preferred "
"to use `as.data.table()` or `setDT()` on a valid list."
msgstr ""
"Pour l'instant, `data.table()` a un surcoût, donc à l'intérieur des "
"boucles, il est préférable d'utiliser `as.data.table()` ou `setDT()` sur "
"une liste valide."
