#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.4.4\n"

#: fr/datatable-faq.Rmd.tmp:block 1 (code)
msgid ""
"title: \"Frequently Asked Questions about data.table\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"  markdown::html_format:\n"
"    options:\n"
"      toc: true\n"
"      number_sections: true\n"
"    meta:\n"
"      css: [default, css/toc.css]\n"
"vignette: >\n"
"  %\\VignetteIndexEntry{Frequently Asked Questions about data.table}\n"
"  %\\VignetteEngine{knitr::knitr}\n"
"  \\usepackage[utf8]{inputenc}\n"
msgstr ""
"title: \"Foire aux questions sur data.table\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"  markdown::html_format :\n"
"    options:\n"
"      toc: true\n"
"      number_sections: true\n"
"    meta:\n"
"      css: [default, ../css/toc.css]\n"
"vignette: >\n"
"  %\\VignetteIndexEntry{Foire aux questions sur data.table}\n"
"  %\\VignetteEngine{knitr::knitr}\n"
"  \\usepackage[utf8]{inputenc}\n"

#: fr/datatable-faq.Rmd.tmp:block 3 (code)
msgid ""
"#===== r, echo = FALSE, message = FALSE\n"
"library(data.table)\n"
"knitr::opts_chunk$set(\n"
"  comment = \"#\",\n"
"    error = FALSE,\n"
"     tidy = FALSE,\n"
"    cache = FALSE,\n"
" collapse = TRUE)\n"
".old.th = setDTthreads(1)\n"
msgstr ""
"#===== r, echo = FALSE, message = FALSE\n"
"library(data.table)\n"
"knitr::opts_chunk$set(\n"
"  comment = \"#\",\n"
"    error = FALSE,\n"
"     tidy = FALSE,\n"
"    cache = FALSE,\n"
" collapse = TRUE)\n"
".old.th = setDTthreads(1)\n"

#: fr/datatable-faq.Rmd.tmp:block 4 (paragraph)
#, fuzzy
msgid ""
"The first section, Beginner FAQs, is intended to be read in order, from start "
"to finish. It's just written in a FAQ style to be digested more easily. It "
"isn't really the most frequently asked questions. A better measure for that "
"is looking on Stack Overflow."
msgstr ""
"La première section, FAQ pour débutants, est destinée à être lue dans "
"l'ordre, du début à la fin. Elle est simplement rédigée dans le style d'une "
"FAQ afin d'être plus facile à assimiler. Il ne s'agit pas vraiment des "
"questions les plus fréquemment posées. Une meilleure mesure pour cela est de "
"regarder sur Stack Overflow."

#: fr/datatable-faq.Rmd.tmp:block 5 (paragraph)
#, fuzzy
msgid ""
"This FAQ is required reading and considered core documentation. Please do not "
"ask questions on Stack Overflow or raise issues on GitHub until you have read "
"it. We can all tell when you ask that you haven't read it. So if you do ask "
"and haven't read it, don't use your real name."
msgstr ""
"Cette FAQ est une lecture obligatoire et est considérée comme une "
"documentation de base. Ne posez pas de questions sur Stack Overflow ou ne "
"soulevez pas de problèmes sur GitHub avant de l'avoir lue. Nous savons tous "
"que vous n'avez pas lu la FAQ lorsque vous posez une question. Si vous posez "
"une question sans l'avoir lue, n'utilisez pas votre vrai nom."

#: fr/datatable-faq.Rmd.tmp:block 6 (paragraph)
#, fuzzy
msgid ""
"This document has been quickly revised given the changes in v1.9.8 released "
"Nov 2016. Please do submit pull requests to fix mistakes or improvements. If "
"anyone knows why the table of contents comes out so narrow and squashed when "
"displayed by CRAN, please let us know. This document used to be a PDF and we "
"changed it recently to HTML."
msgstr ""
"Ce document a été rapidement révisé en fonction des changements apportés à la "
"version 1.9.8 publiée en novembre 2016. N'hésitez pas à soumettre des pull "
"requests pour corriger des erreurs ou des améliorations. Si quelqu'un sait "
"pourquoi la table des matières est si étroite et écrasée lorsqu'elle est "
"affichée par le CRAN, merci de nous le faire savoir. Ce document était "
"auparavant un PDF et nous l'avons récemment changé en HTML."

#: fr/datatable-faq.Rmd.tmp:block 7 (header)
#, fuzzy
msgid "Beginner FAQs"
msgstr "FAQ pour les débutants"

#: fr/datatable-faq.Rmd.tmp:block 8 (header)
#, fuzzy
msgid ""
"Why do `DT[ , 5]` and `DT[2, 5]` return a 1-column data.table rather than "
"vectors like `data.frame`? {#j-num}"
msgstr ""
"Pourquoi `DT[ , 5]` et `DT[2, 5]` renvoient-ils un data.table à une colonne "
"plutôt que des vecteurs comme `data.frame` ? {#j-num}"

#: fr/datatable-faq.Rmd.tmp:block 9 (paragraph)
#, fuzzy
msgid ""
"For consistency so that when you use data.table in functions that accept "
"varying inputs, you can rely on `DT[...]` returning a data.table. You don't "
"have to remember to include `drop=FALSE` like you do in data.frame. data."
"table was first released in 2006 and this difference to data.frame has been a "
"feature since the very beginning."
msgstr ""
"Pour des raisons de cohérence, lorsque vous utilisez data.table dans des "
"fonctions qui acceptent des entrées variables, vous pouvez compter sur "
"`DT[...]` qui renvoie un data.table. Vous n'avez pas à vous souvenir "
"d'inclure `drop=FALSE` comme vous le faites dans data.frame. data.table a été "
"publié pour la première fois en 2006 et cette différence avec data.frame a "
"été une caractéristique depuis le tout début."

#: fr/datatable-faq.Rmd.tmp:block 10 (paragraph)
#, fuzzy
msgid ""
"You may have heard that it is generally bad practice to refer to columns by "
"number rather than name, though. If your colleague comes along and reads your "
"code later they may have to hunt around to find out which column is number 5. "
"If you or they change the column ordering higher up in your R program, you "
"may produce wrong results with no warning or error if you forget to change "
"all the places in your code which refer to column number 5. That is your "
"fault not R's or data.table's. It's really really bad. Please don't do it. "
"It's the same mantra as professional SQL developers have: never use `select "
"*`, always explicitly select by column name to at least try to be robust to "
"future changes."
msgstr ""
"Vous avez peut-être entendu dire qu'il n'est généralement pas judicieux de "
"désigner les colonnes par leur numéro plutôt que par leur nom. Si votre "
"collègue vient à lire votre code plus tard, il devra peut-être chercher à "
"savoir quelle colonne porte le numéro 5. Si vous ou lui changez l'ordre des "
"colonnes plus haut dans votre programme R, vous risquez de produire des "
"résultats erronés sans avertissement ni erreur si vous oubliez de modifier "
"tous les endroits de votre code qui font référence à la colonne numéro 5. "
"C'est votre faute, pas celle de R ou de data.table. C'est vraiment très "
"mauvais. S'il vous plaît, ne le faites pas. C'est le même mantra que celui "
"des développeurs SQL professionnels : ne jamais utiliser `select *`, toujours "
"sélectionner explicitement par le nom de la colonne pour au moins essayer "
"d'être robuste aux changements futurs."

#: fr/datatable-faq.Rmd.tmp:block 11 (paragraph)
#, fuzzy
msgid ""
"Say column 5 is named `\"region\"` and you really must extract that column as "
"a vector not a data.table. It is more robust to use the column name and write "
"`DT$region` or `DT[[\"region\"]]`; i.e., the same as base R. Using base R's "
"`$` and `[[` on data.table is encouraged. Not when combined with `<-` to "
"assign (use `:=` instead for that) but just to select a single column by name "
"they are encouraged."
msgstr ""
"Disons que la colonne 5 s'appelle \"region\" et que vous devez vraiment "
"extraire cette colonne en tant que vecteur et non en tant que data.table. Il "
"est plus robuste d'utiliser le nom de la colonne et d'écrire `DT$region` ou "
"`DT[\"region\"]]` ; c'est à dire, la même chose que R de base. Pas lorsqu'ils "
"sont combinés avec `<-` pour assigner (utilisez `:=` à la place pour cela) "
"mais juste pour sélectionner une seule colonne par son nom, ils sont "
"encouragés."

#: fr/datatable-faq.Rmd.tmp:block 12 (paragraph)
#, fuzzy
msgid ""
"There are some circumstances where referring to a column by number seems like "
"the only way, such as a sequence of columns. In these situations just like "
"data.frame, you can write `DT[, 5:10]` and `DT[,c(1,4,10)]`. However, again, "
"it is more robust (to future changes in your data's number of and ordering of "
"columns) to use a named range such as `DT[,columnRed:columnViolet]` or name "
"each one `DT[,c(\"columnRed\",\"columnOrange\",\"columnYellow\")]`. It is "
"harder work up front, but you will probably thank yourself and your "
"colleagues might thank you in the future. At least you can say you tried your "
"best to write robust code if something does go wrong."
msgstr ""
"Il y a des circonstances où se référer à une colonne par un numéro semble "
"être la seule façon, comme une séquence de colonnes. Dans ces situations, "
"tout comme data.frame, vous pouvez écrire `DT[, 5:10]` et `DT[,c(1,4,10)]`. "
"Cependant, encore une fois, il est plus robuste (face à de futurs changements "
"dans le nombre et l'ordre des colonnes de vos données) d'utiliser une plage "
"nommée comme `DT[,columnRed:columnViolet]` ou de nommer chacune `DT[,"
"c(\"columnRed\", \"columnOrange\", \"columnYellow\")]`. C'est un travail plus "
"difficile au départ, mais vous vous en féliciterez probablement et vos "
"collègues vous en remercieront peut-être à l'avenir. Au moins, vous pourrez "
"dire que vous avez fait de votre mieux pour écrire un code robuste en cas de "
"problème."

#: fr/datatable-faq.Rmd.tmp:block 13 (paragraph)
#, fuzzy
msgid ""
"However, what we really want you to do is `DT[,.(columnRed,columnOrange,"
"columnYellow)]`; i.e., use column names as if they are variables directly "
"inside `DT[...]`. You don't have to prefix each column with `DT$` like you do "
"in data.frame. The `.()` part is just an alias for `list()` and you can use "
"`list()` instead if you prefer. You can place any R expression of column "
"names, using any R package, returning different types of different lengths, "
"right there. We wanted to encourage you to do that so strongly in the past "
"that we deliberately didn't make `DT[,5]` work at all. Before v1.9.8 released "
"Nov 2016, `DT[,5]` used to just return `5`. The thinking was that we could "
"more simply teach one fact that the parts inside `DT[...]` get evaluated "
"within the frame of DT always (they see column names as if they are "
"variables). And `5` evaluates to `5` so that behaviour was consistent with "
"the single rule. We asked you to go through an extra deliberate hurdle `DT[,5,"
"with=FALSE]` if you really wanted to select a column by name or number. Going "
"forward from Nov 2016, you don't need to use `with=FALSE` and we'll see how "
"greater consistency with data.frame in this regard will help or hinder both "
"new and long-time users. The new users who don't read this FAQ, not even this "
"very first entry, will hopefully not stumble as soon with data.table as they "
"did before if they had expected it to work like data.frame. Hopefully they "
"will not miss out on understanding our intent and recommendation to place "
"expressions of columns inside `DT[i, j, by]`. If they use data.table like "
"data.frame they won't gain any benefits. If you know anyone like that, please "
"give them a friendly nudge to read this document like you are."
msgstr ""
"Cependant, ce que nous voulons vraiment que vous fassiez est `DT[,."
"(colonneRouge,colonneOrange,colonneJaune)]` ; c'est-à-dire, utiliser les noms "
"de colonnes comme s'ils étaient des variables directement à l'intérieur de "
"`DT[...]`. Vous n'avez pas besoin de préfixer chaque colonne avec `DT$` comme "
"vous le faites dans data.frame. La partie `.()` est juste un alias pour "
"`list()` et vous pouvez utiliser `list()` à la place si vous préférez. Vous "
"pouvez placer n'importe quelle expression R de noms de colonnes, en utilisant "
"n'importe quel package R, retournant différents types de longueurs "
"différentes, juste ici. Nous voulions tellement vous encourager à le faire "
"dans le passé que nous avons délibérément fait en sorte que `DT[,5]` ne "
"fonctionne pas du tout. Avant la version 1.9.8 publiée en novembre 2016, "
"`DT[,5]` retournait simplement `5`. L'idée était d'enseigner plus simplement "
"que les parties à l'intérieur de `DT[...]` sont toujours évaluées dans le "
"cadre de DT (ils voient les noms de colonnes comme s'il s'agissait de "
"variables). Et `5` est évalué à `5`, de sorte que ce comportement est "
"cohérent avec la règle unique. Nous vous avons demandé de passer par un "
"obstacle supplémentaire délibéré `DT[,5,with=FALSE]` si vous vouliez vraiment "
"sélectionner une colonne par nom ou par nombre. A partir de Nov 2016, vous "
"n'aurez plus besoin d'utiliser `with=FALSE` et nous verrons comment une plus "
"grande cohérence avec data.frame à cet égard aidera ou gênera les nouveaux "
"utilisateurs et les utilisateurs de longue date. Les nouveaux utilisateurs "
"qui ne lisent pas cette FAQ, pas même cette toute première entrée, ne "
"trébucheront pas aussi vite avec data.table qu'ils l'ont fait auparavant "
"s'ils s'attendaient à ce qu'il fonctionne comme data.frame. Nous espérons "
"qu'ils ne manqueront pas de comprendre notre intention et notre "
"recommandation de placer les expressions de colonnes à l'intérieur de `DT[i, "
"j, by]`. S'ils utilisent data.table comme data.frame, ils n'en tireront aucun "
"bénéfice. Si vous connaissez quelqu'un dans ce cas, donnez-lui un coup de "
"pouce amical pour qu'il lise ce document comme vous le faites."

#: fr/datatable-faq.Rmd.tmp:block 14 (paragraph)
#, fuzzy
msgid ""
"Reminder: you can place *any* R expression inside `DT[...]` using column "
"names as if they are variables; e.g., try `DT[, colA*colB/2]`. That does "
"return a vector because you used column names as if they are variables. Wrap "
"with `.()` to return a data.table; i.e. `DT[,.(colA*colB/2)]`. Name it: `DT[,."
"(myResult = colA*colB/2)]`. And we'll leave it to you to guess how to return "
"two things from this query. It's also quite common to do a bunch of things "
"inside an anonymous body: `DT[, { x<-colA+10; x*x/2 }]` or call another "
"package's function: `DT[ , fitdistr(columnA, \"normal\")]`."
msgstr ""
"Rappel : vous pouvez placer *n'importe quelle* expression R à l'intérieur de "
"`DT[...]` en utilisant les noms de colonnes comme s'il s'agissait de "
"variables ; par exemple, essayez `DT[, colA*colB/2]`. Cela renvoie un vecteur "
"parce que vous avez utilisé les noms de colonnes comme s'il s'agissait de "
"variables. Enveloppez avec `.()` pour retourner un data.table ; i.e. `DT[,."
"(colA*colB/2)]`. Nommez-le : `DT[,.(myResult = colA*colB/2)]`. Et nous vous "
"laissons deviner comment retourner deux choses à partir de cette requête. Il "
"est aussi assez courant de faire un tas de choses à l'intérieur d'un corps "
"anonyme : `DT[, { x<-colA+10 ; x*x/2 }]` ou d'appeler une fonction d'un autre "
"package : `DT[ , fitdistr(columnA, \"normal\")]`."

#: fr/datatable-faq.Rmd.tmp:block 15 (header)
#, fuzzy
msgid ""
"Why does `DT[,\"region\"]` return a 1-column data.table rather than a vector?"
msgstr ""
"Pourquoi `DT[, \"region\"]` renvoie-t-il un data.table à une colonne plutôt "
"qu'un vecteur ?"

#: fr/datatable-faq.Rmd.tmp:block 16 (paragraph)
#, fuzzy
msgid ""
"See the [answer above](#j-num). Try `DT$region` instead. Or "
"`DT[[\"region\"]]`."
msgstr ""
"Voir la [réponse ci-dessus](#j-num). Essayez `DT$region` à la place. Ou "
"`DT[[\"region\"]]`."

#: fr/datatable-faq.Rmd.tmp:block 17 (header)
#, fuzzy
msgid ""
"Why does `DT[, region]` return a vector for the \"region\" column? I'd like a "
"1-column data.table."
msgstr ""
"Pourquoi `DT[, region]` retourne un vecteur pour la colonne \"region\" ? Je "
"voudrais un data.table à 1 colonne."

#: fr/datatable-faq.Rmd.tmp:block 18 (paragraph)
#, fuzzy
msgid ""
"Try `DT[ , .(region)]` instead. `.()` is an alias for `list()` and ensures a "
"data.table is returned."
msgstr ""
"Essayez plutôt `DT[ , .(region)]`. `.()` est un alias de `list()` et assure "
"qu'une table de données est retournée."

#: fr/datatable-faq.Rmd.tmp:block 19 (paragraph)
#, fuzzy
msgid ""
"Also continue reading and see the FAQ after next. Skim whole documents before "
"getting stuck in one part."
msgstr ""
"Poursuivez également votre lecture et consultez la FAQ qui suit. Parcourez "
"des documents entiers avant de rester bloqué sur une partie."

#: fr/datatable-faq.Rmd.tmp:block 20 (header)
#, fuzzy
msgid ""
"Why does `DT[ , x, y, z]` not work? I wanted the 3 columns `x`,`y` and `z`."
msgstr ""
"Pourquoi `DT[ , x, y, z]` ne fonctionne pas ? Je voulais les 3 colonnes `x`,"
"`y` et `z`."

#: fr/datatable-faq.Rmd.tmp:block 21 (paragraph)
#, fuzzy
msgid ""
"The `j` expression is the 2nd argument. Try `DT[ , c(\"x\",\"y\",\"z\")]` or "
"`DT[ , .(x,y,z)]`."
msgstr ""
"L'expression `j` est le 2ème argument. Essayez `DT[ , c(\"x\", \"y\", "
"\"z\")]` ou `DT[ , .(x,y,z)]`."

#: fr/datatable-faq.Rmd.tmp:block 22 (header)
#, fuzzy
msgid ""
"I assigned a variable `mycol=\"x\"` but then `DT[, mycol]` returns an error. "
"How do I get it to look up the column name contained in the `mycol` variable?"
msgstr ""
"J'ai assigné une variable `mycol=\"x\"` mais `DT[, mycol]` renvoie une "
"erreur. Comment faire pour qu'il recherche le nom de la colonne contenue dans "
"la variable `mycol` ?"

#: fr/datatable-faq.Rmd.tmp:block 23 (paragraph)
#, fuzzy
msgid ""
"The error is that column named `\"mycol\"` cannot be found, and this error is "
"correct. `data.table`'s scoping is different to `data.frame` in that you can "
"use column names as if they are variables directly inside `DT[...]` without "
"prefixing each column name with `DT$`; see FAQ 1.1 above."
msgstr ""
"L'erreur est que la colonne nommée `\"mycol\"` ne peut pas être trouvée, et "
"cette erreur est correcte. la portée de `data.table` est différente de celle "
"de `data.frame` dans la mesure où vous pouvez utiliser les noms de colonnes "
"comme s'il s'agissait de variables directement à l'intérieur de `DT[...]` "
"sans préfixer chaque nom de colonne par `DT$` ; voir la FAQ 1.1 ci-dessus."

#: fr/datatable-faq.Rmd.tmp:block 24 (paragraph)
#, fuzzy
msgid ""
"To use `mycol` to select the column `x` from `DT`, there are a few options:"
msgstr ""
"Pour utiliser `mycol` afin de sélectionner la colonne `x` de `DT`, il y a "
"quelques options :"

#: fr/datatable-faq.Rmd.tmp:block 25 (code)
#, fuzzy
msgid ""
"DT[, ..mycol]            # .. prefix conveys to look for the mycol one level "
"up in calling scope\n"
"DT[, mycol, with=FALSE]  # revert to data.frame behavior\n"
"DT[[mycol]]               # treat DT as a list and use [[ from base R\n"
msgstr ""
"DT[, ..mycol] # ... préfixe indique qu'il faut rechercher le mycol un niveau "
"plus haut dans l'étendue de l'appel\n"
"DT[, mycol, with=FALSE] # revient au comportement data.frame\n"
"DT[[mycol]]               # traiter DT comme une liste et utiliser [[ de la "
"base R\n"

#: fr/datatable-faq.Rmd.tmp:block 26 (paragraph)
#, fuzzy
msgid "See `?data.table` for more details about the `..` prefix."
msgstr "Voir `?data.table` pour plus de détails sur le préfixe `..`."

#: fr/datatable-faq.Rmd.tmp:block 27 (paragraph)
#, fuzzy
msgid ""
"The `with` argument takes its name from the `base` function `with()`. When "
"`with=TRUE` (default), `data.table` operates similar to `with()`, i.e. `DT[, "
"mycol]` behaves like `with(DT, mycol)`. When `with=FALSE`, the standard `data."
"frame` evaluation rules apply to all variables in `j` and you can no longer "
"use column names directly."
msgstr ""
"L'argument `with` tire son nom de la fonction `base` `with()`. Lorsque "
"`with=TRUE` (par défaut), `data.table` fonctionne de manière similaire à "
"`with()`, c'est-à-dire que `DT[, mycol]` se comporte comme `with(DT, mycol)`. "
"Lorsque `with=FALSE`, les règles d'évaluation standard de `data.frame` "
"s'appliquent à toutes les variables de `j` et vous ne pouvez plus utiliser "
"les noms de colonnes directement."

#: fr/datatable-faq.Rmd.tmp:block 28 (header)
#, fuzzy
msgid ""
"What are the benefits of being able to use column names as if they are "
"variables inside `DT[...]`?"
msgstr ""
"Quels sont les avantages de pouvoir utiliser les noms de colonnes comme s'il "
"s'agissait de variables à l'intérieur de `DT[...]` ?"

#: fr/datatable-faq.Rmd.tmp:block 29 (paragraph)
#, fuzzy
msgid ""
"`j` doesn't have to be just column names. You can write any R *expression* of "
"column names directly in `j`, *e.g.*, `DT[ , mean(x*y/z)]`. The same applies "
"to `i`, *e.g.*, `DT[x>1000, sum(y*z)]`."
msgstr ""
"`j` n'a pas besoin d'être uniquement un nom de colonne. Vous pouvez écrire "
"n'importe quelle *expression* R de noms de colonnes directement dans `j`, *e."
"g.*, `DT[ , mean(x*y/z)]`. La même chose s'applique à `i`, *e.g.*, "
"`DT[x>1000, sum(y*z)]`."

#: fr/datatable-faq.Rmd.tmp:block 30 (paragraph)
#, fuzzy
msgid ""
"This runs the `j` expression on the set of rows where the `i` expression is "
"true. You don't even need to return data, *e.g.*, `DT[x>1000, plot(y, z)]`. "
"You can do `j` by group simply by adding `by = `; e.g., `DT[x>1000, sum(y*z), "
"by = w]`. This runs `j` for each group in column `w` but just over the rows "
"where `x>1000`. By placing the 3 parts of the query (i=where, j=select and "
"by=group by) inside the square brackets, data.table sees this query as a "
"whole before any part of it is evaluated. Thus it can optimize the combined "
"query for performance. It can do this because the R language uniquely has "
"lazy evaluation (Python and Julia do not). data.table sees the expressions "
"inside `DT[...]` before they are evaluated and optimizes them before "
"evaluation. For example, if data.table see that you're only using 2 columns "
"out of 100, it won't bother to subset the 98 that aren't needed by your j "
"expression."
msgstr ""
"Ceci exécute l'expression `j` sur l'ensemble des lignes où l'expression `i` "
"est vraie. Vous n'avez même pas besoin de renvoyer des données, *e.g.*, "
"`DT[x>1000, plot(y, z)]`. Vous pouvez faire `j` par groupe en ajoutant "
"simplement `by = ` ; par exemple, `DT[x>1000, sum(y*z), by = w]`. Ceci "
"exécute `j` pour chaque groupe dans la colonne `w` mais seulement sur les "
"lignes où `x>1000`. En plaçant les 3 parties de la requête (i=where, j=select "
"et by=group by) à l'intérieur des crochets, data.table voit cette requête "
"comme un tout avant qu'aucune partie ne soit évaluée. Il peut ainsi optimiser "
"les performances de la requête combinée. Il peut le faire parce que le "
"langage R dispose uniquement d'une évaluation paresseuse (ce qui n'est pas le "
"cas de Python et de Julia). data.table voit les expressions à l'intérieur de "
"`DT[...]` avant qu'elles ne soient évaluées et les optimise avant "
"l'évaluation. Par exemple, si data.table voit que vous n'utilisez que 2 "
"colonnes sur 100, il ne s'embêtera pas à sous-sélectionner les 98 qui ne sont "
"pas nécessaires à votre expression j."

#: fr/datatable-faq.Rmd.tmp:block 31 (header)
#, fuzzy
msgid ""
"OK, I'm starting to see what data.table is about, but why didn't you just "
"enhance `data.frame` in R? Why does it have to be a new package?"
msgstr ""
"OK, je commence à comprendre ce qu'est data.table, mais pourquoi n'avez-vous "
"pas simplement amélioré `data.frame` dans R ? Pourquoi faut-il que ce soit un "
"nouveau package ?"

#: fr/datatable-faq.Rmd.tmp:block 32 (paragraph)
#, fuzzy
msgid ""
"As [highlighted above](#j-num), `j` in `[.data.table` is fundamentally "
"different from `j` in `[.data.frame`. Even if something as simple as `DF[ , "
"1]` was changed in base R to return a data.frame rather than a vector, that "
"would break existing code in many 1000's of CRAN packages and user code. As "
"soon as we took the step to create a new class that inherited from data."
"frame, we had the opportunity to change a few things and we did. We want data."
"table to be slightly different and to work this way for more complicated "
"syntax to work. There are other differences, too (see [below]"
"(#SmallerDiffs) )."
msgstr ""
"Comme [souligné ci-dessus] (#j-num), `j` dans `[.data.table` est "
"fondamentalement différent de `j` dans `[.data.frame`. Même si quelque chose "
"d'aussi simple que `DF[ , 1]` était modifié dans la base R pour retourner un "
"data.frame plutôt qu'un vecteur, cela casserait le code existant dans des "
"milliers de paquets CRAN et dans le code utilisateur. Dès que nous avons pris "
"la décision de créer une nouvelle classe héritant de data.frame, nous avons "
"eu l'opportunité de changer certaines choses et nous l'avons fait. Nous "
"voulons que data.table soit légèrement différent et qu'il fonctionne de cette "
"façon pour que la syntaxe plus compliquée fonctionne. Il existe également "
"d'autres différences (voir [ci-dessous](#PetitesDifférences) )."

#: fr/datatable-faq.Rmd.tmp:block 33 (paragraph)
#, fuzzy
msgid ""
"Furthermore, data.table *inherits* from `data.frame`. It *is* a `data.frame`, "
"too. A data.table can be passed to any package that only accepts `data.frame` "
"and that package can use `[.data.frame` syntax on the data.table. See [this "
"answer](https://stackoverflow.com/a/10529888/403310) for how that is achieved."
msgstr ""
"De plus, data.table *hérite* de `data.frame`. C'est aussi *un `data.frame`. "
"Un data.table peut être passé à n'importe quel paquet qui n'accepte que `data."
"frame` et ce paquet peut utiliser la syntaxe `[.data.frame` sur le data."
"table. Voir [cette réponse] (https://stackoverflow.com/a/10529888/403310) "
"pour savoir comment procéder."

#: fr/datatable-faq.Rmd.tmp:block 34 (paragraph)
#, fuzzy
msgid ""
"We *have* proposed enhancements to R wherever possible, too. One of these was "
"accepted as a new feature in R 2.12.0:"
msgstr ""
"Nous avons également proposé des améliorations à R chaque fois que cela était "
"possible. L'une d'entre elles a été acceptée comme nouvelle fonctionnalité "
"dans R 2.12.0 :"

#: fr/datatable-faq.Rmd.tmp:block 35 (quote)
#, fuzzy
msgid ""
"`unique()` and `match()` are now faster on character vectors where all "
"elements are in the global CHARSXP cache and have unmarked encoding (ASCII). "
"Thanks to Matt Dowle for suggesting improvements to the way the hash code is "
"generated in unique.c."
msgstr ""
"`unique()` et `match()` sont maintenant plus rapides sur les vecteurs de "
"caractères où tous les éléments sont dans le cache global CHARSXP et ont un "
"encodage non marqué (ASCII). Merci à Matt Dowle pour avoir suggéré des "
"améliorations dans la façon dont le code de hachage est généré dans unique.c."

#: fr/datatable-faq.Rmd.tmp:block 36 (paragraph)
#, fuzzy
msgid ""
"A second proposal was to use `memcpy` in duplicate.c, which is much faster "
"than a for loop in C. This would improve the *way* that R copies data "
"internally (on some measures by 13 times). The thread on r-devel is [here]"
"(https://stat.ethz.ch/pipermail/r-devel/2010-April/057249.html)."
msgstr ""
"Une deuxième proposition était d'utiliser `memcpy` dans duplicate.c, qui est "
"beaucoup plus rapide qu'une boucle for en C. Cela améliorerait la *manière* "
"dont R copie les données en interne (sur certaines mesures, de 13 fois). Le "
"fil de discussion sur r-devel est [ici] (https://stat.ethz.ch/pipermail/r-"
"devel/2010-April/057249.html)."

#: fr/datatable-faq.Rmd.tmp:block 37 (paragraph)
#, fuzzy
msgid ""
"A third more significant proposal that was accepted is that R now uses data."
"table's radix sort code as from R 3.3.0:"
msgstr ""
"Une troisième proposition plus significative qui a été acceptée est que R "
"utilise maintenant le code de tri radix de data.table à partir de R 3.3.0 :"

#: fr/datatable-faq.Rmd.tmp:block 38 (quote)
#, fuzzy
msgid ""
"The radix sort algorithm and implementation from data.table (forder) replaces "
"the previous radix (counting) sort and adds a new method for order(). "
"Contributed by Matt Dowle and Arun Srinivasan, the new algorithm supports "
"logical, integer (even with large values), real, and character vectors. It "
"outperforms all other methods, but there are some caveats (see ?sort)."
msgstr ""
"L'algorithme de tri radix et l'implémentation de data.table (forder) remplace "
"l'ancien tri radix (comptage) et ajoute une nouvelle méthode pour order(). "
"Contribué par Matt Dowle et Arun Srinivasan, le nouvel algorithme supporte "
"les vecteurs logiques, entiers (même avec de grandes valeurs), réels et de "
"caractères. Il est plus performant que toutes les autres méthodes, mais il y "
"a quelques mises en garde (voir ?sort)."

#: fr/datatable-faq.Rmd.tmp:block 39 (paragraph)
#, fuzzy
msgid ""
"This was big event for us and we celebrated until the cows came home. (Not "
"really.)"
msgstr ""
"C'était un grand événement pour nous et nous l'avons fêté jusqu'à ce que les "
"vaches rentrent à la maison. (Pas vraiment.)"

#: fr/datatable-faq.Rmd.tmp:block 40 (header)
#, fuzzy
msgid "Why are the defaults the way they are? Why does it work the way it does?"
msgstr ""
"Pourquoi les valeurs par défaut sont-elles telles qu'elles sont ? Pourquoi le "
"système fonctionne-t-il comme il le fait ?"

#: fr/datatable-faq.Rmd.tmp:block 41 (paragraph)
#, fuzzy
msgid ""
"The simple answer is because the main author originally designed it for his "
"own use. He wanted it that way. He finds it a more natural, faster way to "
"write code, which also executes more quickly."
msgstr ""
"La réponse est simple : l'auteur principal l'a conçu à l'origine pour son "
"propre usage. C'est ce qu'il voulait. Il trouve que c'est une façon plus "
"naturelle et plus rapide d'écrire du code, qui s'exécute également plus "
"rapidement."

#: fr/datatable-faq.Rmd.tmp:block 42 (header)
#, fuzzy
msgid "Isn't this already done by `with()` and `subset()` in `base`?"
msgstr "N'est-ce pas déjà fait par `with()` et `subset()` dans `base` ?"

#: fr/datatable-faq.Rmd.tmp:block 43 (paragraph)
#, fuzzy
msgid ""
"Some of the features discussed so far are, yes. The package builds upon base "
"functionality. It does the same sorts of things but with less code required "
"and executes many times faster if used correctly."
msgstr ""
"Certaines des caractéristiques discutées jusqu'à présent sont, oui. Le paquet "
"s'appuie sur la fonctionnalité de base. Il fait le même genre de choses, mais "
"avec moins de code et s'exécute beaucoup plus rapidement s'il est utilisé "
"correctement."

#: fr/datatable-faq.Rmd.tmp:block 44 (header)
#, fuzzy
msgid ""
"Why does `X[Y]` return all the columns from `Y` too? Shouldn't it return a "
"subset of `X`?"
msgstr ""
"Pourquoi `X[Y]` retourne-t-il aussi toutes les colonnes de `Y` ? Ne devrait-"
"elle pas retourner un sous-ensemble de `X` ?"

#: fr/datatable-faq.Rmd.tmp:block 45 (paragraph)
#, fuzzy
msgid ""
"This was changed in v1.5.3 (Feb 2011). Since then `X[Y]` includes `Y`'s non-"
"join columns. We refer to this feature as *join inherited scope* because not "
"only are `X` columns available to the `j` expression, so are `Y` columns. The "
"downside is that `X[Y]` is less efficient since every item of `Y`'s non-join "
"columns are duplicated to match the (likely large) number of rows in `X` that "
"match. We therefore strongly encourage `X[Y, j]` instead of `X[Y]`. See [next "
"FAQ](#MergeDiff)."
msgstr ""
"Cela a été modifié dans la version 1.5.3 (février 2011). Depuis lors, `X[Y]` "
"inclut les colonnes non-jointes de `Y`. Nous nous référons à cette "
"fonctionnalité comme *join inherited scope* parce que non seulement les "
"colonnes `X` sont disponibles pour l'expression `j`, mais les colonnes `Y` le "
"sont aussi. L'inconvénient est que `X[Y]` est moins efficace puisque chaque "
"élément des colonnes non-jointes de `Y` est dupliqué pour correspondre au "
"nombre (probablement grand) de lignes dans `X` qui correspondent. Nous "
"encourageons donc fortement l'utilisation de `X[Y, j]` au lieu de `X[Y]`. "
"Voir [FAQ suivante](#MergeDiff)."

#: fr/datatable-faq.Rmd.tmp:block 46 (header)
#, fuzzy
msgid "What is the difference between `X[Y]` and `merge(X, Y)`? {#MergeDiff}"
msgstr "Quelle est la différence entre `X[Y]` et `merge(X, Y)` ? {#MergeDiff}"

#: fr/datatable-faq.Rmd.tmp:block 47 (paragraph)
#, fuzzy
msgid ""
"`X[Y]` is a join, looking up `X`'s rows using `Y` (or `Y`'s key if it has "
"one) as an index."
msgstr ""
"`X[Y]` est une jointure, qui recherche les lignes de `X` en utilisant `Y` (ou "
"la clé de `Y` si elle en a une) comme index."

#: fr/datatable-faq.Rmd.tmp:block 48 (paragraph)
#, fuzzy
msgid ""
"`Y[X]` is a join, looking up `Y`'s rows using `X` (or `X`'s key if it has "
"one) as an index."
msgstr ""
"`Y[X]` est une jointure, qui recherche les lignes de `Y` en utilisant `X` (ou "
"la clé de `X` si elle en a une) comme index."

#: fr/datatable-faq.Rmd.tmp:block 49 (paragraph)
#, fuzzy
msgid ""
"`merge(X,Y)`[^1] does both ways at the same time. The number of rows of "
"`X[Y]` and `Y[X]` usually differ, whereas the number of rows returned by "
"`merge(X, Y)` and `merge(Y, X)` is the same."
msgstr ""
"`merge(X,Y)`[^1] fait les deux en même temps. Le nombre de lignes de `X[Y]` "
"et de `Y[X]` est généralement différent, alors que le nombre de lignes "
"retournées par `merge(X, Y)` et `merge(Y, X)` est le même."

#: fr/datatable-faq.Rmd.tmp:block 50 (paragraph)
#, fuzzy
msgid ""
"*BUT* that misses the main point. Most tasks require something to be done on "
"the data after a join or merge. Why merge all the columns of data, only to "
"use a small subset of them afterwards? You may suggest `merge(X[ , "
"ColsNeeded1], Y[ , ColsNeeded2])`, but that requires the programmer to work "
"out which columns are needed. `X[Y, j]` in data.table does all that in one "
"step for you. When you write `X[Y, sum(foo*bar)]`, data.table automatically "
"inspects the `j` expression to see which columns it uses. It will subset "
"those columns only; the others are ignored. Memory is only created for the "
"columns `j` uses and `Y` columns enjoy standard R recycling rules within the "
"context of each group. Let's say `foo` is in `X` and `bar` is in `Y` (along "
"with 20 other columns in `Y`). Isn't `X[Y, sum(foo*bar)]` quicker to program "
"and quicker to run than a `merge` of everything wastefully followed by a "
"`subset`?"
msgstr ""
"*MAIS* cela ne tient pas compte de l'essentiel. La plupart des tâches exigent "
"que l'on fasse quelque chose sur les données après une jointure ou une "
"fusion. Pourquoi fusionner toutes les colonnes de données pour n'en utiliser "
"qu'un petit sous-ensemble par la suite ? Vous pouvez suggérer `merge(X[ , "
"ColsNeeded1], Y[ , ColsNeed2])`, mais cela demande au programmeur de "
"déterminer quelles colonnes sont nécessaires. `X[Y, j]` dans data.table fait "
"tout cela en une seule étape pour vous. Quand vous écrivez `X[Y, "
"sum(foo*bar)]`, data.table inspecte automatiquement l'expression `j` pour "
"voir quelles colonnes elle utilise. Il ne sous-ensemble que ces colonnes ; "
"les autres sont ignorées. La mémoire n'est créée que pour les colonnes que "
"`j` utilise et les colonnes `Y` bénéficient des règles de recyclage standard "
"de R dans le contexte de chaque groupe. Disons que `foo` est dans `X` et "
"`bar` est dans `Y` (avec 20 autres colonnes dans `Y`). Est-ce que `X[Y, "
"sum(foo*bar)]` n'est pas plus rapide à programmer et à exécuter qu'une "
"`fusion` de tout ce qui est suivi par un `subset` ?"

#: fr/datatable-faq.Rmd.tmp:block 51 (paragraph)
#, fuzzy
msgid ""
"[^1]: Here we mean either the `merge` *method* for data.table or the `merge` "
"method for `data.frame` since both methods work in the same way in this "
"respect. See `?merge.data.table` and [below](#r-dispatch) for more "
"information about method dispatch."
msgstr ""
"[^1]: Il s'agit ici de la méthode `merge` *method* pour data.table ou de la "
"méthode `merge` pour `data.frame` puisque les deux méthodes fonctionnent de "
"la même manière à cet égard. Voir `?merge.data.table` et [below](#r-dispatch) "
"pour plus d'informations sur la répartition des méthodes."

#: fr/datatable-faq.Rmd.tmp:block 52 (header)
#, fuzzy
msgid "Anything else about `X[Y, sum(foo*bar)]`?"
msgstr "Autre chose à propos de `X[Y, sum(foo*bar)]` ?"

#: fr/datatable-faq.Rmd.tmp:block 53 (paragraph)
#, fuzzy
msgid ""
"This behaviour changed in v1.9.4 (Sep 2014). It now does the `X[Y]` join and "
"then runs `sum(foo*bar)` over all the rows; i.e., `X[Y][ , sum(foo*bar)]`. It "
"used to run `j` for each *group* of `X` that each row of `Y` matches to. That "
"can still be done as it's very useful but you now need to be explicit and "
"specify `by = .EACHI`, *i.e.*, `X[Y, sum(foo*bar), by = .EACHI]`. We call "
"this *grouping by each `i`*."
msgstr ""
"Ce comportement a changé dans la version 1.9.4 (septembre 2014). Il fait "
"maintenant la jointure `X[Y]` et exécute ensuite `sum(foo*bar)` sur toutes "
"les lignes ; c'est à dire, `X[Y][ , sum(foo*bar)]`. Il avait l'habitude "
"d'exécuter `j` pour chaque *groupe* de `X` auquel correspondait chaque ligne "
"de `Y`. Cela peut toujours être fait et c'est très utile, mais vous devez "
"maintenant être explicite et spécifier `by = .EACHI`, *c'est-à-dire `X[Y, "
"sum(foo*bar), by = .EACHI]`. C'est ce que nous appelons le *regroupement par "
"chaque `i`*."

#: fr/datatable-faq.Rmd.tmp:block 54 (paragraph)
#, fuzzy
msgid ""
"For example, (further complicating it by using *join inherited scope*, too):"
msgstr ""
"Par exemple, (en le compliquant encore en utilisant *join inherited scope*, "
"aussi) :"

#: fr/datatable-faq.Rmd.tmp:block 55 (code)
#, fuzzy
msgid ""
"X = data.table(grp = c(\"a\", \"a\", \"b\",\n"
"                       \"b\", \"b\", \"c\", \"c\"), foo = 1:7)\n"
"setkey(X, grp)\n"
"Y = data.table(c(\"b\", \"c\"), bar = c(4, 2))\n"
"X\n"
"Y\n"
"X[Y, sum(foo*bar)]\n"
"X[Y, sum(foo*bar), by = .EACHI]\n"
msgstr ""
"X = data.table(grp = c(\"a\", \"a\", \"b\",\n"
"                       \"b\", \"b\", \"c\", \"c\"), foo = 1:7)\n"
"setkey(X, grp)\n"
"Y = data.table(c(\"b\", \"c\"), bar = c(4, 2))\n"
"X\n"
"Y\n"
"X[Y, sum(foo*bar)]\n"
"X[Y, sum(foo*bar), by = .EACHI]\n"

#: fr/datatable-faq.Rmd.tmp:block 56 (header)
#, fuzzy
msgid ""
"That's nice. How did you manage to change it given that users depended on the "
"old behaviour?"
msgstr ""
"C'est très bien. Comment avez-vous réussi à le modifier étant donné que les "
"utilisateurs dépendaient de l'ancien comportement ?"

#: fr/datatable-faq.Rmd.tmp:block 57 (paragraph)
#, fuzzy
msgid ""
"The request to change came from users. The feeling was that if a query is "
"doing grouping then an explicit `by=` should be present for code readability "
"reasons. An option was provided to return the old behaviour: "
"`options(datatable.old.bywithoutby)`, by default `FALSE`. This enabled "
"upgrading to test the other new features / bug fixes in v1.9.4, with later "
"migration of any by-without-by queries when ready by adding `by=.EACHI` to "
"them. We retained 47 pre-change tests and added them back as new tests, "
"tested under `options(datatable.old.bywithoutby=TRUE)`. We added a startup "
"message about the change and how to revert to the old behaviour. After 1 year "
"the option was deprecated with warning when used. After 2 years the option to "
"revert to old behaviour was removed."
msgstr ""
"La demande de changement est venue des utilisateurs. Le sentiment était que "
"si une requête fait du groupage, alors un `by=` explicite devrait être "
"présent pour des raisons de lisibilité du code. Une option a été fournie pour "
"retourner l'ancien comportement : `options(datatable.old.bywithoutby)`, par "
"défaut `FALSE`. Cela a permis de tester les autres nouvelles fonctionnalités "
"et corrections de bogues de la version 1.9.4, avec une migration ultérieure "
"des requêtes by-without-by lorsqu'elles sont prêtes en ajoutant `by=.EACHI` à "
"ces requêtes. Nous avons conservé 47 tests antérieurs au changement et les "
"avons ajoutés en tant que nouveaux tests, testés sous `options(datatable.old."
"bywithoutby=TRUE)`. Nous avons ajouté un message de démarrage à propos du "
"changement et de la façon de revenir à l'ancien comportement. Après 1 an, "
"l'option a été dépréciée avec un avertissement en cas d'utilisation. Après 2 "
"ans, l'option permettant de revenir à l'ancien comportement a été supprimée."

#: fr/datatable-faq.Rmd.tmp:block 58 (paragraph)
#, fuzzy
msgid ""
"Of the 66 packages on CRAN or Bioconductor that depended on or import data."
"table at the time of releasing v1.9.4 (it is now over 300), only one was "
"affected by the change. That could be because many packages don't have "
"comprehensive tests, or just that grouping by each row in `i` wasn't being "
"used much by downstream packages. We always test the new version with all "
"dependent packages before release and coordinate any changes with those "
"maintainers. So this release was quite straightforward in that regard."
msgstr ""
"Sur les 66 paquets sur CRAN ou Bioconductor qui dépendaient ou importaient "
"data.table au moment de la publication de la v1.9.4 (il y en a maintenant "
"plus de 300), un seul a été affecté par le changement. Cela peut être dû au "
"fait que de nombreux paquets n'ont pas de tests complets, ou simplement au "
"fait que le regroupement par chaque ligne dans `i` n'était pas beaucoup "
"utilisé par les paquets en aval. Nous testons toujours la nouvelle version "
"avec tous les paquets dépendants avant de la publier et nous coordonnons les "
"changements avec les responsables de ces paquets. Cette version a donc été "
"assez simple à cet égard."

#: fr/datatable-faq.Rmd.tmp:block 59 (paragraph)
#, fuzzy
msgid ""
"Another compelling reason to make the change was that previously, there was "
"no efficient way to achieve what `X[Y, sum(foo*bar)]` does now. You had to "
"write `X[Y][ , sum(foo*bar)]`. That was suboptimal because `X[Y]` joined all "
"the columns and passed them all to the second compound query without knowing "
"that only `foo` and `bar` are needed. To solve that efficiency problem, extra "
"programming effort was required: `X[Y, list(foo, bar)][ , sum(foo*bar)]`. The "
"change to `by = .EACHI` has simplified this by allowing both queries to be "
"expressed inside a single `DT[...]` query for efficiency."
msgstr ""
"Une autre raison convaincante de faire ce changement est qu'auparavant, il "
"n'y avait pas de moyen efficace de réaliser ce que `X[Y, sum(foo*bar)]` fait "
"maintenant. Il fallait écrire `X[Y][ , sum(foo*bar)]`. C'était sous-optimal "
"parce que `X[Y]` joignait toutes les colonnes et les passait toutes à la "
"seconde requête composée sans savoir que seuls `foo` et `bar` étaient "
"nécessaires. Pour résoudre ce problème d'efficacité, un effort de "
"programmation supplémentaire a été nécessaire : `X[Y, list(foo, bar)][ , "
"sum(foo*bar)]`. Le passage à `by = .EACHI` a simplifié cela en permettant aux "
"deux requêtes d'être exprimées dans une seule requête `DT[...]` pour plus "
"d'efficacité."

#: fr/datatable-faq.Rmd.tmp:block 60 (header)
#, fuzzy
msgid "General Syntax"
msgstr "Syntaxe générale"

#: fr/datatable-faq.Rmd.tmp:block 61 (header)
#, fuzzy
msgid ""
"How can I avoid writing a really long `j` expression? You've said that I "
"should use the column *names*, but I've got a lot of columns."
msgstr ""
"Comment éviter d'écrire une expression `j` très longue ? Vous avez dit que je "
"devrais utiliser les *noms* de colonnes, mais j'ai beaucoup de colonnes."

#: fr/datatable-faq.Rmd.tmp:block 62 (paragraph)
#, fuzzy
msgid ""
"When grouping, the `j` expression can use column names as variables, as you "
"know, but it can also use a reserved symbol `.SD` which refers to the "
"**S**ubset of the **D**ata.table for each group (excluding the grouping "
"columns). So to sum up all your columns it's just `DT[ , lapply(.SD, sum), by "
"= grp]`. It might seem tricky, but it's fast to write and fast to run. Notice "
"you don't have to create an anonymous function. The `.SD` object is "
"efficiently implemented internally and more efficient than passing an "
"argument to a function. But if the `.SD` symbol appears in `j` then data."
"table has to populate `.SD` fully for each group even if `j` doesn't use all "
"of it."
msgstr ""
"Lors du regroupement, l'expression `j` peut utiliser les noms de colonnes "
"comme variables, comme vous le savez, mais elle peut aussi utiliser un "
"symbole réservé `.SD` qui fait référence au **S**ubset de la **D**ata.table "
"pour chaque groupe (à l'exclusion des colonnes de regroupement). Donc pour "
"résumer toutes vos colonnes, c'est juste `DT[ , lapply(.SD, sum), by = grp]`. "
"Cela peut sembler compliqué, mais c'est rapide à écrire et à exécuter. Notez "
"que vous n'avez pas besoin de créer une fonction anonyme. L'objet `.SD` est "
"efficacement implémenté en interne et plus efficace que de passer un argument "
"à une fonction. Mais si le symbole `.SD` apparaît dans `j` alors data.table "
"doit remplir `.SD` complètement pour chaque groupe même si `j` ne l'utilise "
"pas entièrement."

#: fr/datatable-faq.Rmd.tmp:block 63 (paragraph)
#, fuzzy
msgid ""
"So please don't do, for example, `DT[ , sum(.SD[[\"sales\"]]), by = grp]`. "
"That works but is inefficient and inelegant. `DT[ , sum(sales), by = grp]` is "
"what was intended, and it could be 100s of times faster. If you use *all* of "
"the data in `.SD` for each group (such as in `DT[ , lapply(.SD, sum), by = "
"grp]`) then that's very good usage of `.SD`. If you're using *several* but "
"not *all* of the columns, you can combine `.SD` with `.SDcols`; see `?data."
"table`."
msgstr ""
"Ne faites donc pas, par exemple, `DT[ , sum(.SD[[\"sales\"]]), by = grp]`. "
"Cela fonctionne, mais c'est inefficace et inélégant. `DT[ , sum(sales), by = "
"grp]` est ce qui était prévu, et il pourrait être des centaines de fois plus "
"rapide. Si vous utilisez *toutes* les données de `.SD` pour chaque groupe "
"(comme dans `DT[ , lapply(.SD, sum), by = grp]`) alors c'est une très bonne "
"utilisation de `.SD`. Si vous utilisez *plusieurs* mais pas *toutes* les "
"colonnes, vous pouvez combiner `.SD` avec `.SDcols` ; voir `?data.table`."

#: fr/datatable-faq.Rmd.tmp:block 64 (header)
#, fuzzy
msgid "Why is the default for `mult` now `\"all\"`?"
msgstr "Pourquoi la valeur par défaut de `mult` est-elle maintenant `\"all\"` ?"

#: fr/datatable-faq.Rmd.tmp:block 65 (paragraph)
#, fuzzy
msgid ""
"In v1.5.3 the default was changed to `\"all\"`. When `i` (or `i`'s key if it "
"has one) has fewer columns than `x`'s key, `mult` was already set to "
"`\"all\"` automatically. Changing the default makes this clearer and easier "
"for users as it came up quite often."
msgstr ""
"Dans la version 1.5.3, la valeur par défaut a été changée en \"all\". Quand "
"`i` (ou la clé de `i` si elle en a une) a moins de colonnes que la clé de "
"`x`, `mult` était déjà mis à `\"all\"` automatiquement. Changer la valeur par "
"défaut rend la chose plus claire et plus facile pour les utilisateurs, car la "
"question se posait assez souvent."

#: fr/datatable-faq.Rmd.tmp:block 66 (paragraph)
#, fuzzy
msgid ""
"In versions up to v1.3, `\"all\"` was slower. Internally, `\"all\"` was "
"implemented by joining using `\"first\"`, then again from scratch using "
"`\"last\"`, after which a diff between them was performed to work out the "
"span of the matches in `x` for each row in `i`. Most often we join to single "
"rows, though, where `\"first\"`,`\"last\"` and `\"all\"` return the same "
"result. We preferred maximum performance for the majority of situations so "
"the default chosen was `\"first\"`. When working with a non-unique key "
"(generally a single column containing a grouping variable), `DT[\"A\"]` "
"returned the first row of that group so `DT[\"A\", mult = \"all\"]` was "
"needed to return all the rows in that group."
msgstr ""
"Dans les versions antérieures à la v1.3, `\"all\"` était plus lent. En "
"interne, `\"all\"` était implémenté en joignant en utilisant `\"first\"`, "
"puis à nouveau à partir de zéro en utilisant `\"last\"`, après quoi un diff "
"entre eux était effectué pour calculer l'étendue des correspondances dans `x` "
"pour chaque ligne dans `i`. La plupart du temps, nous effectuons des "
"jointures sur des lignes individuelles, où `\"first\"`,`\"last\"` et "
"`\"all\"` renvoient le même résultat. Nous avons préféré une performance "
"maximale dans la majorité des cas, c'est pourquoi nous avons choisi par "
"défaut `\"first\"`. Lorsque l'on travaille avec une clé non unique "
"(généralement une colonne unique contenant une variable de regroupement), "
"`DT[\"A\"]` renvoie la première ligne de ce groupe, donc `DT[\"A\", mult = "
"\"all\"]` est nécessaire pour renvoyer toutes les lignes de ce groupe."

#: fr/datatable-faq.Rmd.tmp:block 67 (paragraph)
#, fuzzy
msgid ""
"In v1.4 the binary search in C was changed to branch at the deepest level to "
"find first and last. That branch will likely occur within the same final "
"pages of RAM so there should no longer be a speed disadvantage in defaulting "
"`mult` to `\"all\"`. We warned that the default might change and made the "
"change in v1.5.3."
msgstr ""
"Dans la version 1.4, la recherche binaire en C a été modifiée pour se "
"brancher au niveau le plus profond afin de trouver le premier et le dernier. "
"Ce branchement se produira probablement dans les mêmes pages finales de RAM, "
"donc il ne devrait plus y avoir de désavantage en termes de vitesse en "
"mettant par défaut `mult` à `\"all\"`. Nous avons prévenu que la valeur par "
"défaut pourrait changer et nous avons fait le changement dans la version "
"1.5.3."

#: fr/datatable-faq.Rmd.tmp:block 68 (paragraph)
#, fuzzy
msgid ""
"A future version of data.table may allow a distinction between a key and a "
"*unique key*. Internally `mult = \"all\"` would perform more like `mult = "
"\"first\"` when all `x`'s key columns were joined to and `x`'s key was a "
"unique key. data.table would need checks on insert and update to make sure a "
"unique key is maintained. An advantage of specifying a unique key would be "
"that data.table would ensure no duplicates could be inserted, in addition to "
"performance."
msgstr ""
"Une future version de data.table pourrait permettre une distinction entre une "
"clé et une *clé unique*. En interne, `mult = \"all\"` fonctionnerait plus "
"comme `mult = \"first\"` lorsque toutes les colonnes clés de `x` sont jointes "
"et que la clé de `x` est une clé unique. data.table aurait besoin de "
"vérifications lors de l'insertion et de la mise à jour pour s'assurer qu'une "
"clé unique est maintenue. L'avantage de spécifier une clé unique serait que "
"data.table s'assurerait qu'aucun duplicata ne puisse être inséré, en plus de "
"la performance."

#: fr/datatable-faq.Rmd.tmp:block 69 (header)
#, fuzzy
msgid "I'm using `c()` in `j` and getting strange results."
msgstr "J'utilise `c()` dans `j` et j'obtiens des résultats étranges."

#: fr/datatable-faq.Rmd.tmp:block 70 (paragraph)
#, fuzzy
msgid ""
"This is a common source of confusion. In `data.frame` you are used to, for "
"example:"
msgstr ""
"Il s'agit d'une source de confusion fréquente. Dans `data.frame`, vous avez "
"l'habitude de, par exemple :"

#: fr/datatable-faq.Rmd.tmp:block 71 (code)
#, fuzzy
msgid ""
"DF = data.frame(x = 1:3, y = 4:6, z = 7:9)\n"
"DF\n"
"DF[ , c(\"y\", \"z\")]\n"
msgstr ""
"DF = data.frame(x = 1:3, y = 4:6, z = 7:9)\n"
"DF\n"
"DF[ , c(\"y\", \"z\")]\n"

#: fr/datatable-faq.Rmd.tmp:block 72 (paragraph)
#, fuzzy
msgid ""
"which returns the two columns. In data.table you know you can use the column "
"names directly and might try:"
msgstr ""
"qui renvoie les deux colonnes. Dans data.table, vous savez que vous pouvez "
"utiliser les noms de colonnes directement et vous pouvez essayer :"

#: fr/datatable-faq.Rmd.tmp:block 73 (code)
#, fuzzy
msgid ""
"DT = data.table(DF)\n"
"DT[ , c(y, z)]\n"
msgstr ""
"DT = data.table(DF)\n"
"DT[ , c(y, z)]\n"

#: fr/datatable-faq.Rmd.tmp:block 74 (paragraph)
#, fuzzy
msgid ""
"but this returns one vector. Remember that the `j` expression is evaluated "
"within the environment of `DT` and `c()` returns a vector. If 2 or more "
"columns are required, use `list()` or `.()` instead:"
msgstr ""
"mais elle renvoie un vecteur. Rappelez-vous que l'expression `j` est évaluée "
"dans l'environnement de `DT` et que `c()` renvoie un vecteur. Si 2 colonnes "
"ou plus sont nécessaires, utilisez `list()` ou `.()` à la place :"

#: fr/datatable-faq.Rmd.tmp:block 75 (code)
#, fuzzy
msgid "DT[ , .(y, z)]\n"
msgstr "DT[ , .(y, z)]\n"

#: fr/datatable-faq.Rmd.tmp:block 76 (paragraph)
#, fuzzy
msgid ""
"`c()` can be useful in a data.table too, but its behaviour is different from "
"that in `[.data.frame`."
msgstr ""
"`c()` peut également être utile dans un data.table, mais son comportement est "
"différent de celui de `[.data.frame`."

#: fr/datatable-faq.Rmd.tmp:block 77 (header)
#, fuzzy
msgid ""
"I have built up a complex table with many columns. I want to use it as a "
"template for a new table; *i.e.*, create a new table with no rows, but with "
"the column names and types copied from my table. Can I do that easily?"
msgstr ""
"J'ai créé un tableau complexe comportant de nombreuses colonnes. Je souhaite "
"l'utiliser comme modèle pour un nouveau tableau ; *c'est-à-dire créer un "
"nouveau tableau sans lignes, mais avec les noms et les types de colonnes "
"copiés à partir de mon tableau. Est-ce que je peux le faire facilement ?"

#: fr/datatable-faq.Rmd.tmp:block 78 (paragraph)
#, fuzzy
msgid "Yes. If your complex table is called `DT`, try `NEWDT = DT[0]`."
msgstr "Si votre table complexe s'appelle `DT`, essayez `NEWDT = DT[0]`."

#: fr/datatable-faq.Rmd.tmp:block 79 (header)
#, fuzzy
msgid "Is a null data.table the same as `DT[0]`?"
msgstr "Un data.table nul est-il identique à `DT[0]` ?"

#: fr/datatable-faq.Rmd.tmp:block 80 (paragraph)
#, fuzzy
msgid ""
"No. By \"null data.table\" we mean the result of `data.table(NULL)` or `as."
"data.table(NULL)`; *i.e.*,"
msgstr ""
"Non. Par \"table de données nulle\", nous entendons le résultat de `data."
"table(NULL)` ou de `as.data.table(NULL)` ; *c'est-à-dire *,"

#: fr/datatable-faq.Rmd.tmp:block 81 (code)
#, fuzzy
msgid ""
"data.table(NULL)\n"
"data.frame(NULL)\n"
"as.data.table(NULL)\n"
"as.data.frame(NULL)\n"
"is.null(data.table(NULL))\n"
"is.null(data.frame(NULL))\n"
msgstr ""
"data.table(NULL)\n"
"data.frame(NULL)\n"
"as.data.table(NULL)\n"
"as.data.frame(NULL)\n"
"is.null(data.table(NULL))\n"
"is.null(data.frame(NULL))\n"

#: fr/datatable-faq.Rmd.tmp:block 82 (paragraph)
#, fuzzy
msgid ""
"The null data.table|`frame` is `NULL` with some attributes attached, which "
"means it's no longer `NULL`. In R only pure `NULL` is `NULL` as tested by `is."
"null()`. When referring to the \"null data.table\" we use lower case null to "
"help distinguish from upper case `NULL`. To test for the null data.table, use "
"`length(DT) == 0` or `ncol(DT) == 0` (`length` is slightly faster as it's a "
"primitive function)."
msgstr ""
"Le data.table|`frame` null est `NULL` avec quelques attributs attachés, ce "
"qui signifie qu'il n'est plus `NULL`. Dans R, seul le `NULL` pur est `NULL`, "
"comme testé par `is.null()`. Lorsque l'on se réfère à \"data.table null\", on "
"utilise la minuscule null pour faire la différence avec la majuscule `NULL`. "
"Pour tester la nullité d'un data.table, utilisez `length(DT) == 0` ou "
"`ncol(DT) == 0` (`length` est légèrement plus rapide car il s'agit d'une "
"fonction primitive)."

#: fr/datatable-faq.Rmd.tmp:block 83 (paragraph)
#, fuzzy
msgid ""
"An *empty* data.table (`DT[0]`) has one or more columns, all of which are "
"empty. Those empty columns still have names and types."
msgstr ""
"Un data.table *vide* (`DT[0]`) possède une ou plusieurs colonnes, toutes "
"vides. Ces colonnes vides ont toujours des noms et des types."

#: fr/datatable-faq.Rmd.tmp:block 84 (code)
#, fuzzy
msgid ""
"DT = data.table(a = 1:3, b = c(4, 5, 6), d = c(7L,8L,9L))\n"
"DT[0]\n"
"sapply(DT[0], class)\n"
msgstr ""
"DT = data.table(a = 1:3, b = c(4, 5, 6), d = c(7L,8L,9L))\n"
"DT[0]\n"
"sapply(DT[0], class)\n"

#: fr/datatable-faq.Rmd.tmp:block 85 (header)
#, fuzzy
msgid "Why has the `DT()` alias been removed? {#DTremove1}"
msgstr "Pourquoi l'alias `DT()` a-t-il été supprimé ? {#DTremove1}"

#: fr/datatable-faq.Rmd.tmp:block 86 (paragraph)
#, fuzzy
msgid ""
"`DT` was introduced originally as a wrapper for a list of `j `expressions. "
"Since `DT` was an alias for data.table, this was a convenient way to take "
"care of silent recycling in cases where each item of the `j` list evaluated "
"to different lengths. The alias was one reason grouping was slow, though."
msgstr ""
"`DT` a été introduit à l'origine comme une enveloppe pour une liste "
"d'expressions `j`. Comme `DT` était un alias de data.table, c'était un moyen "
"pratique de prendre en charge le recyclage silencieux dans les cas où chaque "
"élément de la liste `j` était évalué à des longueurs différentes. L'alias "
"était l'une des raisons pour lesquelles le groupage était lent."

#: fr/datatable-faq.Rmd.tmp:block 87 (paragraph)
#, fuzzy
msgid ""
"As of v1.3, `list()` or `.()` should be passed instead to the `j` argument. "
"These are much faster, especially when there are many groups. Internally, "
"this was a non-trivial change. Vector recycling is now done internally, along "
"with several other speed enhancements for grouping."
msgstr ""
"Depuis la version 1.3, `list()` ou `.()` devraient être passés à la place de "
"l'argument `j`. Ces méthodes sont beaucoup plus rapides, en particulier "
"lorsqu'il y a beaucoup de groupes. En interne, il s'agit d'un changement non "
"trivial. Le recyclage des vecteurs est maintenant effectué en interne, ainsi "
"que plusieurs autres améliorations de la vitesse de groupage."

#: fr/datatable-faq.Rmd.tmp:block 88 (header)
#, fuzzy
msgid ""
"But my code uses `j = DT(...)` and it works. The previous FAQ says that "
"`DT()` has been removed. {#DTremove2}"
msgstr ""
"Mais mon code utilise `j = DT(...)` et il fonctionne. La FAQ précédente dit "
"que `DT()` a été supprimé. {#DTremove2}"

#: fr/datatable-faq.Rmd.tmp:block 89 (paragraph)
#, fuzzy
msgid ""
"Then you are using a version prior to 1.5.3. Prior to 1.5.3 `[.data.table` "
"detected use of `DT()` in the `j` and automatically replaced it with a call "
"to `list()`. This was to help the transition for existing users."
msgstr ""
"Vous utilisez alors une version antérieure à la 1.5.3. Avant la version "
"1.5.3, `[.data.table` détectait l'utilisation de `DT()` dans le `j` et le "
"remplaçait automatiquement par un appel à `list()`. Ceci avait pour but de "
"faciliter la transition pour les utilisateurs existants."

#: fr/datatable-faq.Rmd.tmp:block 90 (header)
#, fuzzy
msgid "What are the scoping rules for `j` expressions?"
msgstr "Quelles sont les règles de portée des expressions `j` ?"

#: fr/datatable-faq.Rmd.tmp:block 91 (paragraph)
#, fuzzy
msgid ""
"Think of the subset as an environment where all the column names are "
"variables. When a variable `foo` is used in the `j` of a query such as `X[Y, "
"sum(foo)]`, `foo` is looked for in the following order:"
msgstr ""
"Considérez le sous-ensemble comme un environnement où tous les noms de "
"colonnes sont des variables. Lorsqu'une variable `foo` est utilisée dans le "
"`j` d'une requête telle que `X[Y, sum(foo)]`, `foo` est recherché dans "
"l'ordre suivant :"

#: fr/datatable-faq.Rmd.tmp:block 92 (paragraph)
#, fuzzy
msgid ""
"===== 1. The scope of `X`'s subset; *i.e.*, `X`'s column names.===== ===== 2. "
"The scope of each row of `Y`; *i.e.*, `Y`'s column names (*join inherited "
"scope*)===== ===== 3. The scope of the calling frame; *e.g.*, the line that "
"appears before the data.table query.===== ===== 4. Exercise for reader: does "
"it then ripple up the calling frames, or go straight to `globalenv()`?===== "
"===== 5. The global environment====="
msgstr ""
"===== 1. La portée du sous-ensemble `X` ; *c'est-à-dire *, les noms de "
"colonnes de `X`.===== ===== 2. La portée de chaque ligne de `Y` ; *i.e.*, les "
"noms des colonnes de `Y` (*joint inherited scope*)===== ===== 3. La portée du "
"cadre d'appel ; *e.g.*, la ligne qui apparaît avant la requête data.table."
"===== ===== 4. Exercice pour le lecteur : est-ce que cela se répercute "
"ensuite sur les cadres d'appel ou est-ce que cela va directement à "
"`globalenv()` ? ===== ===== 5. L'environnement global====="

#: fr/datatable-faq.Rmd.tmp:block 93 (paragraph)
#, fuzzy
msgid ""
"This is *lexical scoping* as explained in [R FAQ 3.3.1](https://cran.r-"
"project.org/doc/FAQ/R-FAQ.html#Lexical-scoping). The environment in which the "
"function was created is not relevant, though, because there is *no function*. "
"No anonymous *function* is passed to `j`. Instead, an anonymous *body* is "
"passed to `j`; for example,"
msgstr ""
"Il s'agit d'un *cadrage logique* comme expliqué dans [R FAQ 3.3.1](https://"
"cran.r-project.org/doc/FAQ/R-FAQ.html#Lexical-scoping). L'environnement dans "
"lequel la fonction a été créée n'est pas pertinent, cependant, parce qu'il "
"n'y a *pas de fonction*. Aucune *fonction* anonyme n'est passée à `j`. Au "
"lieu de cela, un *corps* anonyme est passé à `j` ; par exemple,"

#: fr/datatable-faq.Rmd.tmp:block 94 (code)
#, fuzzy
msgid ""
"DT = data.table(x = rep(c(\"a\", \"b\"), c(2, 3)), y = 1:5)\n"
"DT\n"
"DT[ , {z = sum(y); z + 3}, by = x]\n"
msgstr ""
"DT = data.table(x = rep(c(\"a\", \"b\"), c(2, 3)), y = 1:5)\n"
"DT\n"
"DT[ , {z = sum(y) ; z + 3}, by = x]\n"

#: fr/datatable-faq.Rmd.tmp:block 95 (paragraph)
#, fuzzy
msgid "Some programming languages call this a *lambda*."
msgstr "Certains langages de programmation appellent cela un *lambda*."

#: fr/datatable-faq.Rmd.tmp:block 96 (header)
#, fuzzy
msgid "Can I trace the `j` expression as it runs through the groups? {#j-trace}"
msgstr ""
"Puis-je tracer l'expression `j` au fur et à mesure qu'elle passe dans les "
"groupes ? {#j-trace}"

#: fr/datatable-faq.Rmd.tmp:block 97 (paragraph)
#, fuzzy
msgid "Try something like this:"
msgstr "Essayez quelque chose comme ceci :"

#: fr/datatable-faq.Rmd.tmp:block 98 (code)
msgid ""
"DT[ , {\n"
"  cat(\"Objects:\", paste(objects(), collapse = \",\"), \"\\n\")\n"
"  cat(\"Trace: x=\", as.character(x), \" y=\", y, \"\\n\")\n"
"  sum(y)},\n"
"  by = x]\n"
msgstr ""
"DT[ , {\n"
"  cat(\"Objets :\", paste(objects(), collapse = \",\"), \"\\n\")\n"
"  cat(\"Trace : x=\", as.character(x), \" y=\", y, \"\\n\")\n"
"  sum(y)},\n"
"  by = x]\n"

#: fr/datatable-faq.Rmd.tmp:block 99 (header)
#, fuzzy
msgid "Inside each group, why are the group variables length-1?"
msgstr ""
"À l'intérieur de chaque groupe, pourquoi les variables de groupe sont-elles "
"de longueur 1 ?"

#: fr/datatable-faq.Rmd.tmp:block 100 (paragraph)
#, fuzzy
msgid ""
"[Above](#j-trace), `x` is a grouping variable and (as from v1.6.1) has "
"`length` 1 (if inspected or used in `j`). It's for efficiency and "
"convenience. Therefore, there is no difference between the following two "
"statements:"
msgstr ""
"[Above](#j-trace), `x` est une variable de regroupement et (à partir de la "
"version 1.6.1) a une longueur de 1 (si elle est inspectée ou utilisée dans "
"`j`). C'est pour des raisons d'efficacité et de commodité. Par conséquent, il "
"n'y a pas de différence entre les deux déclarations suivantes :"

#: fr/datatable-faq.Rmd.tmp:block 101 (code)
#, fuzzy
msgid ""
"DT[ , .(g = 1, h = 2, i = 3, j = 4, repeatgroupname = x, sum(y)), by = x]\n"
"DT[ , .(g = 1, h = 2, i = 3, j = 4, repeatgroupname = x[1], sum(y)), by = x]\n"
msgstr ""
"DT[ , .(g = 1, h = 2, i = 3, j = 4, repeatgroupname = x, sum(y)), by = x]\n"
"DT[ , .(g = 1, h = 2, i = 3, j = 4, repeatgroupname = x[1], sum(y)), by = x]\n"

#: fr/datatable-faq.Rmd.tmp:block 102 (paragraph)
#, fuzzy
msgid ""
"If you need the size of the current group, use `.N` rather than calling "
"`length()` on any column."
msgstr ""
"Si vous avez besoin de la taille du groupe actuel, utilisez `.N` plutôt que "
"d'appeler `length()` sur n'importe quelle colonne."

#: fr/datatable-faq.Rmd.tmp:block 103 (header)
#, fuzzy
msgid "Only the first 10 rows are printed, how do I print more?"
msgstr ""
"Seules les 10 premières lignes sont imprimées, comment en imprimer d'autres ?"

#: fr/datatable-faq.Rmd.tmp:block 104 (paragraph)
#, fuzzy
msgid ""
"There are two things happening here. First, if the number of rows in a data."
"table are large (`> 100` by default), then a summary of the data.table is "
"printed to the console by default. Second, the summary of a large data.table "
"is printed by taking the top and bottom `n` (`= 5` by default) rows of the "
"data.table and only printing those. Both of these parameters (when to trigger "
"a summary and how much of a table to use as a summary) are configurable by "
"R's `options` mechanism, or by calling the `print` function directly."
msgstr ""
"Il se passe deux choses ici. Premièrement, si le nombre de lignes d'un data."
"table est important (`> 100` par défaut), alors un résumé du data.table est "
"imprimé sur la console par défaut. Deuxièmement, le résumé d'un grand data."
"table est imprimé en prenant les `n` (`= 5` par défaut) lignes du haut et du "
"bas du data.table et en n'imprimant que celles-ci. Ces deux paramètres (quand "
"déclencher un résumé et quelle partie du tableau utiliser comme résumé) sont "
"configurables par le mécanisme `options` de R, ou en appelant directement la "
"fonction `print`."

#: fr/datatable-faq.Rmd.tmp:block 105 (paragraph)
#, fuzzy
msgid ""
"For instance, to enforce the summary of a data.table to only happen when a "
"data.table is greater than 50 rows, you could `options(datatable.print.nrows "
"= 50)`. To disable the summary-by-default completely, you could "
"`options(datatable.print.nrows = Inf)`. You could also call `print` directly, "
"as in `print(your.data.table, nrows = Inf)`."
msgstr ""
"Par exemple, pour forcer le résumé d'un data.table à ne se produire que "
"lorsqu'un data.table est supérieur à 50 lignes, vous pourriez "
"`options(datatable.print.nrows = 50)`. Pour désactiver complètement le résumé "
"par défaut, vous pourriez `options(datatable.print.nrows = Inf)`. Vous pouvez "
"aussi appeler `print` directement, comme dans `print(your.data.table, nrows = "
"Inf)`."

#: fr/datatable-faq.Rmd.tmp:block 106 (paragraph)
#, fuzzy
msgid ""
"If you want to show more than just the top (and bottom) 10 rows of a data."
"table summary (say you like 20), set `options(datatable.print.topn = 20)`, "
"for example. Again, you could also just call `print` directly, as in "
"`print(your.data.table, topn = 20)`."
msgstr ""
"Si vous voulez afficher plus que les 10 premières (et dernières) lignes d'un "
"tableau de données (disons 20), mettez `options(datatable.print.topn = 20)`, "
"par exemple. Encore une fois, vous pouvez aussi appeler directement `print`, "
"comme dans `print(your.data.table, topn = 20)`."

#: fr/datatable-faq.Rmd.tmp:block 107 (header)
#, fuzzy
msgid "With an `X[Y]` join, what if `X` contains a column called `\"Y\"`?"
msgstr ""
"Avec une jointure `X[Y]`, que se passe-t-il si `X` contient une colonne "
"appelée `\"Y\"` ?"

#: fr/datatable-faq.Rmd.tmp:block 108 (paragraph)
#, fuzzy
msgid ""
"When `i` is a single name such as `Y` it is evaluated in the calling frame. "
"In all other cases such as calls to `.()` or other expressions, `i` is "
"evaluated within the scope of `X`. This facilitates easy *self-joins* such as "
"`X[J(unique(colA)), mult = \"first\"]`."
msgstr ""
"Lorsque `i` est un nom unique tel que `Y`, il est évalué dans le cadre "
"d'appel. Dans tous les autres cas, comme les appels à `.()` ou d'autres "
"expressions, `i` est évalué dans la portée de `X`. Cela facilite les *auto-"
"joints* comme `X[J(unique(colA)), mult = \"first\"]`."

#: fr/datatable-faq.Rmd.tmp:block 109 (header)
#, fuzzy
msgid ""
"`X[Z[Y]]` is failing because `X` contains a column `\"Y\"`. I'd like it to "
"use the table `Y` in calling scope."
msgstr ""
"`X[Z[Y]]` échoue parce que `X` contient une colonne `\"Y\"`. J'aimerais qu'il "
"utilise la table `Y` dans la portée de l'appel."

#: fr/datatable-faq.Rmd.tmp:block 110 (paragraph)
#, fuzzy
msgid ""
"The `Z[Y]` part is not a single name so that is evaluated within the frame of "
"`X` and the problem occurs. Try `tmp = Z[Y]; X[tmp]`. This is robust to `X` "
"containing a column `\"tmp\"` because `tmp` is a single name. If you often "
"encounter conflicts of this type, one simple solution may be to name all "
"tables in uppercase and all column names in lowercase, or some similar scheme."
msgstr ""
"La partie `Z[Y]` n'est pas un nom unique, elle est donc évaluée dans le cadre "
"de `X` et le problème se produit. Essayez `tmp = Z[Y] ; X[tmp]`. Ceci est "
"robuste à `X` contenant une colonne `\"tmp\"` parce que `tmp` est un nom "
"unique. Si vous rencontrez souvent des conflits de ce type, une solution "
"simple peut être de nommer toutes les tables en majuscules et tous les noms "
"de colonnes en minuscules, ou un schéma similaire."

#: fr/datatable-faq.Rmd.tmp:block 111 (header)
#, fuzzy
msgid ""
"Can you explain further why data.table is inspired by `A[B]` syntax in `base`?"
msgstr ""
"Pouvez-vous nous expliquer pourquoi data.table s'inspire de la syntaxe `A[B]` "
"de `base` ?"

#: fr/datatable-faq.Rmd.tmp:block 112 (paragraph)
#, fuzzy
msgid "Consider `A[B]` syntax using an example matrix `A`:"
msgstr "Considérons la syntaxe `A[B]` en utilisant un exemple de matrice `A` :"

#: fr/datatable-faq.Rmd.tmp:block 113 (code)
#, fuzzy
msgid ""
"A = matrix(1:12, nrow = 4)\n"
"A\n"
msgstr ""
"A = matrix(1:12, nrow = 4)\n"
"A\n"

#: fr/datatable-faq.Rmd.tmp:block 114 (paragraph)
#, fuzzy
msgid ""
"To obtain cells `(1, 2) = 5` and `(3, 3) = 11` many users (we believe) may "
"try this first:"
msgstr ""
"Pour obtenir les cellules `(1, 2) = 5` et `(3, 3) = 11`, de nombreux "
"utilisateurs (nous pensons) peuvent d'abord essayer ceci :"

#: fr/datatable-faq.Rmd.tmp:block 115 (code)
#, fuzzy
msgid "A[c(1, 3), c(2, 3)]\n"
msgstr "A[c(1, 3), c(2, 3)]\n"

#: fr/datatable-faq.Rmd.tmp:block 116 (paragraph)
#, fuzzy
msgid ""
"However, this returns the union of those rows and columns. To reference the "
"cells, a 2-column matrix is required. `?Extract` says:"
msgstr ""
"Cependant, cette méthode renvoie l'union de ces lignes et de ces colonnes. "
"Pour référencer les cellules, une matrice à 2 colonnes est nécessaire. `?"
"Extract` dit :"

#: fr/datatable-faq.Rmd.tmp:block 117 (quote)
#, fuzzy
msgid ""
"When indexing arrays by `[` a single argument `i` can be a matrix with as "
"many columns as there are dimensions of `x`; the result is then a vector with "
"elements corresponding to the sets of indices in each row of `i`."
msgstr ""
"Lors de l'indexation des tableaux par `[`, un seul argument `i` peut être une "
"matrice avec autant de colonnes qu'il y a de dimensions de `x` ; le résultat "
"est alors un vecteur avec des éléments correspondant aux ensembles d'indices "
"dans chaque ligne de `i`."

#: fr/datatable-faq.Rmd.tmp:block 118 (paragraph)
#, fuzzy
msgid "Let's try again."
msgstr "Essayons encore une fois."

#: fr/datatable-faq.Rmd.tmp:block 119 (code)
#, fuzzy
msgid ""
"B = cbind(c(1, 3), c(2, 3))\n"
"B\n"
"A[B]\n"
msgstr ""
"B = cbind(c(1, 3), c(2, 3))\n"
"B\n"
"A[B]\n"

#: fr/datatable-faq.Rmd.tmp:block 120 (paragraph)
#, fuzzy
msgid ""
"A matrix is a 2-dimensional structure with row names and column names. Can we "
"do the same with names?"
msgstr ""
"Une matrice est une structure à 2 dimensions avec des noms de lignes et de "
"colonnes. Peut-on faire la même chose avec les noms ?"

#: fr/datatable-faq.Rmd.tmp:block 121 (code)
msgid ""
"rownames(A) = letters[1:4]\n"
"colnames(A) = LETTERS[1:3]\n"
"A\n"
"B = cbind(c(\"a\", \"c\"), c(\"B\", \"C\"))\n"
"A[B]\n"
msgstr ""
"rownames(A) = letters[1:4]\n"
"colnames(A) = LETTERS[1:3]\n"
"A\n"
"B = cbind(c(\"a\", \"c\"), c(\"B\", \"C\"))\n"
"A[B]\n"

#: fr/datatable-faq.Rmd.tmp:block 122 (paragraph)
#, fuzzy
msgid "So yes, we can. Can we do the same with a `data.frame`?"
msgstr ""
"Donc oui, nous pouvons le faire. Peut-on faire la même chose avec un `data."
"frame` ?"

#: fr/datatable-faq.Rmd.tmp:block 123 (code)
msgid ""
"A = data.frame(A = 1:4, B = letters[11:14], C = pi*1:4)\n"
"rownames(A) = letters[1:4]\n"
"A\n"
"B\n"
"A[B]\n"
msgstr ""
"A = data.frame(A = 1:4, B = letters[11:14], C = pi*1:4)\n"
"rownames(A) = letters[1:4]\n"
"A\n"
"B\n"
"A[B]\n"

#: fr/datatable-faq.Rmd.tmp:block 124 (paragraph)
#, fuzzy
msgid ""
"But, notice that the result was coerced to `character.` R coerced `A` to "
"`matrix` first so that the syntax could work, but the result isn't ideal. "
"Let's try making `B` a `data.frame`."
msgstr ""
"Mais, remarquez que le résultat a été coercé en `character.` R a coercé `A` "
"en `matrix` d'abord pour que la syntaxe puisse fonctionner, mais le résultat "
"n'est pas idéal. Essayons de faire de `B` un `data.frame`."

#: fr/datatable-faq.Rmd.tmp:block 125 (code)
#, fuzzy
msgid ""
"B = data.frame(c(\"a\", \"c\"), c(\"B\", \"C\"))\n"
"cat(try(A[B], silent = TRUE))\n"
msgstr ""
"B = data.frame(c(\"a\", \"c\"), c(\"B\", \"C\"))\n"
"cat(try(A[B], silent = TRUE))\n"

#: fr/datatable-faq.Rmd.tmp:block 126 (paragraph)
#, fuzzy
msgid ""
"So we can't subset a `data.frame` by a `data.frame` in base R. What if we "
"want row names and column names that aren't `character` but `integer` or "
"`float`? What if we want more than 2 dimensions of mixed types? Enter data."
"table."
msgstr ""
"Nous ne pouvons donc pas sous-enseigner un `data.frame` par un `data.frame` "
"dans la base R. Que faire si nous voulons des noms de lignes et de colonnes "
"qui ne sont pas des `caractères` mais des `integer` ou des `float` ? Que "
"faire si nous voulons plus de 2 dimensions de types mixtes ? Entrez dans data."
"table."

#: fr/datatable-faq.Rmd.tmp:block 127 (paragraph)
#, fuzzy
msgid ""
"Furthermore, matrices, especially sparse matrices, are often stored in a 3-"
"column tuple: `(i, j, value)`. This can be thought of as a key-value pair "
"where `i` and `j` form a 2-column key. If we have more than one value, "
"perhaps of different types, it might look like `(i, j, val1, val2, "
"val3, ...)`. This looks very much like a `data.frame`. Hence data.table "
"extends `data.frame` so that a `data.frame` `X` can be subset by a `data."
"frame` `Y`, leading to the `X[Y]` syntax."
msgstr ""
"En outre, les matrices, en particulier les matrices peu denses, sont souvent "
"stockées dans un tuple à trois colonnes : (i, j, valeur)`. Cela peut être "
"considéré comme une paire clé-valeur où `i` et `j` forment une clé à 2 "
"colonnes. Si nous avons plus d'une valeur, peut-être de types différents, "
"cela peut ressembler à `(i, j, val1, val2, val3, ...)`. Cela ressemble "
"beaucoup à un `data.frame`. C'est pourquoi data.table étend `data.frame` de "
"sorte qu'un `data.frame` `X` puisse être sous-ensemble d'un `data.frame` `Y`, "
"ce qui conduit à la syntaxe `X[Y]`."

#: fr/datatable-faq.Rmd.tmp:block 128 (header)
#, fuzzy
msgid "Can base be changed to do this then, rather than a new package?"
msgstr ""
"Est-il possible de modifier la base pour faire cela, plutôt que de créer un "
"nouveau paquet ?"

#: fr/datatable-faq.Rmd.tmp:block 129 (paragraph)
#, fuzzy
msgid ""
"`data.frame` is used *everywhere* and so it is very difficult to make *any* "
"changes to it. data.table *inherits* from `data.frame`. It *is* a `data."
"frame`, too. A data.table *can* be passed to any package that *only* accepts "
"`data.frame`. When that package uses `[.data.frame` syntax on the data.table, "
"it works. It works because `[.data.table` looks to see where it was called "
"from. If it was called from such a package, `[.data.table` diverts to `[.data."
"frame`."
msgstr ""
"`data.frame` est utilisé *partout* et il est donc très difficile d'y apporter "
"*un quelconque changement. data.table *hérite* de `data.frame`. C'est aussi "
"un `data.frame`. Un data.table *peut* être passé à n'importe quel paquet qui "
"*seulement* accepte `data.frame`. Quand ce paquet utilise la syntaxe `[.data."
"frame` sur le data.table, cela fonctionne. Cela fonctionne parce que `[.data."
"table` regarde d'où il a été appelé. S'il a été appelé à partir d'un tel "
"paquet, `[.data.table` se dirige vers `[.data.frame`."

#: fr/datatable-faq.Rmd.tmp:block 130 (header)
#, fuzzy
msgid "I've heard that data.table syntax is analogous to SQL."
msgstr ""
"J'ai entendu dire que la syntaxe de data.table était analogue à celle de SQL."

#: fr/datatable-faq.Rmd.tmp:block 131 (paragraph)
#, fuzzy
msgid "Yes:"
msgstr "Oui :"

#: fr/datatable-faq.Rmd.tmp:block 132 (paragraph)
msgid ""
"===== - `i` $$$\\Leftrightarrow$$$ where===== ===== - `j` $$$\\Leftrightarrow$"
"$$ select===== ===== - `:=` $$$\\Leftrightarrow$$$ update===== ===== - `by` $$"
"$\\Leftrightarrow$$$ group by===== ===== - `i` $$$\\Leftrightarrow$$$ order "
"by (in compound syntax)===== ===== - `i` $$$\\Leftrightarrow$$$ having (in "
"compound syntax)===== ===== - `nomatch = NA` $$$\\Leftrightarrow$$$ outer "
"join===== ===== - `nomatch = NULL` $$$\\Leftrightarrow$$$ inner join===== "
"===== - `mult = \"first\"|\"last\"` $$$\\Leftrightarrow$$$ N/A because SQL is "
"inherently unordered===== ===== - `roll = TRUE` $$$\\Leftrightarrow$$$ N/A "
"because SQL is inherently unordered====="
msgstr ""
"===== - `i` $$$\\Leftrightarrow$$$ where===== ===== - `j` $$$\\Leftrightarrow$"
"$$ select===== ===== - ` :=` $$$\\Leftrightarrow$$$ update===== ===== - `by` $"
"$$\\Leftrightarrow$ group by===== ===== - `i` $$$\\Leftrightarrow$$$ order by "
"(en syntaxe composée)===== ===== - `i` $$$\\Leftrightarrow$$$ having (en "
"syntaxe composée)===== ===== - `nomatch = NA` $$$\\Leftrightarrow$$$ outer "
"join===== ===== - `nomatch = NULL` $$$\\Leftrightarrow$$$ inner join===== "
"===== - `mult = \"first\"|\"last\"` $$$\\Leftrightarrow$$$ N/A parce que SQL "
"est intrinsèquement non ordonné===== ===== - `roll = TRUE` $$$"
"\\Leftrightarrow$$$ N/A parce que SQL est intrinsèquement non ordonné====="

#: fr/datatable-faq.Rmd.tmp:block 133 (paragraph)
#, fuzzy
msgid "The general form is:"
msgstr "La forme générale est la suivante :"

#: fr/datatable-faq.Rmd.tmp:block 134 (code)
#, fuzzy
msgid "DT[where, select|update, group by][order by][...] ... [...]\n"
msgstr "DT[where, select|update, group by][order by][...] ... [...]\n"

#: fr/datatable-faq.Rmd.tmp:block 135 (paragraph)
#, fuzzy
msgid ""
"A key advantage of column vectors in R is that they are *ordered*, unlike "
"SQL[^2]. We can use ordered functions in `data.table` queries such as "
"`diff()` and we can use *any* R function from any package, not just the "
"functions that are defined in SQL. A disadvantage is that R objects must fit "
"in memory, but with several R packages such as `ff`, `bigmemory`, `mmap` and "
"`indexing`, this is changing."
msgstr ""
"L'un des principaux avantages des vecteurs colonnes dans R est qu'ils sont "
"*ordonnés*, contrairement à SQL[^2]. Nous pouvons utiliser des fonctions "
"ordonnées dans les requêtes `data.table` telles que `diff()` et nous pouvons "
"utiliser *n'importe quelle fonction R de n'importe quel package, pas "
"seulement les fonctions qui sont définies dans SQL. L'inconvénient est que "
"les objets R doivent tenir dans la mémoire, mais avec plusieurs paquets R "
"tels que `ff`, `bigmemory`, `mmap` et `indexing`, cela est en train de "
"changer."

#: fr/datatable-faq.Rmd.tmp:block 136 (paragraph)
#, fuzzy
msgid ""
"[^2]: It may be a surprise to learn that `select top 10 * from ...` does "
"*not* reliably return the same rows over time in SQL. You do need to include "
"an `order by` clause, or use a clustered index to guarantee row order; *i.e."
"*, SQL is inherently unordered."
msgstr ""
"[^2]: Il peut être surprenant d'apprendre que `select top 10 * from ...` ne "
"renvoie pas de manière fiable les mêmes lignes dans le temps en SQL. Vous "
"devez inclure une clause `order by`, ou utiliser un index en grappe pour "
"garantir l'ordre des lignes ; *i.e.*, SQL est intrinsèquement non ordonné."

#: fr/datatable-faq.Rmd.tmp:block 137 (header)
#, fuzzy
msgid ""
"What are the smaller syntax differences between `data.frame` and data.table "
"{#SmallerDiffs}"
msgstr ""
"Quelles sont les petites différences de syntaxe entre `data.frame` et data."
"table {#SmallerDiffs}"

#: fr/datatable-faq.Rmd.tmp:block 138 (paragraph)
#, fuzzy
msgid ""
"===== - `DT[3]` refers to the 3rd *row*, but `DF[3]` refers to the 3rd "
"*column*===== ===== - `DT[3, ] == DT[3]`, but `DF[ , 3] == DF[3]` (somewhat "
"confusingly in data.frame, whereas data.table is consistent)===== ===== - For "
"this reason we say the comma is *optional* in `DT`, but not optional in "
"`DF`===== ===== - `DT[[3]] == DF[, 3] == DF[[3]]`===== ===== - `DT[i, ]`, "
"where `i` is a single integer, returns a single row, just like `DF[i, ]`, but "
"unlike a matrix single-row subset which returns a vector.===== ===== - `DT[ , "
"j]` where `j` is a single integer returns a one-column data.table, unlike "
"`DF[, j]` which returns a vector by default===== ===== - `DT[ , \"colA\"]"
"[[1]] == DF[ , \"colA\"]`.===== ===== - `DT[ , colA] == DF[ , \"colA\"]` "
"(currently in data.table v1.9.8 but is about to change, see release "
"notes)===== ===== - `DT[ , list(colA)] == DF[ , \"colA\", drop = FALSE]`===== "
"===== - `DT[NA]` returns 1 row of `NA`, but `DF[NA]` returns an entire copy "
"of `DF` containing `NA` throughout. The symbol `NA` is type `logical` in R "
"and is therefore recycled by `[.data.frame`. The user's intention was "
"probably `DF[NA_integer_]`. `[.data.table` diverts to this probable intention "
"automatically, for convenience.===== ===== - `DT[c(TRUE, NA, FALSE)]` treats "
"the `NA` as `FALSE`, but `DF[c(TRUE, NA, FALSE)]` returns===== `NA` rows for "
"each `NA` ===== - `DT[ColA == ColB]` is simpler than `DF[!is.na(ColA) & !is."
"na(ColB) & ColA == ColB, ]`===== ===== - `data.frame(list(1:2, \"k\", 1:4))` "
"creates 3 columns, data.table creates one `list` column.===== ===== - `check."
"names` is by default `TRUE` in `data.frame` but `FALSE` in data.table, for "
"convenience.===== ===== - `data.table` has always set "
"`stringsAsFactors=FALSE` by default. In R 4.0.0 (Apr 2020), `data.frame`'s "
"default was changed from `TRUE` to `FALSE` and there is no longer a "
"difference in this regard; see [stringsAsFactors, Kurt Hornik, Feb 2020]"
"(https://developer.r-project.org/Blog/public/2020/02/16/stringsasfactors/)."
"===== ===== - Atomic vectors in `list` columns are collapsed when printed "
"using `\", \"` in `data.frame`, but `\",\"` in data.table with a trailing "
"comma after the 6th item to avoid accidental printing of large embedded "
"objects.===== ===== - Unlike data.frames a data.table cannot store rows with "
"no columns, as rows are considered to be the children of columns: `nrow(DF[, "
"0])` returns the number of rows, while `nrow(DT[, 0])` always returns 0; but "
"see issue [#2422](https://github.com/Rdatatable/data.table/issues/2422).====="
msgstr ""
"===== - `DT[3]` fait référence à la 3ème *rangée*, mais `DF[3]` fait "
"référence à la 3ème *colonne*===== ===== - `DT[3, ] == DT[3]`, mais `DF[ , 3] "
"== DF[3]` (un peu déroutant dans data.frame, alors que data.table est "
"cohérent)===== ===== - Pour cette raison, nous disons que la virgule est "
"*optionnelle* dans `DT`, mais pas optionnelle dans `DF`===== ===== - `DT[[3]] "
"== DF[, 3] == DF[[3]]`===== ===== - `DT[i, ]`, où `i` est un seul entier, "
"renvoie une seule ligne, tout comme `DF[i, ]`, mais contrairement à un sous-"
"ensemble de matrice à une seule ligne qui renvoie un vecteur.===== ===== - "
"`DT[ , j]` où `j` est un entier renvoie un data.table à une colonne, "
"contrairement à `DF[, j]` qui renvoie un vecteur par défaut===== ===== - "
"`DT[ , \"colA\"][[1]] == DF[ , \"colA\"]`.===== ===== - `DT[ , colA] == DF[ , "
"\"colA\"]` (actuellement dans data.table v1.9.8 mais est sur le point de "
"changer, voir les notes de version)===== ===== - `DT[ , list(colA)] == DF[ , "
"\"colA\", drop = FALSE]`===== ===== - `DT[NA]` renvoie 1 ligne de `NA`, mais "
"`DF[NA]` renvoie une copie entière de `DF` contenant `NA` tout au long. Le "
"symbole `NA` est de type `logique` dans R et est donc recyclé par `[.data."
"frame`. L'intention de l'utilisateur était probablement `DF[NA_integer_]`. "
"par commodité, `[.data.table' se réoriente automatiquement vers cette "
"intention probable.===== ===== - `DT[c(TRUE, NA, FALSE)]` traite le `NA` "
"comme `FALSE`, mais `DF[c(TRUE, NA, FALSE)]` renvoie===== lignes `NA` pour "
"chaque `NA` ===== - `DT[ColA == ColB]` est plus simple que `DF[!is.na(ColA) "
"& !is.na(ColB) & ColA == ColB, ]`===== ===== - `data.frame(list(1:2, \"k\", "
"1:4))` crée 3 colonnes, data.table crée une colonne `list`.===== ===== - "
"`check.names` est par défaut `TRUE` dans `data.frame` mais `FALSE` dans data."
"table, par commodité.===== ===== - `data.table` a toujours mis "
"`stringsAsFactors=FALSE` par défaut. Dans R 4.0.0 (Apr 2020), la valeur par "
"défaut de `data.frame` a été changée de `TRUE` à `FALSE` et il n'y a plus de "
"différence à cet égard ; voir [stringsAsFactors, Kurt Hornik, Feb 2020]"
"(https://developer.r-project.org/Blog/public/2020/02/16/stringsasfactors/)."
"===== ===== - Les vecteurs atomiques dans les colonnes de `list` sont réduits "
"lorsqu'ils sont imprimés en utilisant `\", \"` dans `data.frame`, mais `\","
"\"` dans data.table avec une virgule après le 6ème élément pour éviter "
"l'impression accidentelle de gros objets intégrés.===== ===== - Contrairement "
"aux data.frames, un data.table ne peut pas stocker des lignes sans colonnes, "
"car les lignes sont considérées comme les enfants des colonnes : `nrow(DF[, "
"0])` renvoie le nombre de lignes, tandis que `nrow(DT[, 0])` renvoie toujours "
"0 ; mais voir le numéro [#2422](https://github.com/Rdatatable/data.table/"
"issues/2422).====="

#: fr/datatable-faq.Rmd.tmp:block 139 (paragraph)
#, fuzzy
msgid ""
"In `[.data.frame` we very often set `drop = FALSE`. When we forget, bugs can "
"arise in edge cases where single columns are selected and all of a sudden a "
"vector is returned rather than a single column `data.frame`. In `[.data."
"table` we took the opportunity to make it consistent and dropped `drop`."
msgstr ""
"Dans `[.data.frame`, nous mettons très souvent `drop = FALSE`. Lorsque nous "
"l'oublions, des bogues peuvent apparaître dans les cas où une seule colonne "
"est sélectionnée et où, tout à coup, un vecteur est retourné au lieu d'un "
"`data.frame` à une seule colonne. Dans `[.data.table`, nous avons saisi "
"l'opportunité de rendre les choses plus cohérentes et nous avons supprimé "
"`drop`."

#: fr/datatable-faq.Rmd.tmp:block 140 (paragraph)
#, fuzzy
msgid ""
"When a data.table is passed to a data.table-unaware package, that package is "
"not concerned with any of these differences; it just works."
msgstr ""
"Lorsqu'un data.table est transmis à un paquetage ne prenant pas en compte "
"data.table, ce paquetage ne se préoccupe pas de ces différences ; il "
"fonctionne simplement."

#: fr/datatable-faq.Rmd.tmp:block 141 (header)
#, fuzzy
msgid ""
"I'm using `j` for its side effect only, but I'm still getting data returned. "
"How do I stop that?"
msgstr ""
"J'utilise `j` pour son effet secondaire uniquement, mais je reçois toujours "
"des données en retour. Comment arrêter cela ?"

#: fr/datatable-faq.Rmd.tmp:block 142 (paragraph)
#, fuzzy
msgid ""
"In this case `j` can be wrapped with `invisible()`; e.g., `DT[ , "
"invisible(hist(colB)), by = colA]`[^3]"
msgstr ""
"Dans ce cas, `j` peut être entouré de `invisible()` ; par exemple, `DT[ , "
"invisible(hist(colB)), by = colA]`[^3]"

#: fr/datatable-faq.Rmd.tmp:block 143 (paragraph)
#, fuzzy
msgid ""
"[^3]: *e.g.*, `hist()` returns the breakpoints in addition to plotting to the "
"graphics device."
msgstr ""
"[^3]: *e.g.*, `hist()` renvoie les points d'arrêt en plus du tracé sur le "
"périphérique graphique."

#: fr/datatable-faq.Rmd.tmp:block 144 (header)
#, fuzzy
msgid "Why does `[.data.table` now have a `drop` argument from v1.5?"
msgstr ""
"Pourquoi `[.data.table` a maintenant un argument `drop` depuis la v1.5 ?"

#: fr/datatable-faq.Rmd.tmp:block 145 (paragraph)
#, fuzzy
msgid ""
"So that data.table can inherit from `data.frame` without using `...`. If we "
"used `...` then invalid argument names would not be caught."
msgstr ""
"Ainsi, data.table peut hériter de `data.frame` sans utiliser `...`. Si nous "
"utilisions `...`, les noms d'arguments invalides ne seraient pas détectés."

#: fr/datatable-faq.Rmd.tmp:block 146 (paragraph)
#, fuzzy
msgid ""
"The `drop` argument is never used by `[.data.table`. It is a placeholder for "
"non-data.table-aware packages when they use the `[.data.frame` syntax "
"directly on a data.table."
msgstr ""
"L'argument `drop` n'est jamais utilisé par `[.data.table`. C'est un substitut "
"pour les paquets non compatibles avec data.table lorsqu'ils utilisent la "
"syntaxe `[.data.frame` directement sur un data.table."

#: fr/datatable-faq.Rmd.tmp:block 147 (header)
#, fuzzy
msgid "Rolling joins are cool and very fast! Was that hard to program?"
msgstr ""
"Les jonctions par roulement sont cool et très rapides ! C'était difficile à "
"programmer ?"

#: fr/datatable-faq.Rmd.tmp:block 148 (paragraph)
#, fuzzy
msgid ""
"The prevailing row on or before the `i` row is the final row the binary "
"search tests anyway. So `roll = TRUE` is essentially just a switch in the "
"binary search C code to return that row."
msgstr ""
"La ligne dominante sur ou avant la ligne `i` est la ligne finale que la "
"recherche binaire teste de toute façon. Donc `roll = TRUE` est "
"essentiellement un interrupteur dans le code C de la recherche binaire pour "
"retourner cette ligne."

#: fr/datatable-faq.Rmd.tmp:block 149 (header)
#, fuzzy
msgid ""
"Why does `DT[i, col := value]` return the whole of `DT`? I expected either no "
"visible value (consistent with `<-`), or a message or return value containing "
"how many rows were updated. It isn't obvious that the data has indeed been "
"updated by reference."
msgstr ""
"Pourquoi `DT[i, col := valeur]` retourne-t-il la totalité de `DT` ? Je "
"m'attendais à ce qu'il n'y ait pas de valeur visible (ce qui est cohérent "
"avec `<-`), ou à ce qu'il y ait un message ou une valeur de retour contenant "
"le nombre de lignes mises à jour. Il n'est pas évident que les données aient "
"été mises à jour par référence."

#: fr/datatable-faq.Rmd.tmp:block 150 (paragraph)
#, fuzzy
msgid "This has changed in v1.8.3 to meet your expectations. Please upgrade."
msgstr ""
"Ceci a été modifié dans la version 1.8.3 pour répondre à vos attentes. "
"Veuillez mettre à jour."

#: fr/datatable-faq.Rmd.tmp:block 151 (paragraph)
#, fuzzy
msgid ""
"The whole of `DT` is returned (now invisibly) so that compound syntax can "
"work; *e.g.*, `DT[i, done := TRUE][ , sum(done)]`. The number of rows updated "
"is returned when `verbose` is `TRUE`, either on a per-query basis or globally "
"using `options(datatable.verbose = TRUE)`."
msgstr ""
"L'ensemble de `DT` est retourné (maintenant de manière invisible) pour que la "
"syntaxe composée puisse fonctionner ; *e.g.*, `DT[i, done := TRUE][ , "
"sum(done)]`. Le nombre de lignes mises à jour est retourné quand `verbose` "
"est `TRUE`, soit sur une base par requête, soit globalement en utilisant "
"`options(datatable.verbose = TRUE)`."

#: fr/datatable-faq.Rmd.tmp:block 152 (header)
#, fuzzy
msgid ""
"OK, thanks. What was so difficult about the result of `DT[i, col := value]` "
"being returned invisibly?"
msgstr ""
"D'accord, merci. Qu'y a-t-il de si difficile dans le fait que le résultat de "
"`DT[i, col := value]` soit renvoyé de façon invisible ?"

#: fr/datatable-faq.Rmd.tmp:block 153 (paragraph)
#, fuzzy
msgid ""
"R internally forces visibility on for `[`. The value of FunTab's eval column "
"(see [src/main/names.c](https://github.com/wch/r-source/blob/trunk/src/main/"
"names.c)) for `[` is `0` meaning \"force `R_Visible` on\" (see [R-Internals "
"section 1.6](https://cran.r-project.org/doc/manuals/r-release/R-ints."
"html#Autoprinting) ). Therefore, when we tried `invisible()` or setting "
"`R_Visible` to `0` directly ourselves, `eval` in [src/main/eval.c](https://"
"github.com/wch/r-source/blob/trunk/src/main/eval.c) would force it on again."
msgstr ""
"R force en interne la visibilité pour `[`. La valeur de la colonne eval de "
"FunTab (voir [src/main/names.c](https://github.com/wch/r-source/blob/trunk/"
"src/main/names.c)) pour `[` est `0` ce qui signifie \"force `R_Visible` on\" "
"(voir [R-Internals section 1.6](https://cran.r-project.org/doc/manuals/r-"
"release/R-ints.html#Autoprinting) ). Par conséquent, lorsque nous avons "
"essayé `invisible()` ou de mettre `R_Visible` à `0` directement nous-mêmes, "
"`eval` dans [src/main/eval.c](https://github.com/wch/r-source/blob/trunk/src/"
"main/eval.c) l'a forcé à nouveau."

#: fr/datatable-faq.Rmd.tmp:block 154 (paragraph)
#, fuzzy
msgid ""
"To solve this problem, the key was to stop trying to stop the print method "
"running after a `:=`. Instead, inside `:=` we now (from v1.8.3) set a global "
"flag which the print method uses to know whether to actually print or not."
msgstr ""
"Pour résoudre ce problème, la clé était de ne plus essayer d'arrêter "
"l'exécution de la méthode print après un `:=`. Au lieu de cela, à l'intérieur "
"de `:=` nous mettons maintenant (à partir de la version 1.8.3) un drapeau "
"global que la méthode print utilise pour savoir si elle doit imprimer ou non."

#: fr/datatable-faq.Rmd.tmp:block 155 (header)
#, fuzzy
msgid ""
"Why do I have to type `DT` sometimes twice after using `:=` to print the "
"result to console?"
msgstr ""
"Pourquoi dois-je taper `DT` parfois deux fois après avoir utilisé `:=` pour "
"imprimer le résultat dans la console ?"

#: fr/datatable-faq.Rmd.tmp:block 156 (paragraph)
#, fuzzy
msgid ""
"This is an unfortunate downside to get [#869](https://github.com/Rdatatable/"
"data.table/issues/869) to work. If a `:=` is used inside a function with no "
"`DT[]` before the end of the function, then the next time `DT` is typed at "
"the prompt, nothing will be printed. A repeated `DT` will print. To avoid "
"this: include a `DT[]` after the last `:=` in your function. If that is not "
"possible (e.g., it's not a function you can change) then `print(DT)` and "
"`DT[]` at the prompt are guaranteed to print. As before, adding an extra `[]` "
"on the end of `:=` query is a recommended idiom to update and then print; e.g."
"> `DT[,foo:=3L][]`."
msgstr ""
"C'est un inconvénient malheureux pour faire fonctionner [#869](https://github."
"com/Rdatatable/data.table/issues/869). Si un `:=` est utilisé à l'intérieur "
"d'une fonction sans `DT[]` avant la fin de la fonction, alors la prochaine "
"fois que `DT` est tapé à l'invite, rien ne sera imprimé. Un `DT` répété sera "
"imprimé. Pour éviter cela : incluez un `DT[]` après le dernier `:=` dans "
"votre fonction. Si ce n'est pas possible (par exemple, ce n'est pas une "
"fonction que vous pouvez changer), alors `print(DT)` et `DT[]` à l'invite "
"sont garantis de s'imprimer. Comme précédemment, l'ajout d'un `[]` "
"supplémentaire à la fin de la requête `:=` est un idiome recommandé pour "
"mettre à jour et ensuite imprimer ; e.g.> `DT[,foo:=3L][]`."

#: fr/datatable-faq.Rmd.tmp:block 157 (header)
#, fuzzy
msgid ""
"I've noticed that `base::cbind.data.frame` (and `base::rbind.data.frame`) "
"appear to be changed by data.table. How is this possible? Why?"
msgstr ""
"J'ai remarqué que `base::cbind.data.frame` (et `base::rbind.data.frame`) "
"semble être modifié par data.table. Comment cela est-il possible ? Pourquoi ?"

#: fr/datatable-faq.Rmd.tmp:block 158 (paragraph)
#, fuzzy
msgid ""
"It was a temporary, last resort solution before rbind and cbind S3 method "
"dispatch was fixed in R >= 4.0.0. Essentially, the issue was that `data."
"table` inherits from `data.frame`, *and* `base::cbind` and `base::rbind` "
"(uniquely) do their own S3 dispatch internally as documented by `?cbind`. The "
"`data.table` workaround was adding one `for` loop to the start of each "
"function directly in `base`. That modification was made dynamically, *i.e.*, "
"the `base` definition of `cbind.data.frame` was fetched, the `for` loop added "
"to the beginning, and then assigned back to `base`. This solution was "
"designed to be robust to different definitions of `base::cbind.data.frame` in "
"different versions of R, including unknown future changes. It worked well. "
"The competing requirements were:"
msgstr ""
"C'était une solution temporaire de dernier recours avant que le dispatching "
"des méthodes S3 de rbind et cbind ne soit corrigé dans R >= 4.0.0. "
"Essentiellement, le problème était que `data.table` hérite de `data.frame`, "
"*et* `base::cbind` et `base::rbind` (uniquement) font leur propre dispatching "
"S3 en interne comme documenté par `?cbind`. La solution pour `data.table` "
"était d'ajouter une boucle `for` au début de chaque fonction directement dans "
"`base`. Cette modification était faite dynamiquement, *c'est-à-dire que la "
"définition `base` de `cbind.data.frame` était récupérée, la boucle `for` "
"ajoutée au début, et ensuite réassignée à `base`. Cette solution a été conçue "
"pour être robuste aux différentes définitions de `base::cbind.data.frame` "
"dans les différentes versions de R, y compris les changements futurs "
"inconnus. Elle a bien fonctionné. Les exigences concurrentes étaient les "
"suivantes :"

#: fr/datatable-faq.Rmd.tmp:block 159 (paragraph)
#, fuzzy
msgid ""
"===== - `cbind(DT, DF)` needs to work. Defining `cbind.data.table` didn't "
"work because `base::cbind` does its own S3 dispatch and required (before R "
"4.0.0) that the *first* `cbind` method for each object it is passed is "
"*identical*. This is not true in `cbind(DT, DF)` because the first method for "
"`DT` is `cbind.data.table` but the first method for `DF` is `cbind.data."
"frame`. `base::cbind` then fell through to its internal `bind` code which "
"appears to treat `DT` as a regular `list` and returns very odd looking and "
"unusable `matrix` output. See [below](#cbinderror). We cannot just advise "
"users not to call `cbind(DT, DF)` because packages such as `ggplot2` make "
"such a call ([test 167.2](https://github.com/Rdatatable/data.table/blob/"
"master/inst/tests/tests.Rraw#L444-L447)).====="
msgstr ""
"===== - `cbind(DT, DF)` doit fonctionner. Définir `cbind.data.table` ne "
"fonctionnait pas parce que `base::cbind` fait sa propre distribution S3 et "
"requiert (avant R 4.0.0) que la *première* méthode `cbind` pour chaque objet "
"qui lui est passé soit *identique*. Ce n'est pas vrai dans `cbind(DT, DF)` "
"parce que la première méthode pour `DT` est `cbind.data.table` mais la "
"première méthode pour `DF` est `cbind.data.frame`. `base::cbind` passe alors "
"à son code `bind` interne qui semble traiter `DT` comme une `liste` normale "
"et renvoie une sortie `matrix` très bizarre et inutilisable. Voir [ci-dessous]"
"(#cbinderror). Nous ne pouvons pas simplement conseiller aux utilisateurs de "
"ne pas appeler `cbind(DT, DF)` parce que des paquets comme `ggplot2` font un "
"tel appel ([test 167.2](https://github.com/Rdatatable/data.table/blob/master/"
"inst/tests/tests.Rraw#L444-L447)).====="

#: fr/datatable-faq.Rmd.tmp:block 160 (paragraph)
#, fuzzy
msgid ""
"===== - This naturally led to trying to mask `cbind.data.frame` instead. "
"Since a data.table is a `data.frame`, `cbind` would find the same method for "
"both `DT` and `DF`. However, this didn't work either because `base::cbind` "
"appears to find methods in `base` first; *i.e.*, `base::cbind.data.frame` "
"isn't maskable.====="
msgstr ""
"===== - Cela a naturellement conduit à essayer de masquer `cbind.data.frame` "
"à la place. Puisqu'une data.table est un `data.frame`, `cbind` trouverait la "
"même méthode pour `DT` et `DF`. Cependant, cela n'a pas fonctionné non plus "
"parce que `base::cbind` semble trouver les méthodes dans `base` en premier ; "
"*i.e.*, `base::cbind.data.frame` n'est pas masquable.====="

#: fr/datatable-faq.Rmd.tmp:block 161 (paragraph)
#, fuzzy
msgid ""
"===== - Finally, we tried masking `cbind` itself (v1.6.5 and v1.6.6). This "
"allowed `cbind(DT, DF)` to work, but introduced compatibility issues with "
"package `IRanges`, since `IRanges` also masks `cbind`. It worked if `IRanges` "
"was lower on the `search()` path than data.table, but if `IRanges` was higher "
"then data.table's, `cbind` would never be called and the strange-looking "
"`matrix` output occurs again (see [below](#cbinderror)).====="
msgstr ""
"===== - Finalement, nous avons essayé de masquer `cbind` lui-même (v1.6.5 et "
"v1.6.6). Cela a permis à `cbind(DT, DF)` de fonctionner, mais a introduit des "
"problèmes de compatibilité avec le paquet `IRanges`, puisque `IRanges` masque "
"aussi `cbind`. Cela fonctionnait si `IRanges` était plus bas dans le chemin "
"`search()` que data.table, mais si `IRanges` était plus haut que data.table, "
"`cbind` n'était jamais appelé et l'étrange sortie `matrix` se produisait à "
"nouveau (voir [ci-dessous](#cbinderror)).====="

#: fr/datatable-faq.Rmd.tmp:block 162 (paragraph)
#, fuzzy
msgid ""
"Many thanks to the R core team for fixing the issue in Sep 2019. data.table "
"v1.12.6+ no longer applies the workaround in R >= 4.0.0."
msgstr ""
"Un grand merci à l'équipe de base de R pour avoir résolu le problème en "
"septembre 2019. data.table v1.12.6+ n'applique plus la solution de "
"contournement dans R >= 4.0.0."

#: fr/datatable-faq.Rmd.tmp:block 163 (header)
#, fuzzy
msgid ""
"I've read about method dispatch (*e.g.* `merge` may or may not dispatch to "
"`merge.data.table`) but *how* does R know how to dispatch? Are dots "
"significant or special? How on earth does R know which function to dispatch "
"and when? {#r-dispatch}"
msgstr ""
"J'ai lu des articles sur la répartition des méthodes (*e.g.* `merge` peut ou "
"non être réparti dans `merge.data.table`) mais *comment* R sait-il comment "
"répartir ? Les points sont-ils significatifs ou spéciaux ? Comment diable R "
"sait-il quelle fonction doit être distribuée et à quel moment ? {#r-dispatch}"

#: fr/datatable-faq.Rmd.tmp:block 164 (paragraph)
#, fuzzy
msgid ""
"This comes up quite a lot but it's really earth-shatteringly simple. A "
"function such as `merge` is *generic* if it consists of a call to "
"`UseMethod`. When you see people talking about whether or not functions are "
"*generic* functions they are merely typing the function without `()` "
"afterwards, looking at the program code inside it and if they see a call to "
"`UseMethod` then it is *generic*. What does `UseMethod` do? It literally "
"slaps the function name together with the class of the first argument, "
"separated by period (`.`) and then calls that function, passing along the "
"same arguments. It's that simple. For example, `merge(X, Y)` contains a "
"`UseMethod` call which means it then *dispatches* (i.e. calls) "
"`paste(\"merge\", class(X), sep = \".\")`. Functions with dots in their name "
"may or may not be methods. The dot is irrelevant really, other than dot being "
"the separator that `UseMethod` uses. Knowing this background should now "
"highlight why, for example, it is obvious to R folk that `as.data.table.data."
"frame` is the `data.frame` method for the `as.data.table` generic function. "
"Further, it may help to elucidate that, yes, you are correct, it is not "
"obvious from its name alone that `ls.fit` is not the fit method of the `ls` "
"generic function. You only know that by typing `ls` (not `ls()`) and "
"observing it isn't a single call to `UseMethod`."
msgstr ""
"On en parle souvent, mais c'est d'une simplicité déconcertante. Une fonction "
"telle que `merge` est *générique* si elle consiste en un appel à `UseMethod`. "
"Quand vous voyez des gens parler de la question de savoir si les fonctions "
"sont *génériques* ou non, ils tapent simplement la fonction sans `()` après, "
"regardent le code du programme à l'intérieur et s'ils voient un appel à "
"`UseMethod` alors c'est *générique*. Que fait `UseMethod` ? Elle colle "
"littéralement le nom de la fonction avec la classe du premier argument, "
"séparés par un point (`.`) et appelle ensuite cette fonction, en lui passant "
"les mêmes arguments. C'est aussi simple que cela. Par exemple, `merge(X, Y)` "
"contient un appel à `UseMethod`, ce qui signifie qu'il *dispatche* (c'est-à-"
"dire appelle) `paste(\"merge\", class(X), sep = \".\")`. Les fonctions avec "
"des points dans leur nom peuvent ou non être des méthodes. Le point n'est pas "
"vraiment pertinent, autre que le point est le séparateur utilisé par "
"`UseMethod`. Connaître ce contexte devrait maintenant permettre de comprendre "
"pourquoi, par exemple, il est évident pour les utilisateurs de R que `as.data."
"table.data.frame` est la méthode `data.frame` pour la fonction générique `as."
"data.table`. De plus, il peut être utile d'élucider que, oui, vous avez "
"raison, il n'est pas évident à partir de son seul nom que `ls.fit` n'est pas "
"la méthode fit de la fonction générique `ls`. Vous ne le savez qu'en tapant "
"`ls` (pas `ls()`) et en observant qu'il n'y a pas un seul appel à `UseMethod`."

#: fr/datatable-faq.Rmd.tmp:block 165 (paragraph)
#, fuzzy
msgid ""
"You might now ask: where is this documented in R? Answer: it's quite clear, "
"but, you need to first know to look in `?UseMethod` and *that* help file "
"contains:"
msgstr ""
"Vous pouvez maintenant vous demander : où cela est-il documenté dans R ? "
"Réponse : c'est assez clair, mais vous devez d'abord savoir qu'il faut "
"chercher dans `?UseMethod` et *ce* fichier d'aide contient :"

#: fr/datatable-faq.Rmd.tmp:block 166 (quote)
#, fuzzy
msgid ""
"When a function calling `UseMethod('fun')` is applied to an object with class "
"attribute `c('first', 'second')`, the system searches for a function called "
"`fun.first` and, if it finds it, applies it to the object. If no such "
"function is found a function called `fun.second` is tried. If no class name "
"produces a suitable function, the function `fun.default` is used, if it "
"exists, or an error results."
msgstr ""
"Lorsqu'une fonction appelant `UseMethod('fun')` est appliquée à un objet avec "
"l'attribut de classe `c('first', 'second')`, le système recherche une "
"fonction appelée `fun.first` et, s'il la trouve, l'applique à l'objet. Si "
"aucune fonction de ce type n'est trouvée, une fonction appelée `fun.second` "
"est essayée. Si aucun nom de classe ne produit une fonction appropriée, la "
"fonction `fun.default` est utilisée, si elle existe, ou une erreur se produit."

#: fr/datatable-faq.Rmd.tmp:block 167 (paragraph)
#, fuzzy
msgid ""
"Happily, an internet search for \"How does R method dispatch work\" (at the "
"time of this writing) returns the `?UseMethod` help page in the top few "
"links. Admittedly, other links rapidly descend into the intricacies of S3 vs "
"S4, internal generics and so on."
msgstr ""
"Heureusement, une recherche internet sur \"How does R method dispatch work\" "
"(à l'heure où j'écris ces lignes) renvoie la page d'aide `?UseMethod` dans "
"les premiers liens. Certes, les autres liens descendent rapidement dans les "
"subtilités de S3 vs S4, les génériques internes et ainsi de suite."

#: fr/datatable-faq.Rmd.tmp:block 168 (paragraph)
#, fuzzy
msgid ""
"However, features like basic S3 dispatch (pasting the function name together "
"with the class name) is why some R folk love R. It's so simple. No "
"complicated registration or signature is required. There isn't much needed to "
"learn. To create the `merge` method for data.table all that was required, "
"literally, was to merely create a function called `merge.data.table`."
msgstr ""
"Cependant, des fonctionnalités telles que l'envoi S3 de base (coller le nom "
"de la fonction avec le nom de la classe) sont la raison pour laquelle "
"certains adeptes de R aiment R. C'est tellement simple. Aucune inscription ou "
"signature compliquée n'est requise. Il n'y a pas grand chose à apprendre. "
"Pour créer la méthode `merge` pour data.table, tout ce qui était nécessaire, "
"littéralement, était de créer une fonction appelée `merge.data.table`."

#: fr/datatable-faq.Rmd.tmp:block 169 (header)
#, fuzzy
msgid "Questions relating to compute time"
msgstr "Questions relatives au temps de calcul"

#: fr/datatable-faq.Rmd.tmp:block 170 (header)
#, fuzzy
msgid ""
"I have 20 columns and a large number of rows. Why is an expression of one "
"column so quick?"
msgstr ""
"J'ai 20 colonnes et un grand nombre de lignes. Pourquoi l'expression d'une "
"colonne est-elle si rapide ?"

#: fr/datatable-faq.Rmd.tmp:block 171 (paragraph)
#, fuzzy
msgid "Several reasons:"
msgstr "Plusieurs raisons à cela :"

#: fr/datatable-faq.Rmd.tmp:block 172 (paragraph)
#, fuzzy
msgid ""
"===== - Only that column is grouped, the other 19 are ignored because data."
"table inspects the `j` expression and realises it doesn't use the other "
"columns.===== ===== - One memory allocation is made for the largest group "
"only, then that memory is re-used for the other groups. There is very little "
"garbage to collect.===== ===== - R is an in-memory column store; i.e., the "
"columns are contiguous in RAM. Page fetches from RAM into L2 cache are "
"minimised.====="
msgstr ""
"===== - Seule cette colonne est groupée, les 19 autres sont ignorées parce "
"que data.table inspecte l'expression `j` et réalise qu'elle n'utilise pas les "
"autres colonnes.===== ===== - Une allocation de mémoire est faite pour le "
"plus grand groupe seulement, puis cette mémoire est réutilisée pour les "
"autres groupes. Il y a très peu de déchets à collecter.===== ===== - R est un "
"magasin de colonnes en mémoire, c'est-à-dire que les colonnes sont contiguës "
"dans la RAM. Les extractions de pages de la RAM vers la mémoire cache L2 sont "
"réduites au minimum.====="

#: fr/datatable-faq.Rmd.tmp:block 173 (header)
#, fuzzy
msgid ""
"I don't have a `key` on a large table, but grouping is still really quick. "
"Why is that?"
msgstr ""
"Je n'ai pas de `key` sur une grande table, mais le regroupement est toujours "
"très rapide. Comment cela se fait-il ?"

#: fr/datatable-faq.Rmd.tmp:block 174 (paragraph)
#, fuzzy
msgid ""
"data.table uses radix sorting. This is significantly faster than other sort "
"algorithms. See [our presentations](https://github.com/Rdatatable/data.table/"
"wiki/Presentations) for more information, in particular from useR!2015 "
"Denmark."
msgstr ""
"data.table utilise le tri radix. Il est nettement plus rapide que les autres "
"algorithmes de tri. Voir [nos présentations](https://github.com/Rdatatable/"
"data.table/wiki/Presentations) pour plus d'informations, en particulier sur "
"useR!2015 Danemark."

#: fr/datatable-faq.Rmd.tmp:block 175 (paragraph)
#, fuzzy
msgid "This is also one reason why `setkey()` is quick."
msgstr "C'est aussi l'une des raisons pour lesquelles `setkey()` est rapide."

#: fr/datatable-faq.Rmd.tmp:block 176 (paragraph)
#, fuzzy
msgid ""
"When no `key` is set, or we group in a different order from that of the key, "
"we call it an *ad hoc* `by`."
msgstr ""
"Lorsqu'aucune \"clé\" n'est définie, ou que l'on regroupe dans un ordre "
"différent de celui de la clé, on parle d'un \"by\" *ad hoc."

#: fr/datatable-faq.Rmd.tmp:block 177 (header)
#, fuzzy
msgid "Why is grouping by columns in the key faster than an *ad hoc* `by`?"
msgstr ""
"Pourquoi le regroupement par colonnes dans la clé est-il plus rapide qu'un "
"*ad hoc* `by` ?"

#: fr/datatable-faq.Rmd.tmp:block 178 (paragraph)
#, fuzzy
msgid ""
"Because each group is contiguous in RAM, thereby minimising page fetches and "
"memory can be copied in bulk (`memcpy` in C) rather than looping in C."
msgstr ""
"Parce que chaque groupe est contigu en RAM, ce qui minimise les recherches de "
"pages et que la mémoire peut être copiée en masse (`memcpy` en C) plutôt "
"qu'en boucle en C."

#: fr/datatable-faq.Rmd.tmp:block 179 (header)
#, fuzzy
msgid "What are primary and secondary indexes in data.table?"
msgstr "Que sont les index primaires et secondaires dans data.table ?"

#: fr/datatable-faq.Rmd.tmp:block 180 (paragraph)
#, fuzzy
msgid ""
"Manual: [`?setkey`](https://www.rdocumentation.org/packages/data.table/"
"functions/setkey) S.O.: [What is the purpose of setting a key in data.table?]"
"(https://stackoverflow.com/questions/20039335/what-is-the-purpose-of-setting-"
"a-key-in-data-table/20057411#20057411)"
msgstr ""
"Manuel : [`?setkey`](https://www.rdocumentation.org/packages/data.table/"
"functions/setkey) S.O. : [Quel est l'intérêt de définir une clé dans data."
"table ?](https://stackoverflow.com/questions/20039335/what-is-the-purpose-of-"
"setting-a-key-in-data-table/20057411#20057411)"

#: fr/datatable-faq.Rmd.tmp:block 181 (paragraph)
#, fuzzy
msgid ""
"`setkey(DT, col1, col2)` orders the rows by column `col1` then within each "
"group of `col1` it orders by `col2`. This is a *primary index*. The row order "
"is changed *by reference* in RAM. Subsequent joins and groups on those key "
"columns then take advantage of the sort order for efficiency. (Imagine how "
"difficult looking for a phone number in a printed telephone directory would "
"be if it wasn't sorted by surname then forename. That's literally all "
"`setkey` does. It sorts the rows by the columns you specify.) The index "
"doesn't use any RAM. It simply changes the row order in RAM and marks the key "
"columns. Analogous to a *clustered index* in SQL."
msgstr ""
"`setkey(DT, col1, col2)` ordonne les lignes par la colonne `col1` puis à "
"l'intérieur de chaque groupe de `col1` il ordonne par `col2`. Il s'agit d'un "
"*index primaire*. L'ordre des lignes est modifié *par référence* en RAM. Les "
"jointures et les groupes ultérieurs sur ces colonnes clés profitent alors de "
"l'ordre de tri pour plus d'efficacité. (Imaginez à quel point la recherche "
"d'un numéro de téléphone dans un annuaire imprimé serait difficile s'il "
"n'était pas trié par nom puis par prénom. C'est littéralement tout ce que "
"fait `setkey`. Il trie les lignes en fonction des colonnes que vous "
"spécifiez) L'index n'utilise pas de RAM. Il change simplement l'ordre des "
"lignes en RAM et marque les colonnes clés. Analogue à un *index groupé* en "
"SQL."

#: fr/datatable-faq.Rmd.tmp:block 182 (paragraph)
#, fuzzy
msgid ""
"However, you can only have one primary key because data can only be "
"physically sorted in RAM in one way at a time. Choose the primary index to be "
"the one you use most often (e.g. `[id,date]`). Sometimes there isn't an "
"obvious choice for the primary key or you need to join and group many "
"different columns in different orders. Enter a secondary index. This does use "
"memory (`4*nrow` bytes regardless of the number of columns in the index) to "
"store the order of the rows by the columns you specify, but doesn't actually "
"reorder the rows in RAM. Subsequent joins and groups take advantage of the "
"secondary key's order but need to *hop* via that index so aren't as efficient "
"as primary indexes. But still, a lot faster than a full vector scan. There is "
"no limit to the number of secondary indexes since each one is just a "
"different ordering vector. Typically you don't need to create secondary "
"indexes. They are created automatically and used for you automatically by "
"using data.table normally; *e.g.* `DT[someCol == someVal, ]` and `DT[someCol "
"%in% someVals, ]` will create, attach and then use the secondary index. This "
"is faster in data.table than a vector scan so automatic indexing is on by "
"default since there is no up-front penalty. There is an option to turn off "
"automatic indexing; *e.g.*, if somehow many indexes are being created and "
"even the relatively small amount of extra memory becomes too large."
msgstr ""
"Cependant, vous ne pouvez avoir qu'une seule clé primaire car les données ne "
"peuvent être triées physiquement dans la mémoire vive que d'une seule manière "
"à la fois. Choisissez l'index primaire comme étant celui que vous utilisez le "
"plus souvent (par exemple `[id,date]`). Parfois, il n'y a pas de choix "
"évident pour la clé primaire ou vous devez joindre et grouper de nombreuses "
"colonnes différentes dans des ordres différents. Entrez un index secondaire. "
"Celui-ci utilise de la mémoire (`4*nrow` bytes indépendamment du nombre de "
"colonnes dans l'index) pour stocker l'ordre des lignes selon les colonnes que "
"vous spécifiez, mais ne réordonne pas réellement les lignes en RAM. Les "
"jointures et les groupes ultérieurs profitent de l'ordre de la clé secondaire "
"mais doivent *sauter* via cet index et ne sont donc pas aussi efficaces que "
"les index primaires. Ils sont donc moins efficaces que les index primaires. "
"Mais ils sont tout de même beaucoup plus rapides qu'un balayage vectoriel "
"complet. Il n'y a pas de limite au nombre d'index secondaires puisque chacun "
"d'entre eux est simplement un vecteur d'ordre différent. En général, il n'est "
"pas nécessaire de créer des index secondaires. Ils sont créés automatiquement "
"et utilisés pour vous automatiquement en utilisant data.table normalement ; "
"*e.g.* `DT[someCol == someVal, ]` et `DT[someCol %in% someVals, ]` créeront, "
"attacheront et utiliseront ensuite l'index secondaire. Ceci est plus rapide "
"dans data.table qu'un balayage vectoriel, donc l'indexation automatique est "
"activée par défaut puisqu'il n'y a pas de pénalité initiale. Il existe une "
"option pour désactiver l'indexation automatique ; *e.g.*, si beaucoup d'index "
"sont créés et que même la quantité relativement faible de mémoire "
"supplémentaire devient trop importante."

#: fr/datatable-faq.Rmd.tmp:block 183 (paragraph)
#, fuzzy
msgid "We use the words *index* and *key* interchangeably."
msgstr "Nous utilisons les mots *index* et *clé* de manière interchangeable."

#: fr/datatable-faq.Rmd.tmp:block 184 (header)
#, fuzzy
msgid "Error messages"
msgstr "Messages d'erreur"

#: fr/datatable-faq.Rmd.tmp:block 185 (header)
#, fuzzy
msgid "\"Could not find function `DT`\""
msgstr "\"Impossible de trouver la fonction `DT`\""

#: fr/datatable-faq.Rmd.tmp:block 186 (paragraph)
#, fuzzy
msgid "See above [here](#DTremove1) and [here](#DTremove2)."
msgstr "Voir ci-dessus [ici](#DTremove1) et [ici](#DTremove2)."

#: fr/datatable-faq.Rmd.tmp:block 187 (header)
#, fuzzy
msgid "\"unused argument(s) (`MySum = sum(v)`)\""
msgstr "\"argument(s) non utilisé(s) (`MySum = sum(v)`)\""

#: fr/datatable-faq.Rmd.tmp:block 188 (paragraph)
#, fuzzy
msgid ""
"This error is generated by `DT[ , MySum = sum(v)]`. `DT[ , .(MySum = "
"sum(v))]` was intended, or `DT[ , j = .(MySum = sum(v))]`."
msgstr ""
"Cette erreur est générée par `DT[ , MySum = sum(v)]`. `DT[ , .(MySum = "
"sum(v))]` était prévu, ou `DT[ , j = .(MySum = sum(v))]`."

#: fr/datatable-faq.Rmd.tmp:block 189 (header)
#, fuzzy
msgid "\"`translateCharUTF8` must be called on a `CHARSXP`\""
msgstr "\"`translateCharUTF8` doit être appelé sur un `CHARSXP`\""

#: fr/datatable-faq.Rmd.tmp:block 190 (paragraph)
msgid ""
"This error (and similar, *e.g.*, \"`getCharCE` must be called on a "
"`CHARSXP`\") may be nothing do with character data or locale. Instead, this "
"can be a symptom of an earlier memory corruption. To date these have been "
"reproducible and fixed (quickly). Please report it to our [issues tracker]"
"(https://github.com/Rdatatable/data.table/issues)."
msgstr ""
"Cette erreur (et d'autres similaires, *e.g.*, \"`getCharCE` must be called on "
"a `CHARSXP`\") peut n'avoir rien à voir avec les données de caractères ou la "
"locale. Au lieu de cela, cela peut être le symptôme d'une corruption de "
"mémoire antérieure. Jusqu'à présent, ces problèmes ont pu être reproduits et "
"corrigés (rapidement). Merci de le signaler sur notre [gestionnaire de "
"tickets (issues tracker)](https://github.com/Rdatatable/data.table/issues)."

#: fr/datatable-faq.Rmd.tmp:block 191 (header)
#, fuzzy
msgid ""
"`cbind(DT, DF)` returns a strange format, *e.g.* `Integer,5` {#cbinderror}"
msgstr ""
"`cbind(DT, DF)` renvoie un format étrange, *e.g.* `Integer,5` {#cbinderror}"

#: fr/datatable-faq.Rmd.tmp:block 192 (paragraph)
#, fuzzy
msgid ""
"This occurs prior to v1.6.5, for `rbind(DT, DF)` too. Please upgrade to "
"v1.6.7 or later."
msgstr ""
"Cela se produit avant la version 1.6.5, pour `rbind(DT, DF)` également. "
"Veuillez mettre à jour vers la version 1.6.7 ou ultérieure."

#: fr/datatable-faq.Rmd.tmp:block 193 (header)
#, fuzzy
msgid "\"cannot change value of locked binding for `.SD`\""
msgstr ""
"\"cannot change value of locked binding for `.SD`\" (Impossible de modifier "
"la valeur d'une liaison verrouillée pour `.SD`)"

#: fr/datatable-faq.Rmd.tmp:block 194 (paragraph)
#, fuzzy
msgid ""
"`.SD` is locked by design. See `?data.table`. If you'd like to manipulate `."
"SD` before using it, or returning it, and don't wish to modify `DT` using `:"
"=`, then take a copy first (see `?copy`), *e.g.*,"
msgstr ""
"`.SD` est verrouillé par conception. Voir `?data.table`. Si vous voulez "
"manipuler `.SD` avant de l'utiliser ou de le retourner, et que vous ne "
"souhaitez pas modifier `DT` en utilisant `:=`, prenez d'abord une copie (voir "
"`?copy`), *e.g.*,"

#: fr/datatable-faq.Rmd.tmp:block 195 (code)
msgid ""
"DT = data.table(a = rep(1:3, 1:3), b = 1:6, c = 7:12)\n"
"DT\n"
"DT[ , { mySD = copy(.SD)\n"
"      mySD[1, b := 99L]\n"
"      mySD},\n"
"    by = a]\n"
msgstr ""
"DT = data.table(a = rep(1:3, 1:3), b = 1:6, c = 7:12)\n"
"DT\n"
"DT[ , { mySD = copy(.SD)\n"
"      mySD[1, b := 99L]\n"
"      mySD},\n"
"    by = a]\n"

#: fr/datatable-faq.Rmd.tmp:block 196 (header)
#, fuzzy
msgid "\"cannot change value of locked binding for `.N`\""
msgstr ""
"\"cannot change value of locked binding for `.N`\" (Impossible de modifier la "
"valeur d'une liaison verrouillée pour `.N`)"

#: fr/datatable-faq.Rmd.tmp:block 197 (paragraph)
#, fuzzy
msgid ""
"Please upgrade to v1.8.1 or later. From this version, if `.N` is returned by "
"`j` it is renamed to `N` to avoid any ambiguity in any subsequent grouping "
"between the `.N` special variable and a column called `\".N\"`."
msgstr ""
"Veuillez mettre à jour vers la version 1.8.1 ou plus récente. A partir de "
"cette version, si `.N` est retourné par `j`, il est renommé en `N` pour "
"éviter toute ambiguïté dans un regroupement ultérieur entre la variable "
"spéciale `.N` et une colonne appelée `\".N\"`."

#: fr/datatable-faq.Rmd.tmp:block 198 (paragraph)
#, fuzzy
msgid ""
"The old behaviour can be reproduced by forcing `.N` to be called `.N`, like "
"this:"
msgstr ""
"L'ancien comportement peut être reproduit en forçant `.N` à s'appeler `.N`, "
"comme ceci :"

#: fr/datatable-faq.Rmd.tmp:block 199 (code)
#, fuzzy
msgid ""
"DT = data.table(a = c(1,1,2,2,2), b = c(1,2,2,2,1))\n"
"DT\n"
"DT[ , list(.N = .N), list(a, b)]   # show intermediate result for exposition\n"
"cat(try(\n"
"    DT[ , list(.N = .N), by = list(a, b)][ , unique(.N), by = a]   # compound "
"query more typical\n"
", silent = TRUE))\n"
msgstr ""
"DT = data.table(a = c(1,1,2,2,2), b = c(1,2,2,2,1))\n"
"DT\n"
"DT[ , list(.N = .N), list(a, b)] # montrer le résultat intermédiaire pour "
"l'exposition\n"
"cat(try(\n"
"    DT[ , list(.N = .N), by = list(a, b)][ , unique(.N), by = a] # composer "
"une requête plus typique\n"
", silent = TRUE))\n"

#: fr/datatable-faq.Rmd.tmp:block 200 (paragraph)
#, fuzzy
msgid ""
"If you are already running v1.8.1 or later then the error message is now more "
"helpful than the \"cannot change value of locked binding\" error, as you can "
"see above, since this vignette was produced using v1.8.1 or later."
msgstr ""
"Si vous utilisez déjà la version 1.8.1 ou une version ultérieure, le message "
"d'erreur est plus utile que l'erreur \"cannot change value of locked "
"binding\", comme vous pouvez le voir ci-dessus, puisque cette vignette a été "
"produite avec la version 1.8.1 ou une version ultérieure."

#: fr/datatable-faq.Rmd.tmp:block 201 (paragraph)
#, fuzzy
msgid "The more natural syntax now works:"
msgstr "La syntaxe plus naturelle fonctionne désormais :"

#: fr/datatable-faq.Rmd.tmp:block 202 (code)
#, fuzzy
msgid ""
"if (packageVersion(\"data.table\") >= \"1.8.1\") {\n"
"    DT[ , .N, by = list(a, b)][ , unique(N), by = a]\n"
"  }\n"
"if (packageVersion(\"data.table\") >= \"1.9.3\") {\n"
"    DT[ , .N, by = .(a, b)][ , unique(N), by = a]   # same\n"
"}\n"
msgstr ""
"if (packageVersion(\"data.table\") >= \"1.8.1\") {\n"
"    DT[ , .N, by = list(a, b)][ , unique(N), by = a]\n"
"  }\n"
"if (packageVersion(\"data.table\") >= \"1.9.3\") {\n"
"    DT[ , .N, by = .(a, b)][ , unique(N), by = a] # same\n"
"}\n"

#: fr/datatable-faq.Rmd.tmp:block 203 (header)
#, fuzzy
msgid "Warning messages"
msgstr "Messages d'avertissement"

#: fr/datatable-faq.Rmd.tmp:block 204 (header)
#, fuzzy
msgid ""
"\"The following object(s) are masked from `package:base`: `cbind`, `rbind`\""
msgstr ""
"\"Le(s) objet(s) suivant(s) est/sont masqué(s) dans `package:base` : `cbind`, "
"`rbind`\""

#: fr/datatable-faq.Rmd.tmp:block 205 (paragraph)
#, fuzzy
msgid ""
"This warning was present in v1.6.5 and v.1.6.6 only, when loading the "
"package. The motivation was to allow `cbind(DT, DF)` to work, but as it "
"transpired, this broke (full) compatibility with package `IRanges`. Please "
"upgrade to v1.6.7 or later."
msgstr ""
"Cet avertissement était présent dans les versions 1.6.5 et 1.6.6 uniquement, "
"lors du chargement du paquet. La motivation était de permettre à `cbind(DT, "
"DF)` de fonctionner, mais il s'est avéré que cela rompait la compatibilité "
"(totale) avec le paquet `IRanges`. Veuillez mettre à jour vers la version "
"1.6.7 ou ultérieure."

#: fr/datatable-faq.Rmd.tmp:block 206 (header)
#, fuzzy
msgid "\"Coerced numeric RHS to integer to match the column's type\""
msgstr ""
"\"Coerced numeric RHS to integer to match the column's type\" (Coercition de "
"l'élément numérique RHS en entier pour correspondre au type de la colonne)"

#: fr/datatable-faq.Rmd.tmp:block 207 (paragraph)
#, fuzzy
msgid "Hopefully, this is self explanatory. The full message is:"
msgstr ""
"J'espère que ce message s'explique de lui-même. Le message complet est le "
"suivant :"

#: fr/datatable-faq.Rmd.tmp:block 208 (paragraph)
#, fuzzy
msgid ""
"Coerced numeric RHS to integer to match the column's type; may have truncated "
"precision. Either change the column to numeric first by creating a new "
"numeric vector length 5 (nrows of entire table) yourself and assigning that "
"(i.e. 'replace' column), or coerce RHS to integer yourself (e.g. 1L or as."
"integer) to make your intent clear (and for speed). Or, set the column type "
"correctly up front when you create the table and stick to it, please."
msgstr ""
"RHS numérique coercé en entier pour correspondre au type de la colonne ; peut "
"avoir une précision tronquée. Vous pouvez soit changer la colonne en "
"numérique en créant vous-même un nouveau tableau numérique de longueur 5 "
"(nrows du tableau entier) et en l'assignant (c.-à-d. colonne \"replace\"), "
"soit forcer vous-même le RHS en entier (par ex. 1L ou as.integer) pour que "
"votre intention soit claire (et pour plus de rapidité). Ou encore, définissez "
"correctement le type de colonne dès la création de la table et respectez-le, "
"s'il vous plaît."

#: fr/datatable-faq.Rmd.tmp:block 209 (paragraph)
#, fuzzy
msgid "To generate it, try:"
msgstr "Pour le générer, essayez :"

#: fr/datatable-faq.Rmd.tmp:block 210 (code)
#, fuzzy
msgid ""
"DT = data.table(a = 1:5, b = 1:5)\n"
"suppressWarnings(\n"
"DT[2, b := 6]         # works (slower) with warning\n"
")\n"
"class(6)              # numeric not integer\n"
"DT[2, b := 7L]        # works (faster) without warning\n"
"class(7L)             # L makes it an integer\n"
"DT[ , b := rnorm(5)]  # 'replace' integer column with a numeric column\n"
msgstr ""
"DT = data.table(a = 1:5, b = 1:5)\n"
"suppressWarnings(\n"
"DT[2, b := 6] # fonctionne (plus lentement) avec l'avertissement\n"
")\n"
"class(6) # numérique pas entier\n"
"DT[2, b := 7L] # fonctionne (plus rapidement) sans avertissement\n"
"class(7L) # L en fait un entier\n"
"DT[ , b := rnorm(5)] # remplace la colonne entière par une colonne numérique\n"

#: fr/datatable-faq.Rmd.tmp:block 211 (header)
#, fuzzy
msgid "Reading data.table from RDS or RData file"
msgstr "Lecture de data.table à partir d'un fichier RDS ou RData"

#: fr/datatable-faq.Rmd.tmp:block 212 (paragraph)
#, fuzzy
msgid ""
"`*.RDS` and `*.RData` are file types which can store in-memory R objects on "
"disk efficiently. However, storing data.table into the binary file loses its "
"column over-allocation. This isn't a big deal -- your data.table will be "
"copied in memory on the next *by reference* operation and throw a warning. "
"Therefore it is recommended to call `setalloccol()` on each data.table loaded "
"with `readRDS()` or `load()` calls."
msgstr ""
"`*.RDS` et `*.RData` sont des types de fichiers qui permettent de stocker "
"efficacement des objets R en mémoire sur le disque. Cependant, le stockage de "
"data.table dans le fichier binaire perd sa sur-allocation de colonnes. Ce "
"n'est pas très grave -- votre data.table sera copié en mémoire lors de la "
"prochaine opération *by reference* et lancera un avertissement. Il est donc "
"recommandé d'appeler `setalloccol()` sur chaque data.table chargée avec les "
"appels `readRDS()` ou `load()`."

#: fr/datatable-faq.Rmd.tmp:block 213 (header)
#, fuzzy
msgid "General questions about the package"
msgstr "Questions générales sur le paquet"

#: fr/datatable-faq.Rmd.tmp:block 214 (header)
#, fuzzy
msgid "v1.3 appears to be missing from the CRAN archive?"
msgstr "la v1.3 semble être absente de l'archive CRAN ?"

#: fr/datatable-faq.Rmd.tmp:block 215 (paragraph)
#, fuzzy
msgid ""
"That is correct. v1.3 was available on R-Forge only. There were several large "
"changes internally and these took some time to test in development."
msgstr ""
"C'est exact. La version 1.3 n'était disponible que sur R-Forge. Il y a eu "
"plusieurs changements importants en interne et il a fallu du temps pour les "
"tester dans le cadre du développement."

#: fr/datatable-faq.Rmd.tmp:block 216 (header)
#, fuzzy
msgid "Is data.table compatible with S-plus?"
msgstr "Data.table est-il compatible avec S-plus ?"

#: fr/datatable-faq.Rmd.tmp:block 217 (paragraph)
#, fuzzy
msgid "Not currently."
msgstr "Pas actuellement."

#: fr/datatable-faq.Rmd.tmp:block 218 (paragraph)
#, fuzzy
msgid ""
"===== - A few core parts of the package are written in C and use internal R "
"functions and R structures.===== ===== - The package uses lexical scoping "
"which is one of the differences between R and **S-plus** explained by [R FAQ "
"3.3.1](https://cran.r-project.org/doc/FAQ/R-FAQ.html#Lexical-scoping)====="
msgstr ""
"===== - Quelques parties essentielles du paquetage sont écrites en C et "
"utilisent des fonctions R internes et des structures R.===== ===== - Le "
"paquetage utilise le cadrage lexical qui est l'une des différences entre R et "
"**S-plus** expliquée par [R FAQ 3.3.1](https://cran.r-project.org/doc/FAQ/R-"
"FAQ.html#Lexical-scoping)====="

#: fr/datatable-faq.Rmd.tmp:block 219 (header)
#, fuzzy
msgid "Is it available for Linux, Mac and Windows?"
msgstr "Est-il disponible pour Linux, Mac et Windows ?"

#: fr/datatable-faq.Rmd.tmp:block 220 (paragraph)
#, fuzzy
msgid ""
"Yes, for both 32-bit and 64-bit on all platforms. Thanks to CRAN. There are "
"no special or OS-specific libraries used."
msgstr ""
"Oui, à la fois pour 32-bit et 64-bit sur toutes les plateformes. Merci au "
"CRAN. Aucune bibliothèque spéciale ou spécifique au système d'exploitation "
"n'est utilisée."

#: fr/datatable-faq.Rmd.tmp:block 221 (header)
#, fuzzy
msgid "I think it's great. What can I do?"
msgstr "Je pense que c'est très bien. Qu'est-ce que je peux faire ?"

#: fr/datatable-faq.Rmd.tmp:block 222 (paragraph)
msgid ""
"Please file suggestions, bug reports and enhancement requests on our [issues "
"tracker](https://github.com/Rdatatable/data.table/issues). This helps make "
"the package better."
msgstr ""
"Veuillez déposer des suggestions, des rapports de bogues et des demandes "
"d'amélioration sur notre [gestionnaire de tickets (issues tracker)](https://"
"github.com/Rdatatable/data.table/issues). Cela permet d'améliorer le package."

#: fr/datatable-faq.Rmd.tmp:block 223 (paragraph)
#, fuzzy
msgid ""
"Please do star the package on [GitHub](https://github.com/Rdatatable/data."
"table/wiki). This helps encourage the developers and helps other R users find "
"the package."
msgstr ""
"Merci d'ajouter le paquet sur [GitHub](https://github.com/Rdatatable/data."
"table/wiki). Cela permet d'encourager les développeurs et d'aider les autres "
"utilisateurs de R à trouver le paquet."

#: fr/datatable-faq.Rmd.tmp:block 224 (paragraph)
#, fuzzy
msgid ""
"You can submit pull requests to change the code and/or documentation "
"yourself; see our [Contribution Guidelines](https://github.com/Rdatatable/"
"data.table/blob/master/.github/CONTRIBUTING.md)."
msgstr ""
"Vous pouvez soumettre des demandes d'extraction pour modifier le code et/ou "
"la documentation vous-même ; voir nos [Directives de contribution](https://"
"github.com/Rdatatable/data.table/blob/master/.github/CONTRIBUTING.md)."

#: fr/datatable-faq.Rmd.tmp:block 225 (header)
#, fuzzy
msgid "I think it's not great. How do I warn others about my experience?"
msgstr ""
"Je pense que ce n'est pas génial. Comment puis-je informer les autres de mon "
"expérience ?"

#: fr/datatable-faq.Rmd.tmp:block 226 (paragraph)
#, fuzzy
msgid ""
"We add all articles we know about (whether positive or negative) to the "
"[Articles](https://github.com/Rdatatable/data.table/wiki/Articles) page. All "
"pages in the project's wiki on GitHub are open-access with no modify "
"restrictions. Feel free to write an article, link to a negative one someone "
"else wrote that you found, or add a new page to our wiki to collect your "
"criticisms. Please make it constructive so we have a chance to improve."
msgstr ""
"Nous ajoutons tous les articles dont nous avons connaissance (qu'ils soient "
"positifs ou négatifs) à la page [Articles](https://github.com/Rdatatable/data."
"table/wiki/Articles). Toutes les pages du wiki du projet sur GitHub sont en "
"accès libre sans restriction de modification. N'hésitez pas à écrire un "
"article, à faire un lien vers un article négatif écrit par quelqu'un d'autre "
"que vous avez trouvé, ou à ajouter une nouvelle page à notre wiki pour "
"recueillir vos critiques. Veillez à ce qu'elles soient constructives afin que "
"nous ayons une chance de nous améliorer."

#: fr/datatable-faq.Rmd.tmp:block 227 (header)
#, fuzzy
msgid ""
"I have a question. I know the r-help posting guide tells me to contact the "
"maintainer (not r-help), but is there a larger group of people I can ask?"
msgstr ""
"J'ai une question à poser. Je sais que le guide d'affichage de r-help me dit "
"de contacter le mainteneur (pas r-help), mais y a-t-il un groupe plus large "
"de personnes à qui je peux demander ?"

#: fr/datatable-faq.Rmd.tmp:block 228 (paragraph)
#, fuzzy
msgid ""
"Please see the [support guide](https://github.com/Rdatatable/data.table/wiki/"
"Support) on the project's homepage which contains up-to-date links."
msgstr ""
"Veuillez consulter le [guide d'assistance](https://github.com/Rdatatable/data."
"table/wiki/Support) sur la page d'accueil du projet, qui contient des liens "
"actualisés."

#: fr/datatable-faq.Rmd.tmp:block 229 (header)
#, fuzzy
msgid "Where are the datatable-help archives?"
msgstr "Où sont les archives de datatable-help ?"

#: fr/datatable-faq.Rmd.tmp:block 230 (paragraph)
#, fuzzy
msgid ""
"The [homepage](https://github.com/Rdatatable/data.table/wiki) contains links "
"to the archives in several formats."
msgstr ""
"La [page d'accueil](https://github.com/Rdatatable/data.table/wiki) contient "
"des liens vers les archives en plusieurs formats."

#: fr/datatable-faq.Rmd.tmp:block 231 (header)
#, fuzzy
msgid ""
"I'd prefer not to post on the Issues page, can I mail just one or two people "
"privately?"
msgstr ""
"Je préférerais ne pas publier sur la page \"Questions\". Puis-je envoyer un "
"courrier privé à une ou deux personnes ?"

#: fr/datatable-faq.Rmd.tmp:block 232 (paragraph)
#, fuzzy
msgid ""
"Sure. You're more likely to get a faster answer from the Issues page or Stack "
"Overflow, though. Further, asking publicly in those places helps build the "
"general knowledge base."
msgstr ""
"Bien sûr, mais il est plus probable que vous obteniez une réponse plus rapide "
"sur la page Issues ou sur Stack Overflow. De plus, le fait de poser des "
"questions publiquement à ces endroits aide à construire la base de "
"connaissances générale."

#: fr/datatable-faq.Rmd.tmp:block 233 (header)
#, fuzzy
msgid ""
"I have created a package that uses data.table. How do I ensure my package is "
"data.table-aware so that inheritance from `data.frame` works?"
msgstr ""
"J'ai créé un package qui utilise data.table. Comment puis-je m'assurer que "
"mon paquetage est compatible avec data.table pour que l'héritage de `data."
"frame` fonctionne ?"

#: fr/datatable-faq.Rmd.tmp:block 234 (paragraph)
#, fuzzy
msgid "Please see [this answer](https://stackoverflow.com/a/10529888/403310)."
msgstr "Voir [cette réponse](https://stackoverflow.com/a/10529888/403310)."

#: fr/datatable-faq.Rmd.tmp:block 235 (code)
#, fuzzy
msgid ""
"#===== r, echo=FALSE\n"
"setDTthreads(.old.th)\n"
msgstr ""
"#===== r, echo=FALSE\n"
"setDTthreads(.old.th)\n"
