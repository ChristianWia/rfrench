#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: Christian Wiat <w9204-rs@yahoo.com>\n"
"Language-Team: \n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Poedit 3.4.4\n"

#: e:/datatable-sd-usage-fr.Rmd:block 3 (paragraph)
msgid ""
"This vignette will explain the most common ways to use the `.SD` variable "
"in your `data.table` analyses. It is an adaptation of [this answer](https://"
"stackoverflow.com/a/47406952/3576984) given on StackOverflow."
msgstr ""
"Cette vignette explique les manières habituelles d'utiliser la variable `."
"SD` dans vos analyses de `data.table` . C'est une adaptation ce [cette "
"réponse](https://stackoverflow.com/a/47406952/3576984) donnée sur "
"StackOverflow."

#: e:/datatable-sd-usage-fr.Rmd:block 4 (header)
msgid "What is `.SD`?"
msgstr "C'est quoi `.SD` ?"

#: e:/datatable-sd-usage-fr.Rmd:block 5 (paragraph)
msgid ""
"In the broadest sense, `.SD` is just shorthand for capturing a variable "
"that comes up frequently in the context of data analysis. It can be "
"understood to stand for *S*ubset, *S*elfsame, or *S*elf-reference of the "
"*D*ata. That is, `.SD` is in its most basic guise a *reflexive reference* "
"to the `data.table` itself -- as we'll see in examples below, this is "
"particularly helpful for chaining together \"queries\" (extractions/subsets/"
"etc using `[`). In particular, this also means that `.SD` is *itself a "
"`data.table`* (with the caveat that it does not allow assignment with `:=`)."
msgstr ""
"Au sens large, `.SD` est simplement un raccourci pour capturer une variable "
"qui apparait fréquemment dans le contexte de l'analyse de données. Il faut "
"comprendre *S* pour *S*ubset, *S*elfsame, ou *S*elf-reference et *D* pour "
"*D*onnée. Ce qui donne, `.SD` qui dans sa forme la plus basique est une "
"*référence réflexive* de la `data.table` elle-même -- comme nous le verrons "
"dans les exemples ci-dessous,  ceci est particulièrement utile pour chaîner "
"ensemble les \"requêtes\" (extractions/sous-ensembles/etc... en utilisant "
"`[`). E particulier cela signifie aussi que *`.SD` est lui-même une `data."
"table`* (avec la mise en garde qu'il ne peut être assigné avec `:=`)."

#: e:/datatable-sd-usage-fr.Rmd:block 6 (paragraph)
msgid ""
"The simpler usage of `.SD` is for column subsetting (i.e., when `.SDcols` "
"is specified); as this version is much more straightforward to understand, "
"we'll cover that first below. The interpretation of `.SD` in its second "
"usage, grouping scenarios (i.e., when `by = ` or `keyby = ` is specified), "
"is slightly different, conceptually (though at core it's the same, since, "
"after all, a non-grouped operation is an edge case of grouping with just "
"one group)."
msgstr ""
"L'utilisation la plus simple de `.SD` est pour le sous-ensemble de colonnes "
"(i.e., quand `.SDcols` est spécifié) ; comme cette version est beaucoup "
"plus simple à comprendre, nous allons la couvrir en premier ci-dessous. "
"L'interprétation de `.SD` dans sa seconde utilisation, les scénarios de "
"regroupement (i.e., quand `by = ` ou `keyby = ` est spécifié), est "
"légèrement différente, conceptuellement (bien qu'au fond ce soit la même "
"chose, puisque, après tout, une opération non regroupée est un cas limite "
"de regroupement avec un seul groupe)."

#: e:/datatable-sd-usage-fr.Rmd:block 7 (header)
msgid "Loading and Previewing Lahman Data"
msgstr "Charger et afficher les données Lahman"

#: e:/datatable-sd-usage-fr.Rmd:block 8 (paragraph)
msgid ""
"To give this a more real-world feel, rather than making up data, let's load "
"some data sets about baseball from the [Lahman database](https://github.com/"
"cdalzell/Lahman). In typical R usage, we'd simply load these data sets from "
"the `Lahman` R package; in this vignette, we've pre-downloaded them "
"directly from the package's GitHub page instead."
msgstr ""
"Pour donner une impression plus réaliste, plutôt que d'inventer des "
"données, chargeons quelques ensembles de données sur le baseball à partir "
"de la [base de données Lahman] (https://github.com/cdalzell/Lahman). Dans "
"une utilisation classique de R, nous chargerions simplement ces données "
"depuis le package R `Lahman` ; dans cette vignette, nous les avons pré-"
"chargées directement depuis la page GitHub du package."

#: e:/datatable-sd-usage-fr.Rmd:block 10 (paragraph)
msgid ""
"Readers up on baseball lingo should find the tables' contents familiar; "
"`Teams` records some statistics for a given team in a given year, while "
"`Pitching` records statistics for a given pitcher in a given year. Please "
"do check out the [documentation](https://github.com/cdalzell/Lahman) and "
"explore the data yourself a bit before proceeding to familiarize yourself "
"with their structure."
msgstr ""
"Les lecteurs qui connaissent le jargon du baseball devraient trouver le "
"contenu des tableaux familier ; `Teams` enregistre certaines statistiques "
"pour une équipe donnée au cours d'une année donnée, tandis que `Pitching` "
"enregistre les statistiques pour un lanceur donné au cours d'une année "
"donnée. N'hésitez pas à consulter la [documentation] (https://github.com/"
"cdalzell/Lahman) et à explorer les données vous-même avant de vous "
"familiariser avec leur structure."

#: e:/datatable-sd-usage-fr.Rmd:block 11 (header)
msgid "`.SD` on Ungrouped Data"
msgstr "`.SD` sur des données non groupées"

#: e:/datatable-sd-usage-fr.Rmd:block 12 (paragraph)
msgid ""
"To illustrate what I mean about the reflexive nature of `.SD`, consider its "
"most banal usage:"
msgstr ""
"Pour illustrer ce que l'on entend par nature réflexive de `.SD`, "
"considérons son utilisation la plus banale :"

#: e:/datatable-sd-usage-fr.Rmd:block 14 (paragraph)
msgid ""
"That is, `Pitching[ , .SD]` has simply returned the whole table, i.e., this "
"was an overly verbose way of writing `Pitching` or `Pitching[]`:"
msgstr ""
"C'est à dire que `Pitching[ , .SD]` a simplement renvoyé la table complète, "
"et c'est une manière exagérément verbeuse d'écrire `Pitching` ou "
"`Pitching[]`:"

#: e:/datatable-sd-usage-fr.Rmd:block 16 (paragraph)
msgid ""
"In terms of subsetting, `.SD` is still a subset of the data, it's just a "
"trivial one (the set itself)."
msgstr ""
"En terme de sous-groupe, `.SD` est un sous-groupe des données, le plus "
"évident (c'est l'ensemble lui-même)."

#: e:/datatable-sd-usage-fr.Rmd:block 17 (header)
msgid "Column Subsetting: `.SDcols`"
msgstr "Extraction de colonnes : `.SDcols`"

#: e:/datatable-sd-usage-fr.Rmd:block 18 (paragraph)
msgid ""
"The first way to impact what `.SD` is is to limit the *columns* contained "
"in `.SD` using the `.SDcols` argument to `[`:"
msgstr ""
"La première façon d'impacter ce que représente `.SD` c'est de limiter les "
"*colonnes* contenues dans `.SD` en utilisant l'argument `.SDcols` dans `[` :"

#: e:/datatable-sd-usage-fr.Rmd:block 20 (paragraph)
msgid ""
"This is just for illustration and was pretty boring. In addition to "
"accepting a character vector, `.SDcols` also accepts:"
msgstr ""
"Ceci ne sert que d'illustration et était très ennuyeux. En plus d'accepter "
"un vecteur de caractères `.SDcols` accepte également :"

#: e:/datatable-sd-usage-fr.Rmd:block 21 (ordered list)
msgid "any function such as `is.character` to filter *columns*"
msgstr "fonction quelconque comme `is.character` pour filtrer les *colonnes*"

#: e:/datatable-sd-usage-fr.Rmd:block 21 (ordered list)
msgid ""
"the function^{*} `patterns()` to filter *column names* by regular expression"
msgstr ""
"la fonction^*^ `patterns()` pour filtrer les *noms des colonnes* avec une "
"expression régulière"

#: e:/datatable-sd-usage-fr.Rmd:block 21 (ordered list)
msgid "integer and logical vectors"
msgstr "vecteurs d'entiers et de booléens"

#: e:/datatable-sd-usage-fr.Rmd:block 22 (paragraph)
msgid "*see `?patterns` for more details"
msgstr "*voir `?patterns` pour davantage de détails"

#: e:/datatable-sd-usage-fr.Rmd:block 23 (paragraph)
msgid ""
"This simple usage lends itself to a wide variety of highly beneficial / "
"ubiquitous data manipulation operations:"
msgstr ""
"Cette simple utilisation permet une large variété d'opérations avantageuses "
"ou équivalentes de manipulation des données :"

#: e:/datatable-sd-usage-fr.Rmd:block 24 (header)
msgid "Column Type Conversion"
msgstr "Convertir un type de colonne"

#: e:/datatable-sd-usage-fr.Rmd:block 25 (paragraph)
msgid ""
"Column type conversion is a fact of life for data munging. Though [`fwrite` "
"recently gained the ability to declare the class of each column up front]"
"(https://github.com/Rdatatable/data.table/pull/2545), not all data sets "
"come from `fread` (e.g. in this vignette) and conversions back and forth "
"among `character`/`factor`/`numeric` types are common. We can use `.SD` and "
"`.SDcols` to batch-convert groups of columns to a common type."
msgstr ""
"La conversion des types de colonnes est une opération routinière lors du "
"traitement des données. Bien que [`fwrite` ait récemment implémenté la "
"possibilité de déclarer la classe de chaque colonne en amont] (https://"
"github.com/Rdatatable/data.table/pull/2545), tous les jeux de données ne "
"proviennent pas de `fread` (par exemple dans cette vignette) et les "
"conversions entre les types `character`/`factor`/`numeric` sont courantes. "
"Nous pouvons utiliser `.SD` et `.SDcols` pour convertir par lots des "
"groupes de colonnes vers un type commun."

#: e:/datatable-sd-usage-fr.Rmd:block 26 (paragraph)
msgid ""
"We notice that the following columns are stored as `character` in the "
"`Teams` data set, but might more logically be stored as `factor`s:"
msgstr ""
"Remarquons que les colonnes suivantes sont rangées en tant que `character` "
"dans l'ensemble de données `Teams`, mais qu'elles pourraient "
"avantageusement être rangées comme `factor` :"

#: e:/datatable-sd-usage-fr.Rmd:block 28 (paragraph)
msgid "The syntax to now convert these columns to `factor` is simple:"
msgstr "La syntaxe pour convertir ces colonnes en `factor` est simple :"

#: e:/datatable-sd-usage-fr.Rmd:block 30 (paragraph)
msgid "Note:"
msgstr "Note :"

#: e:/datatable-sd-usage-fr.Rmd:block 31 (ordered list)
msgid ""
"The `:=` is an assignment operator to update the `data.table` in place "
"without making a copy. See [reference semantics](https://cran.r-project.org/"
"web/packages/data.table/vignettes/datatable-reference-semantics.html) for "
"more."
msgstr ""
"`:=` est un opérateur d'assignation pour mettre à jour la `data.table` "
"existante sans réaliser de copie. Voir les [sémantiques de référence]"
"(https://cran.r-project.org/web/packages/data.table/vignettes/datatable-"
"reference-semantics.html) pour plus d'informations."

#: e:/datatable-sd-usage-fr.Rmd:block 31 (ordered list)
msgid ""
"The LHS, `names(.SD)`, indicates which columns we are updating - in this "
"case we update the entire `.SD`."
msgstr ""
"Le membre de gauche, `names(.SD)`, indique les colonnes à mettre à jour - "
"dans ce cas il s'agit de tout le `.SD`."

#: e:/datatable-sd-usage-fr.Rmd:block 31 (ordered list)
msgid ""
"The RHS, `lapply()`, loops through each column of the `.SD` and converts "
"the column to a factor."
msgstr ""
"Le membre droit `lapply()`, boucle sur chaque colonne de `.SD` et convertit "
"la colonne en facteur."

#: e:/datatable-sd-usage-fr.Rmd:block 31 (ordered list)
msgid ""
"We use the `.SDcols` to only select columns that have pattern of `teamID`."
msgstr ""
"Nous utilisons `.SDcols` pour sélectionner uiquement les colonnes qui ont "
"pour modèle `teamID`."

#: e:/datatable-sd-usage-fr.Rmd:block 32 (paragraph)
msgid ""
"Again, the `.SDcols` argument is quite flexible; above, we supplied "
"`patterns` but we could have also supplied `fkt` or any `character` vector "
"of column names. In other situations, it is more convenient to supply an "
"`integer` vector of column *positions* or a `logical` vector dictating "
"include/exclude for each column. Finally, the use of a function to filter "
"columns is very helpful."
msgstr ""
"A nouveau, l'argument `.SDcols` est très souple ; nous avons fourni ci-"
"dessus `patterns` mais nous aurions pu passer également `fkt` ou tout "
"vecteur `character` de noms de colonnes. Dans d'autres situations, il est "
"plus pratique de fournir un vecteur `integer` de *positions* des colonnes "
"ou un vecteur de `booléens` indiquant pour chaque colonne s'il faut "
"l'inclure ou l'exclure. Finalement nous utilisons une fonction pour filtrer "
"les colonnes ce qui est très pratique."

#: e:/datatable-sd-usage-fr.Rmd:block 33 (paragraph)
msgid ""
"For example, we could do the following to convert all `factor` columns to "
"`character`:"
msgstr ""
"Par exemple nous pourrions faire ceci pour convertir toutes les colonnes "
"`factor` en `character` :"

#: e:/datatable-sd-usage-fr.Rmd:block 35 (paragraph)
msgid ""
"Lastly, we can do pattern-based matching of columns in `.SDcols` to select "
"all columns which contain `team` back to `factor`:"
msgstr ""
"Enfin, nous pouvons faire une correspondance basée sur les motifs des "
"colonnes dans `.SDcols` pour sélectionner toutes les colonnes qui "
"contiennent `team` vers `factor` :"

#: e:/datatable-sd-usage-fr.Rmd:block 37 (paragraph)
msgid ""
"** A proviso to the above: *explicitly* using column numbers (like `DT[ , "
"(1) := rnorm(.N)]`) is bad practice and can lead to silently corrupted code "
"over time if column positions change. Even implicitly using numbers can be "
"dangerous if we don't keep smart/strict control over the ordering of when "
"we create the numbered index and when we use it."
msgstr ""
"** Une réserve à ce qui précède : *l'utilisation explicite* de numéros de "
"colonnes (comme `DT[ , (1) := rnorm(.N)]`) est une mauvaise pratique et "
"peut conduire à un code corrompu sans aucun message d’avertissement au fil "
"du temps si les positions des colonnes changent. Même l'utilisation "
"implicite de nombres peut être dangereuse si nous ne gardons pas un "
"contrôle intelligent/strict sur l'ordre dans lequel nous créons l'index "
"numéroté et quand nous l'utilisons."

#: e:/datatable-sd-usage-fr.Rmd:block 38 (header)
msgid "Controlling a Model's Right-Hand Side"
msgstr "Contrôler le membre droit d'un modèle"

#: e:/datatable-sd-usage-fr.Rmd:block 39 (paragraph)
msgid ""
"Varying model specification is a core feature of robust statistical "
"analysis. Let's try and predict a pitcher's ERA (Earned Runs Average, a "
"measure of performance) using the small set of covariates available in the "
"`Pitching` table. How does the (linear) relationship between `W` (wins) and "
"`ERA` vary depending on which other covariates are included in the "
"specification?"
msgstr ""
"La variation de la spécification du modèle est une caractéristique "
"essentielle de l'analyse statistique robuste. Essayons de prédire l'ERA "
"(Earned Runs Average, une mesure de performance) d'un lanceur en utilisant "
"le petit ensemble de covariables disponibles dans le tableau `Pitching`. "
"Comment la relation (linéaire) entre `W` (victoires) et `ERA` varie-t-elle "
"en fonction des autres covariables incluses dans la spécification ?"

#: e:/datatable-sd-usage-fr.Rmd:block 40 (paragraph)
msgid ""
"Here's a short script leveraging the power of `.SD` which explores this "
"question:"
msgstr ""
"Voici une courte description qui évalue la puissance de `.SD` explorant "
"cette question :"

#: e:/datatable-sd-usage-fr.Rmd:block 42 (paragraph)
msgid ""
"The coefficient always has the expected sign (better pitchers tend to have "
"more wins and fewer runs allowed), but the magnitude can vary substantially "
"depending on what else we control for."
msgstr ""
"Le coefficient a toujours le signe attendu (les meilleurs lanceurs ont "
"tendance à avoir plus de victoires et moins de tours autorisés), mais "
"l'amplitude peut varier substantiellement en fonction de ce qui est "
"contrôlé par ailleurs."

#: e:/datatable-sd-usage-fr.Rmd:block 43 (header)
msgid "Conditional Joins"
msgstr "Jointures conditionnelles"

#: e:/datatable-sd-usage-fr.Rmd:block 44 (paragraph)
msgid ""
"`data.table` syntax is beautiful for its simplicity and robustness. The "
"syntax `x[i]` flexibly handles three common approaches to subsetting -- "
"when `i` is a `logical` vector, `x[i]` will return those rows of `x` "
"corresponding to where `i` is `TRUE`; when `i` is *another `data.table`* "
"(or a `list`), a (right) `join` is performed (in the plain form, using the "
"`key`s of `x` and `i`, otherwise, when `on = ` is specified, using matches "
"of those columns); and when `i` is a character, it is interpreted as "
"shorthand for `x[list(i)]`, i.e., as a join."
msgstr ""
"la syntaxe `data.table` est magnifique pour sa simplicité et sa robustesse. "
"La syntaxe `x[i]` gère de manière flexible trois approches communes du sous-"
"ensemble -- quand `i` est un vecteur `logique`, `x[i]` retournera les "
"lignes de `x` correspondant à l'endroit où `i` est `TRUE` ; quand `i` est "
"*un autre `data.table`* (ou une `liste`), une `jonction` (droite) est "
"effectuée (dans la forme normale, en utilisant les `clés` de `x` et `i`, "
"sinon, quand `on = ` est spécifié, en utilisant les correspondances de ces "
"colonnes) ; et quand `i` est un caractère, il est interprété comme un "
"raccourci pour `x[list(i)]`, c'est-à-dire..., comme une jointure."

#: e:/datatable-sd-usage-fr.Rmd:block 45 (paragraph)
msgid ""
"This is great in general, but falls short when we wish to perform a "
"*conditional join*, wherein the exact nature of the relationship among "
"tables depends on some characteristics of the rows in one or more columns."
msgstr ""
"C'est très bien en général, mais ce n'est pas suffisant lorsque nous "
"souhaitons effectuer une \"jointure conditionnelle\", dans laquelle la "
"nature exacte de la relation entre les tables dépend de certaines "
"caractéristiques des lignes dans une ou plusieurs colonnes."

#: e:/datatable-sd-usage-fr.Rmd:block 46 (paragraph)
msgid ""
"This example is admittedly a tad contrived, but illustrates the idea; see "
"here ([1](https://stackoverflow.com/questions/31329939/conditional-keyed-"
"join-update-and-update-a-flag-column-for-matches), [2](https://"
"stackoverflow.com/questions/29658627/conditional-binary-join-and-update-by-"
"reference-using-the-data-table-package)) for more."
msgstr ""
"Cet exemple est certes un peu artificiel, mais il illustre l'idée ; voir "
"ici ([1](https://stackoverflow.com/questions/31329939/conditional-keyed-"
"join-update-and-update-a-flag-column-for-matches), [2](https://"
"stackoverflow.com/questions/29658627/conditional-binary-join-and-update-by-"
"reference-using-the-data-table-package)) pour plus d'informations."

#: e:/datatable-sd-usage-fr.Rmd:block 47 (paragraph)
msgid ""
"The goal is to add a column `team_performance` to the `Pitching` table that "
"records the team's performance (rank) of the best pitcher on each team (as "
"measured by the lowest ERA, among pitchers with at least 6 recorded games)."
msgstr ""
"L'objectif est d'ajouter une colonne `team_performance` à la table "
"`Pitching` qui enregistre la performance de l'équipe (rang) du meilleur "
"lanceur de chaque équipe (mesurée par l'ERA la plus basse, parmi les "
"lanceurs ayant au moins 6 matchs enregistrés)."

#: e:/datatable-sd-usage-fr.Rmd:block 49 (paragraph)
msgid ""
"Note that the `x[y]` syntax returns `nrow(y)` values (i.e., it's a right "
"join), which is why `.SD` is on the right in `Teams[.SD]` (since the RHS of "
"`:=` in this case requires `nrow(Pitching[rank_in_team == 1])` values)."
msgstr ""
"Notez que la syntaxe `x[y]` renvoie des valeurs `nrow(y)` (c'est-à-dire "
"qu'il s'agit d'une jointure à droite), ce qui explique pourquoi `.SD` est à "
"droite dans `Teams[.SD]` (puisque le RHS de `:=` dans ce cas requiert des "
"valeurs `nrow(Pitching[rank_in_team == 1])`)."

#: e:/datatable-sd-usage-fr.Rmd:block 50 (header)
msgid "Grouped `.SD` operations"
msgstr "Opérations `.SD` groupées"

#: e:/datatable-sd-usage-fr.Rmd:block 51 (paragraph)
msgid ""
"Often, we'd like to perform some operation on our data *at the group "
"level*. When we specify `by =` (or `keyby = `), the mental model for what "
"happens when `data.table` processes `j` is to think of your `data.table` as "
"being split into many component sub-`data.table`s, each of which "
"corresponds to a single value of your `by` variable(s):"
msgstr ""
"Souvent, nous aimerions effectuer une opération sur nos données *au niveau "
"du groupe*. Quand nous spécifions `by =` (ou `keyby = `), le modèle mental "
"pour ce qui se passe quand `data.table` traite `j` est de penser à votre "
"`data.table` comme étant divisé en de nombreux composants sous `data."
"table`, chacun d'entre eux correspondant à une seule valeur de votre (vos) "
"variable(s) `by` :"

#: e:/datatable-sd-usage-fr.Rmd:block 52 (paragraph)
msgid "![Grouping, Illustrated](plots/grouping_illustration.png)"
msgstr "![Regroupement, illustré](../plots/grouping_illustration.png)"

#: e:/datatable-sd-usage-fr.Rmd:block 54 (paragraph)
msgid ""
"In the case of grouping, `.SD` is multiple in nature -- it refers to *each* "
"of these sub-`data.table`s, *one-at-a-time* (slightly more accurately, the "
"scope of `.SD` is a single sub-`data.table`). This allows us to concisely "
"express an operation that we'd like to perform on *each sub-`data.table`* "
"before the re-assembled result is returned to us."
msgstr ""
"Dans le cas du regroupement, `.SD` est multiple par nature -- il se réfère "
"à *chacun* de ces sous-`data.table`s, *un-à-la-fois* (un peu plus "
"précisément, la portée de `.SD` est une seule sous-`data.table`). Cela nous "
"permet d'exprimer de manière concise une opération que nous aimerions "
"effectuer sur *chaque sous-`data.table`* avant que le résultat ré-assemblé "
"ne nous soit retourné."

#: e:/datatable-sd-usage-fr.Rmd:block 55 (paragraph)
msgid ""
"This is useful in a variety of settings, the most common of which are "
"presented here:"
msgstr ""
"C'est utile pour diverses initialisations, les plus communes sont "
"présentées ici :"

#: e:/datatable-sd-usage-fr.Rmd:block 56 (header)
msgid "Group Subsetting"
msgstr "Sous-groupes"

#: e:/datatable-sd-usage-fr.Rmd:block 57 (paragraph)
msgid ""
"Let's get the most recent season of data for each team in the Lahman data. "
"This can be done quite simply with:"
msgstr ""
"Essayons d'obtenir la saison la plus récente des données pour chaque équipe "
"des données Lahman. Ceci peut être fait simplement avec :"

#: e:/datatable-sd-usage-fr.Rmd:block 59 (paragraph)
msgid ""
"Recall that `.SD` is itself a `data.table`, and that `.N` refers to the "
"total number of rows in a group (it's equal to `nrow(.SD)` within each "
"group), so `.SD[.N]` returns the *entirety of `.SD`* for the final row "
"associated with each `teamID`."
msgstr ""
"Rappelons que `.SD` est lui-même un `data.table`, et que `.N` fait "
"référence au nombre total de lignes dans un groupe (il est égal à `nrow(."
"SD)` dans chaque groupe), donc `.SD[.N]` retourne l'*entité de `.SD`* pour "
"la dernière ligne associée à chaque `teamID`."

#: e:/datatable-sd-usage-fr.Rmd:block 60 (paragraph)
msgid ""
"Another common version of this is to use `.SD[1L]` instead to get the "
"*first* observation for each group, or `.SD[sample(.N, 1L)]` to return a "
"*random* row for each group."
msgstr ""
"Une autre version commune de ceci est l'utilisation de `.SD[1L]` à la "
"place, pour obtenir la *première* observation de chaque groupe, ou `."
"SD[sample(.N, 1L)]` pour renvoyer une ligne *aléatoire* pour chaque groupe."

#: e:/datatable-sd-usage-fr.Rmd:block 61 (header)
msgid "Group Optima"
msgstr "Groupe Optima"

#: e:/datatable-sd-usage-fr.Rmd:block 62 (paragraph)
msgid ""
"Suppose we wanted to return the *best* year for each team, as measured by "
"their total number of runs scored (`R`; we could easily adjust this to "
"refer to other metrics, of course). Instead of taking a *fixed* element "
"from each sub-`data.table`, we now define the desired index *dynamically* "
"as follows:"
msgstr ""
"Supposons que nous voulions retourner la *meilleure* année pour chaque "
"équipe, mesurée par le nombre total de runs marqués (`R` ; nous pourrions "
"facilement ajuster ceci pour faire référence à d'autres métriques, bien "
"sûr). Au lieu de prendre un élément *fixe* de chaque sous-`data.table`, "
"nous définissons maintenant l'index désiré *dynamiquement* comme suit :"

#: e:/datatable-sd-usage-fr.Rmd:block 64 (paragraph)
msgid ""
"Note that this approach can of course be combined with `.SDcols` to return "
"only portions of the `data.table` for each `.SD` (with the caveat that `."
"SDcols` should be fixed across the various subsets)"
msgstr ""
"Notez que cette approche peut bien sûr être combinée avec `.SDcols` pour "
"renvoyer uniquement les portions de `data.table` pour chaque `.SD` (avec la "
"mise en garde que `.SDcols` soit initialisé en fonction des différents sous-"
"ensembles)"

#: e:/datatable-sd-usage-fr.Rmd:block 65 (paragraph)
msgid ""
"*NB*: `.SD[1L]` is currently optimized by [*`GForce`*](https://Rdatatable."
"gitlab.io/data.table/library/data.table/html/datatable-optimize.html) ([see "
"also](https://stackoverflow.com/questions/22137591/about-gforce-in-data-"
"table-1-9-2)), `data.table` internals which massively speed up the most "
"common grouped operations like `sum` or `mean` -- see `?GForce` for more "
"details and keep an eye on/voice support for feature improvement requests "
"for updates on this front: [1](https://github.com/Rdatatable/data.table/"
"issues/735), [2](https://github.com/Rdatatable/data.table/issues/2778), [3]"
"(https://github.com/Rdatatable/data.table/issues/523), [4](https://github."
"com/Rdatatable/data.table/issues/971), [5](https://github.com/Rdatatable/"
"data.table/issues/1197), [6](https://github.com/Rdatatable/data.table/"
"issues/1414)"
msgstr ""
"*NB* : `.SD[1L]` est actuellement optimisé par [*`GForce`*](https://"
"Rdatatable.gitlab.io/data.table/library/data.table/html/datatable-optimize."
"html) ([voir aussi](https://stackoverflow.com/questions/22137591/about-"
"gforce-in-data-table-1-9-2)), `data.table` interne qui accélère massivement "
"les opérations groupées les plus courantes comme `sum` ou `mean` -- voir ` ?"
"GForce` pour plus de détails et gardez un oeil sur le support pour les "
"demandes d'amélioration des fonctionnalités pour les mises à jour sur ce "
"front : [1](https://github.com/Rdatatable/data.table/issues/735), [2]"
"(https://github.com/Rdatatable/data.table/issues/2778), [3](https://github."
"com/Rdatatable/data.table/issues/523), [4](https://github.com/Rdatatable/"
"data.table/issues/971), [5](https://github.com/Rdatatable/data.table/"
"issues/1197), [6](https://github.com/Rdatatable/data.table/issues/1414)"

#: e:/datatable-sd-usage-fr.Rmd:block 66 (header)
msgid "Grouped Regression"
msgstr "Régression groupée"

#: e:/datatable-sd-usage-fr.Rmd:block 67 (paragraph)
msgid ""
"Returning to the inquiry above regarding the relationship between `ERA` and "
"`W`, suppose we expect this relationship to differ by team (i.e., there's a "
"different slope for each team). We can easily re-run this regression to "
"explore the heterogeneity in this relationship as follows (noting that the "
"standard errors from this approach are generally incorrect -- the "
"specification `ERA ~ W*teamID` will be better -- this approach is easier to "
"read and the *coefficients* are OK):"
msgstr ""
"Pour revenir à la question ci-dessus concernant la relation entre `ERA` et "
"`W`, supposons que nous nous attendions à ce que cette relation diffère "
"selon l'équipe (c'est-à-dire qu'il y ait une pente différente pour chaque "
"équipe). Nous pouvons facilement réexécuter cette régression pour explorer "
"l'hétérogénéité de cette relation comme suit (en notant que les erreurs "
"standard de cette approche sont généralement incorrectes - la spécification "
"`ERA ~ W*teamID` sera meilleure - cette approche est plus facile à lire et "
"les *coefficients* sont corrects) :"

#: e:/datatable-sd-usage-fr.Rmd:block 69 (paragraph)
msgid ""
"While there is indeed a fair amount of heterogeneity, there's a distinct "
"concentration around the observed overall value."
msgstr ""
"Tandis qu'il existe une grande hétérogénéité, la concentration autour de la "
"valeur générale observée reste très distincte."

#: e:/datatable-sd-usage-fr.Rmd:block 70 (paragraph)
msgid ""
"The above is just a short introduction of the power of `.SD` in "
"facilitating beautiful, efficient code in `data.table`!"
msgstr ""
"Tout ceci n'est simplement qu'une brève introduction sur la puissance de `."
"SD` qui facilite la beauté et l'efficacité du code dans `data.table` !"

#: fr/datatable-sd-usage.Rmd.tmp:block 1 (code)
msgid ""
"title: \"Using .SD for Data Analysis\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"  markdown::html_format:\n"
"    options:\n"
"      toc: true\n"
"      number_sections: true\n"
"    meta:\n"
"      css: [default, css/toc.css]\n"
"vignette: >\n"
"  %\\VignetteIndexEntry{Using .SD for Data Analysis}\n"
"  %\\VignetteEngine{knitr::knitr}\n"
"  \\usepackage[utf8]{inputenc}\n"
msgstr ""
"title: \"Utiliser .SD pour l’analyse de données\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"  markdown::html_format:\n"
"    options:\n"
"      toc: true\n"
"      number_sections: true\n"
"    meta:\n"
"      css: [default, ../css/toc.css]\n"
"vignette: >\n"
"  %\\VignetteIndexEntry{Utiliser .SD pour l’analyse de données}\n"
"  %\\VignetteEngine{knitr::knitr}\n"
"  \\usepackage[utf8]{inputenc}\n"

#: fr/datatable-sd-usage.Rmd.tmp:block 2 (code)
msgid ""
"# Chunk args: r, echo = FALSE, message = FALSE\n"
"require(data.table)\n"
"knitr::opts_chunk$set(\n"
"  comment = \"#\",\n"
"  error = FALSE,\n"
"  tidy = FALSE,\n"
"  cache = FALSE,\n"
"  collapse = TRUE,\n"
"  out.width = '100%',\n"
"  dpi = 144\n"
")\n"
".old.th = setDTthreads(1)\n"
msgstr ""
"# Chunk args: r, echo = FALSE, message = FALSE\n"
"require(data.table)\n"
"knitr::opts_chunk$set(\n"
"  comment = \"#\",\n"
"  error = FALSE,\n"
"  tidy = FALSE,\n"
"  cache = FALSE,\n"
"  collapse = TRUE,\n"
"  out.width = '100%',\n"
"  dpi = 144\n"
")\n"
".old.th = setDTthreads(1)\n"

#: fr/datatable-sd-usage.Rmd.tmp:block 9 (code)
msgid ""
"# Chunk args: r download_lahman\n"
"load('Teams.RData')\n"
"setDT(Teams)\n"
"Teams\n"
"\n"
"load('Pitching.RData')\n"
"setDT(Pitching)\n"
"Pitching\n"
msgstr ""
"# Chunk args: r download_lahman\n"
"load('../Teams.RData')\n"
"setDT(Teams)\n"
"Teams\n"
"\n"
"load('../Pitching.RData')\n"
"setDT(Pitching)\n"
"Pitching\n"

#: fr/datatable-sd-usage.Rmd.tmp:block 13 (code)
msgid ""
"# Chunk args: r plain_sd\n"
"Pitching[ , .SD]\n"
msgstr ""
"# Chunk args: r plain_sd\n"
"Pitching[ , .SD]\n"

#: fr/datatable-sd-usage.Rmd.tmp:block 15 (code)
msgid ""
"# Chunk args: r plain_sd_is_table\n"
"identical(Pitching, Pitching[ , .SD])\n"
msgstr ""
"# Chunk args: r plain_sd_is_table\n"
"identical(Pitching, Pitching[ , .SD])\n"

#: fr/datatable-sd-usage.Rmd.tmp:block 19 (code)
msgid ""
"# Chunk args: r simple_sdcols\n"
"# W: Wins; L: Losses; G: Games\n"
"Pitching[ , .SD, .SDcols = c('W', 'L', 'G')]\n"
msgstr ""
"# Chunk args: r simple_sdcols\n"
"# W: Wins; L: Losses; G: Games\n"
"Pitching[ , .SD, .SDcols = c('W', 'L', 'G')]\n"

#: fr/datatable-sd-usage.Rmd.tmp:block 27 (code)
msgid ""
"# Chunk args: r identify_factors\n"
"# teamIDBR: Team ID used by Baseball Reference website\n"
"# teamIDlahman45: Team ID used in Lahman database version 4.5\n"
"# teamIDretro: Team ID used by Retrosheet\n"
"fkt = c('teamIDBR', 'teamIDlahman45', 'teamIDretro')\n"
"# confirm that they're stored as `character`\n"
"str(Teams[ , ..fkt])\n"
msgstr ""
"# Chunk args: r identify_factors\n"
"# teamIDBR: identifiant du team utilisé par le site de référence du "
"Baseball\n"
"# teamIDlahman45: identifiant du team utilisé dans la base de données "
"Lahman version 4.5\n"
"# teamIDretro: identifiant du team utilisé par Retrosheet\n"
"fkt = c('teamIDBR', 'teamIDlahman45', 'teamIDretro')\n"
"# confirmation qu’ils sont enregistrés comme `character`\n"
"str(Teams[ , ..fkt])\n"

#: fr/datatable-sd-usage.Rmd.tmp:block 29 (code)
msgid ""
"# Chunk args: r assign_factors\n"
"Teams[ , names(.SD) := lapply(.SD, factor), .SDcols = patterns('teamID')]\n"
"# print out the first column to demonstrate success\n"
"head(unique(Teams[[fkt[1L]]]))\n"
msgstr ""
"# Chunk args: r assign_factors\n"
"Teams[ , names(.SD) := lapply(.SD, factor), .SDcols = patterns('teamID')]\n"
"# impression des premières colonnes pour montrer que c’est correct\n"
"head(unique(Teams[[fkt[1L]]]))\n"

#: fr/datatable-sd-usage.Rmd.tmp:block 34 (code)
msgid ""
"# Chunk args: r sd_as_logical\n"
"fct_idx = Teams[, which(sapply(.SD, is.factor))] # column numbers to show "
"the class changing\n"
"str(Teams[[fct_idx[1L]]])\n"
"Teams[ , names(.SD) := lapply(.SD, as.character), .SDcols = is.factor]\n"
"str(Teams[[fct_idx[1L]]])\n"
msgstr ""
"# Chunk args: r sd_as_logical\n"
"fct_idx = Teams[, which(sapply(.SD, is.factor))] # numéros de colonnes "
"montrant un changement de classe\n"
"str(Teams[[fct_idx[1L]]])\n"
"Teams[ , names(.SD) := lapply(.SD, as.character), .SDcols = is.factor]\n"
"str(Teams[[fct_idx[1L]]])\n"

#: fr/datatable-sd-usage.Rmd.tmp:block 36 (code)
msgid ""
"# Chunk args: r sd_patterns\n"
"Teams[ , .SD, .SDcols = patterns('team')]\n"
"Teams[ , names(.SD) := lapply(.SD, factor), .SDcols = patterns('team')]\n"
msgstr ""
"# Chunk args: r sd_patterns\n"
"Teams[ , .SD, .SDcols = patterns('team')]\n"
"Teams[ , names(.SD) := lapply(.SD, factor), .SDcols = patterns('team')]\n"

#: fr/datatable-sd-usage.Rmd.tmp:block 41 (code)
msgid ""
"# Chunk args: r sd_for_lm, cache = FALSE, fig.cap=\"Fit OLS coefficient on "
"W, various specifications, depicted as bars with distinct colors.\"\n"
"# this generates a list of the 2^k possible extra variables\n"
"#   for models of the form ERA ~ G + (...)\n"
"extra_var = c('yearID', 'teamID', 'G', 'L')\n"
"models = unlist(\n"
"  lapply(0L:length(extra_var), combn, x = extra_var, simplify = FALSE),\n"
"  recursive = FALSE\n"
")\n"
"\n"
"# here are 16 visually distinct colors, taken from the list of 20 here:\n"
"#   https://sashat.me/2017/01/11/list-of-20-simple-distinct-colors/\n"
"col16 = c('#e6194b', '#3cb44b', '#ffe119', '#0082c8',\n"
"          '#f58231', '#911eb4', '#46f0f0', '#f032e6',\n"
"          '#d2f53c', '#fabebe', '#008080', '#e6beff',\n"
"          '#aa6e28', '#fffac8', '#800000', '#aaffc3')\n"
"\n"
"par(oma = c(2, 0, 0, 0))\n"
"lm_coef = sapply(models, function(rhs) {\n"
"  # using ERA ~ . and data = .SD, then varying which\n"
"  #   columns are included in .SD allows us to perform this\n"
"  #   iteration over 16 models succinctly.\n"
"  #   coef(.)['W'] extracts the W coefficient from each model fit\n"
"  Pitching[ , coef(lm(ERA ~ ., data = .SD))['W'], .SDcols = c('W', rhs)]\n"
"})\n"
"barplot(lm_coef, names.arg = sapply(models, paste, collapse = '/'),\n"
"        main = 'Wins Coefficient\\nWith Various Covariates',\n"
"        col = col16, las = 2L, cex.names = 0.8)\n"
msgstr ""
"# Chunk args: r sd_for_lm, cache = FALSE, fig.cap=\"Ajustement OLS du "
"coefficient W, différentes spécifications, représentées sous forme de "
"barres de couleurs différentes.\"\n"
"# ceci génère une liste des 2^k variables extras\n"
"#   fpour des modèles du style ERA ~ G + (...)\n"
"extra_var = c('yearID', 'teamID', 'G', 'L')\n"
"models = unlist(\n"
"  lapply(0L:length(extra_var), combn, x = extra_var, simplify = FALSE),\n"
"  recursive = FALSE\n"
")\n"
"\n"
"# voici 16 couleurs visuellement distinctes choisies depuis une liste de 20 "
"ici:\n"
"#   https://sashat.me/2017/01/11/list-of-20-simple-distinct-colors/\n"
"col16 = c('#e6194b', '#3cb44b', '#ffe119', '#0082c8',\n"
"          '#f58231', '#911eb4', '#46f0f0', '#f032e6',\n"
"          '#d2f53c', '#fabebe', '#008080', '#e6beff',\n"
"          '#aa6e28', '#fffac8', '#800000', '#aaffc3')\n"
"\n"
"par(oma = c(2, 0, 0, 0))\n"
"lm_coef = sapply(models, function(rhs) {\n"
"  # utilisation de ERA ~ . and data = .SD, et puis variation de quelles\n"
"  #   colonnes sont incluses dans .SD nous permet de faire cette\n"
"  #   iteration sur 16 modèles de manière succincte.\n"
"  #   coef(.)['W'] extrait le coefficient W de chaque modèle\n"
"  Pitching[ , coef(lm(ERA ~ ., data = .SD))['W'], .SDcols = c('W', rhs)]\n"
"})\n"
"barplot(lm_coef, names.arg = sapply(models, paste, collapse = '/'),\n"
"        main = 'Wins Coefficient\\nWith Various Covariates',\n"
"        col = col16, las = 2L, cex.names = 0.8)\n"

#: fr/datatable-sd-usage.Rmd.tmp:block 48 (code)
msgid ""
"# Chunk args: r conditional_join\n"
"# to exclude pitchers with exceptional performance in a few games,\n"
"#   subset first; then define rank of pitchers within their team each year\n"
"#   (in general, we should put more care into the 'ties.method' of frank)\n"
"Pitching[G > 5, rank_in_team := frank(ERA), by = .(teamID, yearID)]\n"
"Pitching[rank_in_team == 1, team_performance :=\n"
"           Teams[.SD, Rank, on = c('teamID', 'yearID')]]\n"
msgstr ""
"# Chunk args: r conditional_join\n"
"# pour exclure les Pitchers ayant des performances exceptionnelles dans "
"quelques jeux,\n"
"#   créer un sous-ensemble ; ensuite définir le rang des Pitchers dans leur "
"équipe chaque\n"
"#   année (en général, nous devons nous focaliser aussi sur 'ties.method' "
"de frank)\n"
"Pitching[G > 5, rank_in_team := frank(ERA), by = .(teamID, yearID)]\n"
"Pitching[rank_in_team == 1, team_performance :=\n"
"           Teams[.SD, Rank, on = c('teamID', 'yearID')]]\n"

#: fr/datatable-sd-usage.Rmd.tmp:block 58 (code)
msgid ""
"# Chunk args: r group_sd_last\n"
"# the data is already sorted by year; if it weren't\n"
"#   we could do Teams[order(yearID), .SD[.N], by = teamID]\n"
"Teams[ , .SD[.N], by = teamID]\n"
msgstr ""
"# Chunk args: r group_sd_last\n"
"# les données sont déjà triées par année ; si elles ne l’étaient pas\n"
"#   nous pourrions faire Teams[order(yearID), .SD[.N], by = teamID]\n"
"Teams[ , .SD[.N], by = teamID]\n"

#: fr/datatable-sd-usage.Rmd.tmp:block 63 (code)
msgid ""
"# Chunk args: r sd_team_best_year\n"
"Teams[ , .SD[which.max(R)], by = teamID]\n"
msgstr ""
"# Chunk args: r sd_team_best_year\n"
"Teams[ , .SD[which.max(R)], by = teamID]\n"

#: fr/datatable-sd-usage.Rmd.tmp:block 68 (code)
msgid ""
"# Chunk args: r group_lm, results = 'hide', fig.cap=\"A histogram depicting "
"the distribution of fitted coefficients. It is vaguely bell-shaped and "
"concentrated around -.2\"\n"
"# Overall coefficient for comparison\n"
"overall_coef = Pitching[ , coef(lm(ERA ~ W))['W']]\n"
"# use the .N > 20 filter to exclude teams with few observations\n"
"Pitching[ , if (.N > 20L) .(w_coef = coef(lm(ERA ~ W))['W']), by = teamID\n"
"          ][ , hist(w_coef, 20L, las = 1L,\n"
"                    xlab = 'Fitted Coefficient on W',\n"
"                    ylab = 'Number of Teams', col = 'darkgreen',\n"
"                    main = 'Team-Level Distribution\\nWin Coefficients on "
"ERA')]\n"
"abline(v = overall_coef, lty = 2L, col = 'red')\n"
msgstr ""
"# Chunk args: r group_lm, results = 'hide', fig.cap=\"Histogramme de la "
"distribution des coefficients ajustés. It se rapproche d’une courbe en "
"cloche centrée autour de -.2\"\n"
"# Coefficients généraux pour comparaison\n"
"overall_coef = Pitching[ , coef(lm(ERA ~ W))['W']]\n"
"# utilisation d’un filtre .N > 20 pour exclure les équipes où il y a peu "
"d’observations\n"
"Pitching[ , if (.N > 20L) .(w_coef = coef(lm(ERA ~ W))['W']), by = teamID\n"
"          ][ , hist(w_coef, 20L, las = 1L,\n"
"                    xlab = 'Fitted Coefficient on W',\n"
"                    ylab = 'Number of Teams', col = 'darkgreen',\n"
"                    main = 'Team-Level Distribution\\nWin Coefficients on "
"ERA')]\n"
"abline(v = overall_coef, lty = 2L, col = 'red')\n"

#: fr/datatable-sd-usage.Rmd.tmp:block 71 (code)
msgid ""
"# Chunk args: r, echo=FALSE\n"
"setDTthreads(.old.th)\n"
msgstr ""
"# Chunk args: r, echo=FALSE\n"
"setDTthreads(.old.th)\n"
