#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.4.4\n"

#: fr/datatable-reshape.Rmd.tmp:block 1 (code)
msgid ""
"title: \"Efficient reshaping using data.tables\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"  markdown::html_format\n"
"vignette: >\n"
"  %\\VignetteIndexEntry{Efficient reshaping using data.tables}\n"
"  %\\VignetteEngine{knitr::knitr}\n"
"  \\usepackage[utf8]{inputenc}\n"
msgstr ""
"title: \"Remodelage efficace à l'aide de data.tables\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"  markdown::html_format\n"
"vignette: >\n"
"  %\\VignetteIndexEntry{Remodelage efficace à l’aide de data.tables}\n"
"  %\\VignetteEngine{knitr::knitr}\n"
"  \\usepackage[utf8]{inputenc}\n"

#: fr/datatable-reshape.Rmd.tmp:block 2 (code)
#, fuzzy
msgid ""
"#===== r, echo = FALSE, message = FALSE\n"
"require(data.table)\n"
"knitr::opts_chunk$set(\n"
"  comment = \"#\",\n"
"    error = FALSE,\n"
"     tidy = FALSE,\n"
"    cache = FALSE,\n"
" collapse = TRUE)\n"
".old.th = setDTthreads(1)\n"
msgstr ""
"#===== r, echo = FALSE, message = FALSE\n"
"require(data.table)\n"
"knitr::opts_chunk$set(\n"
"  comment = \"#\",\n"
"    error = FALSE,\n"
"     tidy = FALSE,\n"
"    cache = FALSE,\n"
" collapse = TRUE)\n"
".old.th = setDTthreads(1)\n"

#: fr/datatable-reshape.Rmd.tmp:block 3 (paragraph)
#, fuzzy
msgid ""
"This vignette discusses the default usage of reshaping functions `melt` "
"(wide to long) and `dcast` (long to wide) for *data.tables* as well as the "
"**new extended functionalities** of melting and casting on *multiple "
"columns* available from `v1.9.6`."
msgstr ""
"Cette vignette discute de l'utilisation par défaut des fonctions de "
"remodelage `melt` (large vers long) et `dcast` (long vers large) pour *data."
"tables* ainsi que des **nouvelles fonctionnalités étendues** de melting et "
"casting sur *multiple columns* disponibles à partir de `v1.9.6`."

#: fr/datatable-reshape.Rmd.tmp:block 4 (code)
#, fuzzy
msgid ""
"#===== r echo = FALSE\n"
"options(width = 100L)\n"
msgstr ""
"#===== r echo = FALSE\n"
"options(with = 100L)\n"

#: fr/datatable-reshape.Rmd.tmp:block 5 (header)
#, fuzzy
msgid "Data"
msgstr "Données"

#: fr/datatable-reshape.Rmd.tmp:block 6 (paragraph)
#, fuzzy
msgid "We will load the data sets directly within sections."
msgstr ""
"Nous chargerons les ensembles de données directement dans les sections."

#: fr/datatable-reshape.Rmd.tmp:block 7 (header)
#, fuzzy
msgid "Introduction"
msgstr "Introduction"

#: fr/datatable-reshape.Rmd.tmp:block 8 (paragraph)
#, fuzzy
msgid ""
"The `melt` and `dcast` functions for `data.table`s are for reshaping wide-"
"to-long and long-to-wide, respectively; the implementations are "
"specifically designed with large in-memory data (e.g. 10Gb) in mind."
msgstr ""
"Les fonctions `melt` et `dcast` pour `data.table` sont destinées au "
"remodelage de large en long et de long en large, respectivement ; les "
"implémentations sont spécifiquement conçues pour les données en mémoire de "
"grande taille (par exemple 10Gb)."

#: fr/datatable-reshape.Rmd.tmp:block 9 (paragraph)
#, fuzzy
msgid "In this vignette, we will"
msgstr "Dans cette vignette, nous allons"

#: fr/datatable-reshape.Rmd.tmp:block 10 (paragraph)
#, fuzzy
msgid ""
"=====1. First briefly look at the default `melt`ing and `dcast`ing of `data."
"table`s to convert them from *wide* to *long* format and *vice versa*====="
msgstr ""
"=====1. Tout d'abord, examinons brièvement la fusion et la diffusion par "
"défaut de `data.table` pour les convertir du format *large* au format "
"*long* et *vice versa*====="

#: fr/datatable-reshape.Rmd.tmp:block 11 (paragraph)
#, fuzzy
msgid ""
"=====2. Look at scenarios where the current functionalities become "
"cumbersome and inefficient====="
msgstr ""
"=====2. Examinez les scénarios dans lesquels les fonctionnalités actuelles "
"deviennent encombrantes et inefficaces====="

#: fr/datatable-reshape.Rmd.tmp:block 12 (paragraph)
#, fuzzy
msgid ""
"=====3. Finally look at the new improvements to both `melt` and `dcast` "
"methods for `data.table`s to handle multiple columns simultaneously.====="
msgstr ""
"=====3. Enfin, regardez les nouvelles améliorations apportées aux méthodes "
"`melt` et `dcast` pour `data.table`s afin de gérer plusieurs colonnes "
"simultanément.====="

#: fr/datatable-reshape.Rmd.tmp:block 13 (paragraph)
#, fuzzy
msgid ""
"The extended functionalities are in line with `data.table`'s philosophy of "
"performing operations efficiently and in a straightforward manner."
msgstr ""
"Les fonctionnalités étendues sont conformes à la philosophie de `data."
"table` qui consiste à effectuer des opérations de manière efficace et "
"simple."

#: fr/datatable-reshape.Rmd.tmp:block 14 (header)
#, fuzzy
msgid "1. Default functionality"
msgstr "1. Fonctionnalité par défaut"

#: fr/datatable-reshape.Rmd.tmp:block 15 (header)
#, fuzzy
msgid "a) `melt`ing `data.table`s (wide to long)"
msgstr ""
"a) la \"fusion\" des \"tables de données\" (de la plus large à la plus "
"longue)"

#: fr/datatable-reshape.Rmd.tmp:block 16 (paragraph)
#, fuzzy
msgid "Suppose we have a `data.table` (artificial data) as shown below:"
msgstr ""
"Supposons que nous ayons une `data.table` (données artificielles) comme "
"indiqué ci-dessous :"

#: fr/datatable-reshape.Rmd.tmp:block 17 (code)
msgid ""
"s1 <- \"family_id age_mother dob_child1 dob_child2 dob_child3\n"
"1         30 1998-11-26 2000-01-29         NA\n"
"2         27 1996-06-22         NA         NA\n"
"3         26 2002-07-11 2004-04-05 2007-09-02\n"
"4         32 2004-10-10 2009-08-27 2012-07-21\n"
"5         29 2000-12-05 2005-02-28         NA\"\n"
"DT <- fread(s1)\n"
"DT\n"
"## dob stands for date of birth.\n"
"\n"
"str(DT)\n"
msgstr ""
"s1 <- \"family_id age_mother dob_child1 dob_child2 dob_child3\n"
"1         30 1998-11-26 2000-01-29         NA\n"
"2         27 1996-06-22         NA         NA\n"
"3         26 2002-07-11 2004-04-05 2007-09-02\n"
"4         32 2004-10-10 2009-08-27 2012-07-21\n"
"5         29 2000-12-05 2005-02-28         NA\"\n"
"DT <- fread(s1)\n"
"DT\n"
"## dob signifie date de naissance.\n"
"\n"
"str(DT)\n"

#: fr/datatable-reshape.Rmd.tmp:block 18 (header)
#, fuzzy
msgid ""
"- Convert `DT` to *long* form where each `dob` is a separate observation."
msgstr ""
"- Convertir `DT` en une forme *longue* où chaque `dob` est une observation "
"séparée."

#: fr/datatable-reshape.Rmd.tmp:block 19 (paragraph)
#, fuzzy
msgid ""
"We could accomplish this using `melt()` by specifying `id.vars` and "
"`measure.vars` arguments as follows:"
msgstr ""
"Nous pouvons réaliser ceci en utilisant `melt()` en spécifiant les "
"arguments `id.vars` et `measure.vars` comme suit :"

#: fr/datatable-reshape.Rmd.tmp:block 20 (code)
#, fuzzy
msgid ""
"DT.m1 = melt(DT, id.vars = c(\"family_id\", \"age_mother\"),\n"
"                measure.vars = c(\"dob_child1\", \"dob_child2\", "
"\"dob_child3\"))\n"
"DT.m1\n"
"str(DT.m1)\n"
msgstr ""
"DT.m1 = melt(DT, id.vars = c(\"family_id\", \"age_mother\"),\n"
"                measure.vars = c(\"dob_child1\", \"dob_child2\", "
"\"dob_child3\"))\n"
"DT.m1\n"
"str(DT.m1)\n"

#: fr/datatable-reshape.Rmd.tmp:block 21 (paragraph)
#, fuzzy
msgid ""
"=====* `measure.vars` specify the set of columns we would like to collapse "
"(or combine) together.====="
msgstr ""
"=====* `measure.vars` spécifie l'ensemble des colonnes que nous souhaitons "
"comprimer (ou combiner).====="

#: fr/datatable-reshape.Rmd.tmp:block 22 (paragraph)
#, fuzzy
msgid "=====* We can also specify column *indices* instead of *names*.====="
msgstr ""
"=====* Nous pouvons également spécifier des *indices* de colonne au lieu de "
"*noms*.====="

#: fr/datatable-reshape.Rmd.tmp:block 23 (paragraph)
#, fuzzy
msgid ""
"=====* By default, `variable` column is of type `factor`. Set `variable."
"factor` argument to `FALSE` if you'd like to return a *`character`* vector "
"instead.====="
msgstr ""
"=====* Par défaut, la colonne `variable` est de type `facteur`. Mettez "
"l'argument `variable.factor` à `FALSE` si vous souhaitez retourner un "
"vecteur *`caractère`* à la place.====="

#: fr/datatable-reshape.Rmd.tmp:block 24 (paragraph)
#, fuzzy
msgid ""
"=====* By default, the molten columns are automatically named `variable` "
"and `value`.====="
msgstr ""
"=====* Par défaut, les colonnes fondues sont automatiquement nommées "
"`variable` et `valeur`.====="

#: fr/datatable-reshape.Rmd.tmp:block 25 (paragraph)
#, fuzzy
msgid "=====* `melt` preserves column attributes in result.====="
msgstr "=====* `melt` préserve les attributs des colonnes dans result.====="

#: fr/datatable-reshape.Rmd.tmp:block 26 (header)
#, fuzzy
msgid ""
"- Name the `variable` and `value` columns to `child` and `dob` respectively"
msgstr ""
"- Nommez les colonnes `variable` et `value` respectivement `child` et `dob`"

#: fr/datatable-reshape.Rmd.tmp:block 27 (code)
#, fuzzy
msgid ""
"DT.m1 = melt(DT, measure.vars = c(\"dob_child1\", \"dob_child2\", "
"\"dob_child3\"),\n"
"               variable.name = \"child\", value.name = \"dob\")\n"
"DT.m1\n"
msgstr ""
"DT.m1 = melt(DT, measure.vars = c(\"dob_child1\", \"dob_child2\", "
"\"dob_child3\"),\n"
"               variable.name = \"child\", value.name = \"dob\")\n"
"DT.m1\n"

#: fr/datatable-reshape.Rmd.tmp:block 28 (paragraph)
#, fuzzy
msgid ""
"=====* By default, when one of `id.vars` or `measure.vars` is missing, the "
"rest of the columns are *automatically assigned* to the missing argument."
"====="
msgstr ""
"=====* Par défaut, lorsque l'une des variables `id.vars` ou `measure.vars` "
"est manquante, les autres colonnes sont *automatiquement affectées* à "
"l'argument manquant.====="

#: fr/datatable-reshape.Rmd.tmp:block 29 (paragraph)
#, fuzzy
msgid ""
"=====* When neither `id.vars` nor `measure.vars` are specified, as "
"mentioned under `?melt`, all *non*-`numeric`, `integer`, `logical` columns "
"will be assigned to `id.vars`.====="
msgstr ""
"=====* Lorsque ni `id.vars` ni `measure.vars` ne sont spécifiés, comme "
"mentionné sous `?melt`, toutes les colonnes *non*-`numériques`, "
"`intégrales`, `logiques` seront assignées à `id.vars`.====="

#: fr/datatable-reshape.Rmd.tmp:block 30 (code)
#, fuzzy
msgid ""
"In addition, a warning message is issued highlighting the columns that are "
"automatically considered to be `id.vars`.\n"
msgstr ""
"De plus, un message d'avertissement est émis pour mettre en évidence les "
"colonnes qui sont automatiquement considérées comme des `id.vars`.\n"

#: fr/datatable-reshape.Rmd.tmp:block 31 (header)
#, fuzzy
msgid "b) `dcast`ing `data.table`s (long to wide)"
msgstr "b) `dcast`ing `data.table`s (long to wide)"

#: fr/datatable-reshape.Rmd.tmp:block 32 (paragraph)
#, fuzzy
msgid ""
"In the previous section, we saw how to get from wide form to long form. "
"Let's see the reverse operation in this section."
msgstr ""
"Dans la section précédente, nous avons vu comment passer de la forme large "
"à la forme longue. Dans cette section, nous verrons l'opération inverse."

#: fr/datatable-reshape.Rmd.tmp:block 33 (header)
#, fuzzy
msgid "- How can we get back to the original data table `DT` from `DT.m1`?"
msgstr ""
"- Comment revenir à la table de données originale `DT` à partir de `DT.m1` ?"

#: fr/datatable-reshape.Rmd.tmp:block 34 (paragraph)
#, fuzzy
msgid ""
"That is, we'd like to collect all *child* observations corresponding to "
"each `family_id, age_mother` together under the same row. We can accomplish "
"it using `dcast` as follows:"
msgstr ""
"En d'autres termes, nous aimerions rassembler toutes les observations "
"*enfants* correspondant à chaque `family_id, age_mother` dans la même "
"ligne. Nous pouvons le faire en utilisant `dcast` comme suit :"

#: fr/datatable-reshape.Rmd.tmp:block 35 (code)
#, fuzzy
msgid "dcast(DT.m1, family_id + age_mother ~ child, value.var = \"dob\")\n"
msgstr "dcast(DT.m1, family_id + age_mother ~ child, value.var = \"dob\")\n"

#: fr/datatable-reshape.Rmd.tmp:block 36 (paragraph)
#, fuzzy
msgid ""
"=====* `dcast` uses *formula* interface. The variables on the *LHS* of "
"formula represents the *id* vars and *RHS* the *measure* vars.====="
msgstr ""
"=====* `dcast` utilise l'interface *formule*. Les variables sur la *LHS* de "
"la formule représentent les vars *id* et *RHS* les vars *measure*.====="

#: fr/datatable-reshape.Rmd.tmp:block 37 (paragraph)
#, fuzzy
msgid ""
"=====* `value.var` denotes the column to be filled in with while casting to "
"wide format.====="
msgstr ""
"=====* `value.var` indique la colonne à remplir lors du passage au format "
"large.====="

#: fr/datatable-reshape.Rmd.tmp:block 38 (paragraph)
#, fuzzy
msgid ""
"=====* `dcast` also tries to preserve attributes in result wherever "
"possible.====="
msgstr ""
"=====* `dcast` essaie également de préserver les attributs du résultat dans "
"la mesure du possible.====="

#: fr/datatable-reshape.Rmd.tmp:block 39 (header)
#, fuzzy
msgid ""
"- Starting from `DT.m1`, how can we get the number of children in each "
"family?"
msgstr ""
"- A partir de `DT.m1`, comment obtenir le nombre d'enfants dans chaque "
"famille ?"

#: fr/datatable-reshape.Rmd.tmp:block 40 (paragraph)
#, fuzzy
msgid ""
"You can also pass a function to aggregate by in `dcast` with the argument "
"`fun.aggregate`. This is particularly essential when the formula provided "
"does not identify single observation for each cell."
msgstr ""
"Vous pouvez également passer une fonction à agréger dans `dcast` avec "
"l'argument `fun.aggregate`. Ceci est particulièrement utile lorsque la "
"formule fournie n'identifie pas une seule observation pour chaque cellule."

#: fr/datatable-reshape.Rmd.tmp:block 41 (code)
#, fuzzy
msgid ""
"dcast(DT.m1, family_id ~ ., fun.agg = function(x) sum(!is.na(x)), value.var "
"= \"dob\")\n"
msgstr ""
"dcast(DT.m1, family_id ~ ., fun.agg = function(x) sum(!is.na(x)), value.var "
"= \"dob\")\n"

#: fr/datatable-reshape.Rmd.tmp:block 42 (paragraph)
#, fuzzy
msgid "Check `?dcast` for other useful arguments and additional examples."
msgstr ""
"Consultez `?dcast` pour d'autres arguments utiles et des exemples "
"supplémentaires."

#: fr/datatable-reshape.Rmd.tmp:block 43 (header)
#, fuzzy
msgid "2. Limitations in current `melt/dcast` approaches"
msgstr "2. Limites des approches actuelles \"fonte/diffusion\""

#: fr/datatable-reshape.Rmd.tmp:block 44 (paragraph)
#, fuzzy
msgid ""
"So far we've seen features of `melt` and `dcast` that are implemented "
"efficiently for `data.table`s, using internal `data.table` machinery (*fast "
"radix ordering*, *binary search* etc.)."
msgstr ""
"Jusqu'à présent, nous avons vu des fonctionnalités de `melt` et `dcast` qui "
"sont implémentées efficacement pour les `data.table`, en utilisant la "
"machinerie interne de `data.table` (*ordonnancement radix rapide*, "
"*recherche binaire* etc...)."

#: fr/datatable-reshape.Rmd.tmp:block 45 (paragraph)
#, fuzzy
msgid ""
"However, there are situations we might run into where the desired operation "
"is not expressed in a straightforward manner. For example, consider the "
"`data.table` shown below:"
msgstr ""
"Cependant, il existe des situations où l'opération souhaitée n'est pas "
"exprimée de manière directe. Par exemple, considérons la table `data.table` "
"présentée ci-dessous :"

#: fr/datatable-reshape.Rmd.tmp:block 46 (code)
msgid ""
"s2 <- \"family_id age_mother dob_child1 dob_child2 dob_child3 gender_child1 "
"gender_child2 gender_child3\n"
"1         30 1998-11-26 2000-01-29         NA             1             "
"2            NA\n"
"2         27 1996-06-22         NA         NA             2            "
"NA            NA\n"
"3         26 2002-07-11 2004-04-05 2007-09-02             2             "
"2             1\n"
"4         32 2004-10-10 2009-08-27 2012-07-21             1             "
"1             1\n"
"5         29 2000-12-05 2005-02-28         NA             2             "
"1            NA\"\n"
"DT <- fread(s2)\n"
"DT\n"
"## 1 = female, 2 = male\n"
msgstr ""
"s2 <- \"family_id age_mother dob_child1 dob_child2 dob_child3 gender_child1 "
"gender_child2 gender_child3\n"
"1         30 1998-11-26 2000-01-29         NA             1             "
"2            NA\n"
"2         27 1996-06-22         NA         NA             2            "
"NA            NA\n"
"3         26 2002-07-11 2004-04-05 2007-09-02             2             "
"2             1\n"
"4         32 2004-10-10 2009-08-27 2012-07-21             1             "
"1             1\n"
"5         29 2000-12-05 2005-02-28         NA             2             "
"1            NA\"\n"
"DT <- fread(s2)\n"
"DT\n"
"\n"
"## 1 = femme, 2 = homme\n"

#: fr/datatable-reshape.Rmd.tmp:block 47 (paragraph)
#, fuzzy
msgid ""
"And you'd like to combine (`melt`) all the `dob` columns together, and "
"`gender` columns together. Using the current functionality, we can do "
"something like this:"
msgstr ""
"Et vous aimeriez combiner (`melt`) toutes les colonnes `dob` ensemble, et "
"`gender` ensemble. En utilisant la fonctionnalité actuelle, nous pouvons "
"faire quelque chose comme ceci :"

#: fr/datatable-reshape.Rmd.tmp:block 48 (code)
msgid ""
"DT.m1 = melt(DT, id = c(\"family_id\", \"age_mother\"))\n"
"DT.m1[, c(\"variable\", \"child\") := tstrsplit(variable, \"_\", fixed = "
"TRUE)]\n"
"DT.c1 = dcast(DT.m1, family_id + age_mother + child ~ variable, value.var = "
"\"value\")\n"
"DT.c1\n"
"\n"
"str(DT.c1) ## gender column is character type now!\n"
msgstr ""
"DT.m1 = melt(DT, id = c(\"family_id\", \"age_mother\"))\n"
"DT.m1[, c(\"variable\", \"child\") := tstrsplit(variable, \"_\", fixed = "
"TRUE)]\n"
"DT.c1 = dcast(DT.m1, family_id + age_mother + child ~ variable, value.var = "
"\"value\")\n"
"DT.c1\n"
"\n"
"str(DT.c1) ## la colonne 'gender' est un type de caractère maintenant !\n"

#: fr/datatable-reshape.Rmd.tmp:block 49 (header)
#, fuzzy
msgid "Issues"
msgstr "Problèmes"

#: fr/datatable-reshape.Rmd.tmp:block 50 (paragraph)
#, fuzzy
msgid ""
"=====1. What we wanted to do was to combine all the `dob` and `gender` type "
"columns together respectively. Instead, we are combining *everything* "
"together, and then splitting them again. I think it's easy to see that it's "
"quite roundabout (and inefficient).====="
msgstr ""
"=====1. Ce que nous voulions faire, c'était combiner toutes les colonnes de "
"type `dob` et `gender` respectivement. Au lieu de cela, nous combinons "
"*tout* ensemble, puis nous les séparons à nouveau. Je pense qu'il est "
"facile de voir que c'est assez détourné (et inefficace).====="

#: fr/datatable-reshape.Rmd.tmp:block 51 (code)
#, fuzzy
msgid ""
"As an analogy, imagine you've a closet with four shelves of clothes and "
"you'd like to put together the clothes from shelves 1 and 2 together (in "
"1), and 3 and 4 together (in 3). What we are doing is more or less to "
"combine all the clothes together, and then split them back on to shelves 1 "
"and 3!\n"
msgstr ""
"Par analogie, imaginez que vous avez un placard avec quatre étagères de "
"vêtements et que vous souhaitez rassembler les vêtements des étagères 1 et "
"2 (en 1), et 3 et 4 (en 3). Ce que nous faisons, c'est plus ou moins "
"combiner tous les vêtements ensemble, puis les répartir à nouveau sur les "
"étagères 1 et 3 !\n"

#: fr/datatable-reshape.Rmd.tmp:block 52 (paragraph)
#, fuzzy
msgid ""
"=====2. The columns to `melt` may be of different types, as in this case "
"(`character` and `integer` types). By `melt`ing them all together, the "
"columns will be coerced in result, as explained by the warning message "
"above and shown from output of `str(DT.c1)`, where `gender` has been "
"converted to *`character`* type.====="
msgstr ""
"=====2. Les colonnes à `fondre` peuvent être de types différents, comme "
"dans ce cas (types `character` et `integer`). En les \"fondant\" toutes "
"ensemble, les colonnes seront contraintes dans le résultat, comme "
"l'explique le message d'avertissement ci-dessus et comme le montre la "
"sortie de `str(DT.c1)`, où `gender` a été converti en type *`caractère`*."
"====="

#: fr/datatable-reshape.Rmd.tmp:block 53 (paragraph)
#, fuzzy
msgid ""
"=====3. We are generating an additional column by splitting the `variable` "
"column into two columns, whose purpose is quite cryptic. We do it because "
"we need it for *casting* in the next step.====="
msgstr ""
"=====3. Nous générons une colonne supplémentaire en divisant la colonne "
"`variable` en deux colonnes, dont le but est assez énigmatique. Nous le "
"faisons parce que nous en avons besoin pour la *casting* dans l'étape "
"suivante.====="

#: fr/datatable-reshape.Rmd.tmp:block 54 (paragraph)
#, fuzzy
msgid ""
"=====4. Finally, we cast the data set. But the issue is it's a much more "
"computationally involved operation than *melt*. Specifically, it requires "
"computing the order of the variables in formula, and that's costly.====="
msgstr ""
"=====4. Enfin, nous moulons l'ensemble des données. Mais le problème est "
"qu'il s'agit d'une opération beaucoup plus complexe sur le plan "
"informatique que *melt*. En particulier, il faut calculer l'ordre des "
"variables dans la formule, ce qui est coûteux.====="

#: fr/datatable-reshape.Rmd.tmp:block 55 (paragraph)
#, fuzzy
msgid ""
"In fact, `stats::reshape` is capable of performing this operation in a very "
"straightforward manner. It is an extremely useful and often underrated "
"function. You should definitely give it a try!"
msgstr ""
"En fait, `stats::reshape` est capable d'effectuer cette opération de "
"manière très simple. C'est une fonction extrêmement utile et souvent sous-"
"estimée. Vous devriez certainement l'essayer !"

#: fr/datatable-reshape.Rmd.tmp:block 56 (header)
#, fuzzy
msgid "3. Enhanced (new) functionality"
msgstr "3. Fonctionnalité améliorée (nouvelle)"

#: fr/datatable-reshape.Rmd.tmp:block 57 (header)
#, fuzzy
msgid "a) Enhanced `melt`"
msgstr "a) La \"fonte\" améliorée"

#: fr/datatable-reshape.Rmd.tmp:block 58 (paragraph)
#, fuzzy
msgid ""
"Since we'd like for `data.table`s to perform this operation straightforward "
"and efficient using the same interface, we went ahead and implemented an "
"*additional functionality*, where we can `melt` to multiple columns "
"*simultaneously*."
msgstr ""
"Puisque nous aimerions que `data.table`s effectue cette opération de façon "
"simple et efficace en utilisant la même interface, nous sommes allés de "
"l'avant et avons implémenté une *fonctionnalité additionnelle*, où nous "
"pouvons `fondre` sur plusieurs colonnes *simultanément*."

#: fr/datatable-reshape.Rmd.tmp:block 59 (header)
#, fuzzy
msgid "- `melt` multiple columns simultaneously"
msgstr "- faire fondre plusieurs colonnes simultanément"

#: fr/datatable-reshape.Rmd.tmp:block 60 (paragraph)
#, fuzzy
msgid ""
"The idea is quite simple. We pass a list of columns to `measure.vars`, "
"where each element of the list contains the columns that should be combined "
"together."
msgstr ""
"L'idée est assez simple. Nous passons une liste de colonnes à `measure."
"vars`, où chaque élément de la liste contient les colonnes qui doivent être "
"combinées ensemble."

#: fr/datatable-reshape.Rmd.tmp:block 61 (code)
#, fuzzy
msgid ""
"colA = paste0(\"dob_child\", 1:3)\n"
"colB = paste0(\"gender_child\", 1:3)\n"
"DT.m2 = melt(DT, measure = list(colA, colB), value.name = c(\"dob\", "
"\"gender\"))\n"
"DT.m2\n"
"\n"
"str(DT.m2) ## col type is preserved\n"
msgstr ""
"colA = paste0(\"dob_child\", 1:3)\n"
"colB = paste0(\"gender_child\", 1:3)\n"
"DT.m2 = melt(DT, measure = list(colA, colB), value.name = c(\"dob\", "
"\"gender\"))\n"
"DT.m2\n"
"\n"
"str(DT.m2) ## le type de col est préservé\n"

#: fr/datatable-reshape.Rmd.tmp:block 62 (paragraph)
#, fuzzy
msgid "=====* We can remove the `variable` column if necessary.====="
msgstr ""
"=====* Nous pouvons supprimer la colonne `variable` si nécessaire.====="

#: fr/datatable-reshape.Rmd.tmp:block 63 (paragraph)
#, fuzzy
msgid ""
"=====* The functionality is implemented entirely in C, and is therefore "
"both *fast* and *memory efficient* in addition to being *straightforward*."
"====="
msgstr ""
"=====* La fonctionnalité est entièrement mise en œuvre en C, et est donc à "
"la fois *rapide* et *mémoire efficace* en plus d'être *directe*.====="

#: fr/datatable-reshape.Rmd.tmp:block 64 (header)
#, fuzzy
msgid "- Using `patterns()`"
msgstr "- Utilisation de `patterns()`"

#: fr/datatable-reshape.Rmd.tmp:block 65 (paragraph)
#, fuzzy
msgid ""
"Usually in these problems, the columns we'd like to melt can be "
"distinguished by a common pattern. We can use the function `patterns()`, "
"implemented for convenience, to provide regular expressions for the columns "
"to be combined together. The above operation can be rewritten as:"
msgstr ""
"En général, dans ce genre de problème, les colonnes que l'on souhaite "
"fusionner peuvent être distinguées par un motif commun. Nous pouvons "
"utiliser la fonction `patterns()`, implémentée par commodité, pour fournir "
"des expressions régulières pour les colonnes à combiner ensemble. "
"L'opération ci-dessus peut être réécrite comme suit :"

#: fr/datatable-reshape.Rmd.tmp:block 66 (code)
#, fuzzy
msgid ""
"DT.m2 = melt(DT, measure = patterns(\"^dob\", \"^gender\"), value.name = "
"c(\"dob\", \"gender\"))\n"
"DT.m2\n"
msgstr ""
"DT.m2 = melt(DT, measure = patterns(\"^dob\", \"^gender\"), value.name = "
"c(\"dob\", \"gender\"))\n"
"DT.m2\n"

#: fr/datatable-reshape.Rmd.tmp:block 67 (header)
#, fuzzy
msgid "- Using `measure()` to specify `measure.vars` via separator or pattern"
msgstr ""
"- Utilisation de `measure()` pour spécifier `measure.vars` via un "
"séparateur ou un motif"

#: fr/datatable-reshape.Rmd.tmp:block 68 (paragraph)
#, fuzzy
msgid ""
"If, as in the data above, the input columns to melt have regular names, "
"then we can use `measure`, which allows specifying the columns to melt via "
"a separator or a regex. For example consider the iris data,"
msgstr ""
"Si, comme dans les données ci-dessus, les colonnes d'entrée à fondre ont "
"des noms réguliers, alors nous pouvons utiliser `measure`, qui permet de "
"spécifier les colonnes à fondre via un séparateur ou une regex. Par "
"exemple, considérons les données de l'iris,"

#: fr/datatable-reshape.Rmd.tmp:block 69 (code)
#, fuzzy
msgid "(two.iris = data.table(datasets::iris)[c(1,150)])\n"
msgstr "(two.iris = data.table(datasets::iris)[c(1,150)])\n"

#: fr/datatable-reshape.Rmd.tmp:block 70 (paragraph)
#, fuzzy
msgid ""
"The iris data has four numeric columns with a regular structure: first the "
"flower part, then a period, then the measurement dimension. To specify that "
"we want to melt those four columns, we can use `measure` with `sep=\".\"` "
"which means to use `strsplit` on all column names; the columns which result "
"in the maximum number of groups after splitting will be used as `measure."
"vars`:"
msgstr ""
"Les données de l'iris ont quatre colonnes numériques avec une structure "
"régulière : d'abord la partie de la fleur, puis une période, puis la "
"dimension de la mesure. Pour spécifier que nous voulons fondre ces quatre "
"colonnes, nous pouvons utiliser `measure` avec `sep=\".\"` ce qui signifie "
"utiliser `strsplit` sur tous les noms de colonnes ; les colonnes qui "
"résultent en un nombre maximum de groupes après division seront utilisées "
"comme `measure.vars` :"

#: fr/datatable-reshape.Rmd.tmp:block 71 (code)
#, fuzzy
msgid "melt(two.iris, measure.vars = measure(part, dim, sep=\".\"))\n"
msgstr "melt(two.iris, measure.vars = measure(part, dim, sep=\".\"))\n"

#: fr/datatable-reshape.Rmd.tmp:block 72 (paragraph)
#, fuzzy
msgid ""
"The first two arguments to `measure` in the code above (`part` and `dim`) "
"are used to name the output columns; the number of arguments must equal the "
"max number of groups after splitting with `sep`."
msgstr ""
"Les deux premiers arguments de `measure` dans le code ci-dessus (`part` et "
"`dim`) sont utilisés pour nommer les colonnes de sortie ; le nombre "
"d'arguments doit être égal au nombre maximum de groupes après division avec "
"`sep`."

#: fr/datatable-reshape.Rmd.tmp:block 73 (paragraph)
#, fuzzy
msgid ""
"If we want two value columns, one for each part, we can use the special "
"`value.name` keyword, which means to output a value column for each unique "
"name found in that group:"
msgstr ""
"Si nous voulons deux colonnes de valeurs, une pour chaque partie, nous "
"pouvons utiliser le mot-clé spécial `value.name`, ce qui signifie que nous "
"produisons une colonne de valeurs pour chaque nom unique trouvé dans ce "
"groupe :"

#: fr/datatable-reshape.Rmd.tmp:block 74 (code)
#, fuzzy
msgid "melt(two.iris, measure.vars = measure(value.name, dim, sep=\".\"))\n"
msgstr "melt(two.iris, measure.vars = measure(value.name, dim, sep=\".\"))\n"

#: fr/datatable-reshape.Rmd.tmp:block 75 (paragraph)
#, fuzzy
msgid ""
"Using the code above we get one value column per flower part. If we instead "
"want a value column for each measurement dimension, we can do"
msgstr ""
"En utilisant le code ci-dessus, nous obtenons une colonne de valeurs par "
"partie de fleur. Si nous voulons une colonne de valeurs pour chaque "
"dimension de mesure, nous pouvons procéder comme suit"

#: fr/datatable-reshape.Rmd.tmp:block 76 (code)
#, fuzzy
msgid "melt(two.iris, measure.vars = measure(part, value.name, sep=\".\"))\n"
msgstr "melt(two.iris, measure.vars = measure(part, value.name, sep=\".\"))\n"

#: fr/datatable-reshape.Rmd.tmp:block 77 (paragraph)
#, fuzzy
msgid ""
"Going back to the example of the data with families and children, we can "
"see a more complex usage of `measure`, involving a function which is used "
"to convert the `child` string values to integers:"
msgstr ""
"En revenant à l'exemple des données sur les familles et les enfants, nous "
"pouvons voir une utilisation plus complexe de `measure`, impliquant une "
"fonction qui est utilisée pour convertir les valeurs de la chaîne `child` "
"en nombres entiers :"

#: fr/datatable-reshape.Rmd.tmp:block 78 (code)
#, fuzzy
msgid ""
"DT.m3 = melt(DT, measure = measure(value.name, child=as.integer, "
"sep=\"_child\"))\n"
"DT.m3\n"
msgstr ""
"DT.m3 = melt(DT, measure = measure(value.name, child=as.integer, "
"sep=\"_child\"))\n"
"DT.m3\n"

#: fr/datatable-reshape.Rmd.tmp:block 79 (paragraph)
#, fuzzy
msgid ""
"In the code above we used `sep=\"_child\"` which results in melting only "
"the columns which contain that string (six column names split into two "
"groups each). The `child=as.integer` argument means the second group will "
"result in an output column named `child` with values defined by plugging "
"the character strings from that group into the function `as.integer`."
msgstr ""
"Dans le code ci-dessus, nous avons utilisé `sep=\"_child\"`, ce qui a pour "
"effet de faire fondre uniquement les colonnes qui contiennent cette chaîne "
"(six noms de colonnes divisés en deux groupes chacun). L'argument `child=as."
"integer` signifie que le second groupe donnera lieu à une colonne de sortie "
"nommée `child` avec des valeurs définies en insérant les chaînes de "
"caractères de ce groupe dans la fonction `as.integer`."

#: fr/datatable-reshape.Rmd.tmp:block 80 (paragraph)
#, fuzzy
msgid ""
"Finally we consider an example (borrowed from tidyr package) where we need "
"to define the groups using a regular expression rather than a separator."
msgstr ""
"Enfin, nous considérons un exemple (emprunté au paquet tidyr) dans lequel "
"nous devons définir les groupes en utilisant une expression régulière "
"plutôt qu'un séparateur."

#: fr/datatable-reshape.Rmd.tmp:block 81 (code)
msgid ""
"(who <- data.table(id=1, new_sp_m5564=2, newrel_f65=3))\n"
"melt(who, measure.vars = measure(\n"
"  diagnosis, gender, ages, pattern=\"new_?(.*)_(.)(.*)\"))\n"
msgstr ""
"(who <- data.table(id=1, new_sp_m5564=2, newrel_f65=3))\n"
"melt(who, measure.vars = measure(\n"
"  diagnosis, gender, ages, pattern=\"new_?(.*)_(.)(.*)\"))\n"

#: fr/datatable-reshape.Rmd.tmp:block 82 (paragraph)
#, fuzzy
msgid ""
"When using the `pattern` argument, it must be a Perl-compatible regular "
"expression containing the same number of capture groups (parenthesized sub-"
"expressions) as the number other arguments (group names). The code below "
"shows how to use a more complex regex with five groups, two numeric output "
"columns, and an anonymous type conversion function,"
msgstr ""
"Lorsque vous utilisez l'argument `pattern`, il doit s'agir d'une expression "
"rationnelle compatible avec Perl contenant le même nombre de groupes de "
"capture (sous-expressions entre parenthèses) que le nombre d'autres "
"arguments (noms de groupes). Le code ci-dessous montre comment utiliser une "
"expression rationnelle plus complexe avec cinq groupes, deux colonnes de "
"sortie numériques et une fonction de conversion de type anonyme,"

#: fr/datatable-reshape.Rmd.tmp:block 83 (code)
msgid ""
"melt(who, measure.vars = measure(\n"
"  diagnosis, gender, ages,\n"
"  ymin=as.numeric,\n"
"  ymax=function(y) ifelse(nzchar(y), as.numeric(y), Inf),\n"
"  pattern=\"new_?(.*)_(.)(([0-9]{2})([0-9]{0,2}))\"\n"
"))\n"
msgstr ""
"melt(who, measure.vars = measure(\n"
"  diagnosis, gender, age,\n"
"  ymin=as.numeric,\n"
"  ymax=function(y) ifelse(nzchar(y), as.numeric(y), Inf),\n"
"  pattern=\"new_?(.*)_(.)(([0-9]{2})([0-9]{0,2}))\"\n"
"))\n"

#: fr/datatable-reshape.Rmd.tmp:block 84 (header)
#, fuzzy
msgid "b) Enhanced `dcast`"
msgstr "b) Amélioration de la diffusion"

#: fr/datatable-reshape.Rmd.tmp:block 85 (paragraph)
#, fuzzy
msgid ""
"Okay great! We can now melt into multiple columns simultaneously. Now given "
"the data set `DT.m2` as shown above, how can we get back to the same format "
"as the original data we started with?"
msgstr ""
"D'accord, c'est génial ! Nous pouvons maintenant fusionner plusieurs "
"colonnes simultanément. Maintenant, étant donné l'ensemble de données `DT."
"m2` tel que montré ci-dessus, comment pouvons-nous revenir au même format "
"que les données originales avec lesquelles nous avons commencé ?"

#: fr/datatable-reshape.Rmd.tmp:block 86 (paragraph)
#, fuzzy
msgid ""
"If we use the current functionality of `dcast`, then we'd have to cast "
"twice and bind the results together. But that's once again verbose, not "
"straightforward and is also inefficient."
msgstr ""
"Si nous utilisons la fonctionnalité actuelle de `dcast`, alors nous "
"devrions faire deux castings et lier les résultats ensemble. Mais c'est une "
"fois de plus verbeux, pas simple et inefficace."

#: fr/datatable-reshape.Rmd.tmp:block 87 (header)
#, fuzzy
msgid "- Casting multiple `value.var`s simultaneously"
msgstr "- Casting de plusieurs `value.var`s simultanément"

#: fr/datatable-reshape.Rmd.tmp:block 88 (paragraph)
#, fuzzy
msgid ""
"We can now provide **multiple `value.var` columns** to `dcast` for `data."
"table`s directly so that the operations are taken care of internally and "
"efficiently."
msgstr ""
"Nous pouvons maintenant fournir **plusieurs colonnes `value.var`** à "
"`dcast` pour `data.table`s directement afin que les opérations soient "
"prises en charge de manière interne et efficace."

#: fr/datatable-reshape.Rmd.tmp:block 89 (code)
#, fuzzy
msgid ""
"## new 'cast' functionality - multiple value.vars\n"
"DT.c2 = dcast(DT.m2, family_id + age_mother ~ variable, value.var = "
"c(\"dob\", \"gender\"))\n"
"DT.c2\n"
msgstr ""
"## nouvelle fonctionnalité 'cast' - plusieurs value.vars\n"
"DT.c2 = dcast(DT.m2, family_id + age_mother ~ variable, value.var = "
"c(\"dob\", \"gender\"))\n"
"DT.c2\n"

#: fr/datatable-reshape.Rmd.tmp:block 90 (paragraph)
#, fuzzy
msgid "=====* Attributes are preserved in result wherever possible.====="
msgstr ""
"=====* Les attributs sont préservés dans le résultat dans la mesure du "
"possible.====="

#: fr/datatable-reshape.Rmd.tmp:block 91 (paragraph)
#, fuzzy
msgid ""
"=====* Everything is taken care of internally, and efficiently. In addition "
"to being fast, it is also very memory efficient.====="
msgstr ""
"=====* Tout est pris en charge de manière interne et efficace. En plus "
"d'être rapide, il est également très économe en mémoire.====="

#: fr/datatable-reshape.Rmd.tmp:block 93 (header)
#, fuzzy
msgid "Multiple functions to `fun.aggregate`:"
msgstr "Plusieurs fonctions pour `fun.aggregate` :"

#: fr/datatable-reshape.Rmd.tmp:block 94 (paragraph)
#, fuzzy
msgid ""
"You can also provide *multiple functions* to `fun.aggregate` to `dcast` for "
"*data.tables*. Check the examples in `?dcast` which illustrates this "
"functionality."
msgstr ""
"Vous pouvez également fournir des *fonctions multiples* à `fun.aggregate` à "
"`dcast` pour *data.tables*. Consultez les exemples dans `?dcast` qui "
"illustrent cette fonctionnalité."

#: fr/datatable-reshape.Rmd.tmp:block 95 (code)
#, fuzzy
msgid ""
"#===== r, echo=FALSE\n"
"setDTthreads(.old.th)\n"
msgstr ""
"#===== r, echo=FALSE\n"
"setDTthreads(.old.th)\n"
