---
title: "Remodelage efficace à l'aide de data.tables"
date: "`r Sys.Date()`"
output:
  markdown::html_format
vignette: >
  %\VignetteIndexEntry{Remodelage efficace à l’aide de data.tables}
  %\VignetteEngine{knitr::knitr}
  \usepackage[utf8]{inputenc}
---

```{r, echo = FALSE, message = FALSE}
require(data.table)
knitr::opts_chunk$set(
  comment = "#",
    error = FALSE,
     tidy = FALSE,
    cache = FALSE,
 collapse = TRUE)
.old.th = setDTthreads(1)
```

Cette vignette discute de l'utilisation par défaut des fonctions de remodelage `melt` (large vers long) et `dcast` (long vers large) pour *data.tables* ainsi que des **nouvelles fonctionnalités étendues** de melting et casting sur *multiple columns* disponibles à partir de `v1.9.6`.

***

```{r echo = FALSE}
options(with = 100L)
```

## Données

Nous chargerons les ensembles de données directement dans les sections.

## Introduction

Les fonctions `melt` et `dcast` pour `data.table` sont destinées au remodelage de large en long et de long en large, respectivement ; les implémentations sont spécifiquement conçues pour les données en mémoire de grande taille (par exemple 10Gb).

Dans cette vignette, nous allons

1. Tout d'abord, examinons brièvement la fusion et la diffusion par défaut de `data.table` pour les convertir du format *large* au format *long* et *vice versa*

2. Examinez les scénarios dans lesquels les fonctionnalités actuelles deviennent encombrantes et inefficaces

3. Enfin, regardez les nouvelles améliorations apportées aux méthodes `melt` et `dcast` pour `data.table`s afin de gérer plusieurs colonnes simultanément.

Les fonctionnalités étendues sont conformes à la philosophie de `data.table` qui consiste à effectuer des opérations de manière efficace et simple.

## 1. Fonctionnalité par défaut

### a) la "fusion" des "tables de données" (de la plus large à la plus longue)

Supposons que nous ayons une `data.table` (données artificielles) comme indiqué ci-dessous :

```{r}
s1 <- "family_id age_mother dob_child1 dob_child2 dob_child3
1         30 1998-11-26 2000-01-29         NA
2         27 1996-06-22         NA         NA
3         26 2002-07-11 2004-04-05 2007-09-02
4         32 2004-10-10 2009-08-27 2012-07-21
5         29 2000-12-05 2005-02-28         NA"
DT <- fread(s1)
DT
## dob signifie date de naissance.

str(DT)
```

#### - Convertir `DT` en une forme *longue* où chaque `dob` est une observation séparée.

Nous pouvons réaliser ceci en utilisant `melt()` en spécifiant les arguments `id.vars` et `measure.vars` comme suit :

```{r}
DT.m1 = melt(DT, id.vars = c("family_id", "age_mother"),
                measure.vars = c("dob_child1", "dob_child2", "dob_child3"))
DT.m1
str(DT.m1)
```

* `measure.vars` spécifie l'ensemble des colonnes que nous souhaitons comprimer (ou combiner).

* Nous pouvons également spécifier des *indices* de colonne au lieu de *noms*.

* Par défaut, la colonne `variable` est de type `facteur`. Mettez l'argument `variable.factor` à `FALSE` si vous souhaitez retourner un vecteur *`caractère`* à la place.

* Par défaut, les colonnes fondues sont automatiquement nommées `variable` et `valeur`.

* `melt` préserve les attributs des colonnes dans result.

#### - Nommez les colonnes `variable` et `value` respectivement `child` et `dob`

```{r}
DT.m1 = melt(DT, measure.vars = c("dob_child1", "dob_child2", "dob_child3"),
               variable.name = "child", value.name = "dob")
DT.m1
```

* Par défaut, lorsque l'une des variables `id.vars` ou `measure.vars` est manquante, les autres colonnes sont *automatiquement affectées* à l'argument manquant.

* Lorsque ni `id.vars` ni `measure.vars` ne sont spécifiés, comme mentionné sous `?melt`, toutes les colonnes *non*-`numériques`, `intégrales`, `logiques` seront assignées à `id.vars`.

    De plus, un message d'avertissement est émis pour mettre en évidence les colonnes qui sont automatiquement considérées comme des `id.vars`.

### b) `dcast`ing `data.table`s (long to wide)

Dans la section précédente, nous avons vu comment passer de la forme large à la forme longue. Dans cette section, nous verrons l'opération inverse.

#### - Comment revenir à la table de données originale `DT` à partir de `DT.m1` ?

En d'autres termes, nous aimerions rassembler toutes les observations *enfants* correspondant à chaque `family_id, age_mother` dans la même ligne. Nous pouvons le faire en utilisant `dcast` comme suit :

```{r}
dcast(DT.m1, family_id + age_mother ~ child, value.var = "dob")
```

* `dcast` utilise l'interface *formule*. Les variables sur la *LHS* de la formule représentent les vars *id* et *RHS* les vars *measure*.

* `value.var` indique la colonne à remplir lors du passage au format large.

* `dcast` essaie également de préserver les attributs du résultat dans la mesure du possible.

#### - A partir de `DT.m1`, comment obtenir le nombre d'enfants dans chaque famille ?

Vous pouvez également passer une fonction à agréger dans `dcast` avec l'argument `fun.aggregate`. Ceci est particulièrement utile lorsque la formule fournie n'identifie pas une seule observation pour chaque cellule.

```{r}
dcast(DT.m1, family_id ~ ., fun.agg = function(x) sum(!is.na(x)), value.var = "dob")
```

Consultez `?dcast` pour d'autres arguments utiles et des exemples supplémentaires.

## 2. Limites des approches actuelles "fonte/diffusion"

Jusqu'à présent, nous avons vu des fonctionnalités de `melt` et `dcast` qui sont implémentées efficacement pour les `data.table`, en utilisant la machinerie interne de `data.table` (*ordonnancement radix rapide*, *recherche binaire* etc...).

Cependant, il existe des situations où l'opération souhaitée n'est pas exprimée de manière directe. Par exemple, considérons la table `data.table` présentée ci-dessous :

```{r}
s2 <- "family_id age_mother dob_child1 dob_child2 dob_child3 gender_child1 gender_child2 gender_child3
1         30 1998-11-26 2000-01-29         NA             1             2            NA
2         27 1996-06-22         NA         NA             2            NA            NA
3         26 2002-07-11 2004-04-05 2007-09-02             2             2             1
4         32 2004-10-10 2009-08-27 2012-07-21             1             1             1
5         29 2000-12-05 2005-02-28         NA             2             1            NA"
DT <- fread(s2)
DT

## 1 = femme, 2 = homme
```

Et vous aimeriez combiner (`melt`) toutes les colonnes `dob` ensemble, et `gender` ensemble. En utilisant la fonctionnalité actuelle, nous pouvons faire quelque chose comme ceci :

```{r}
DT.m1 = melt(DT, id = c("family_id", "age_mother"))
DT.m1[, c("variable", "child") := tstrsplit(variable, "_", fixed = TRUE)]
DT.c1 = dcast(DT.m1, family_id + age_mother + child ~ variable, value.var = "value")
DT.c1

str(DT.c1) ## la colonne 'gender' est un type de caractère maintenant !
```

#### Problèmes

1. Ce que nous voulions faire, c'était combiner toutes les colonnes de type `dob` et `gender` respectivement. Au lieu de cela, nous combinons *tout* ensemble, puis nous les séparons à nouveau. Je pense qu'il est facile de voir que c'est assez détourné (et inefficace).

    Par analogie, imaginez que vous avez un placard avec quatre étagères de vêtements et que vous souhaitez rassembler les vêtements des étagères 1 et 2 (en 1), et 3 et 4 (en 3). Ce que nous faisons, c'est plus ou moins combiner tous les vêtements ensemble, puis les répartir à nouveau sur les étagères 1 et 3 !

2. Les colonnes à `fondre` peuvent être de types différents, comme dans ce cas (types `character` et `integer`). En les "fondant" toutes ensemble, les colonnes seront contraintes dans le résultat, comme l'explique le message d'avertissement ci-dessus et comme le montre la sortie de `str(DT.c1)`, où `gender` a été converti en type *`caractère`*.

3. Nous générons une colonne supplémentaire en divisant la colonne `variable` en deux colonnes, dont le but est assez énigmatique. Nous le faisons parce que nous en avons besoin pour la *casting* dans l'étape suivante.

4. Enfin, nous moulons l'ensemble des données. Mais le problème est qu'il s'agit d'une opération beaucoup plus complexe sur le plan informatique que *melt*. En particulier, il faut calculer l'ordre des variables dans la formule, ce qui est coûteux.

En fait, `stats::reshape` est capable d'effectuer cette opération de manière très simple. C'est une fonction extrêmement utile et souvent sous-estimée. Vous devriez certainement l'essayer !

## 3. Fonctionnalité améliorée (nouvelle)

### a) La "fonte" améliorée

Puisque nous aimerions que `data.table`s effectue cette opération de façon simple et efficace en utilisant la même interface, nous sommes allés de l'avant et avons implémenté une *fonctionnalité additionnelle*, où nous pouvons `fondre` sur plusieurs colonnes *simultanément*.

#### - faire fondre plusieurs colonnes simultanément

L'idée est assez simple. Nous passons une liste de colonnes à `measure.vars`, où chaque élément de la liste contient les colonnes qui doivent être combinées ensemble.

```{r}
colA = paste0("dob_child", 1:3)
colB = paste0("gender_child", 1:3)
DT.m2 = melt(DT, measure = list(colA, colB), value.name = c("dob", "gender"))
DT.m2

str(DT.m2) ## le type de col est préservé
```

* Nous pouvons supprimer la colonne `variable` si nécessaire.

* La fonctionnalité est entièrement mise en œuvre en C, et est donc à la fois *rapide* et *mémoire efficace* en plus d'être *directe*.

#### - Utilisation de `patterns()`

En général, dans ce genre de problème, les colonnes que l'on souhaite fusionner peuvent être distinguées par un motif commun. Nous pouvons utiliser la fonction `patterns()`, implémentée par commodité, pour fournir des expressions régulières pour les colonnes à combiner ensemble. L'opération ci-dessus peut être réécrite comme suit :

```{r}
DT.m2 = melt(DT, measure = patterns("^dob", "^gender"), value.name = c("dob", "gender"))
DT.m2
```

#### - Utilisation de `measure()` pour spécifier `measure.vars` via un séparateur ou un motif

Si, comme dans les données ci-dessus, les colonnes d'entrée à fondre ont des noms réguliers, alors nous pouvons utiliser `measure`, qui permet de spécifier les colonnes à fondre via un séparateur ou une regex. Par exemple, considérons les données de l'iris,

```{r}
(two.iris = data.table(datasets::iris)[c(1,150)])
```

Les données de l'iris ont quatre colonnes numériques avec une structure régulière : d'abord la partie de la fleur, puis une période, puis la dimension de la mesure. Pour spécifier que nous voulons fondre ces quatre colonnes, nous pouvons utiliser `measure` avec `sep="."` ce qui signifie utiliser `strsplit` sur tous les noms de colonnes ; les colonnes qui résultent en un nombre maximum de groupes après division seront utilisées comme `measure.vars` :

```{r}
melt(two.iris, measure.vars = measure(part, dim, sep="."))
```

Les deux premiers arguments de `measure` dans le code ci-dessus (`part` et `dim`) sont utilisés pour nommer les colonnes de sortie ; le nombre d'arguments doit être égal au nombre maximum de groupes après division avec `sep`.

Si nous voulons deux colonnes de valeurs, une pour chaque partie, nous pouvons utiliser le mot-clé spécial `value.name`, ce qui signifie que nous produisons une colonne de valeurs pour chaque nom unique trouvé dans ce groupe :

```{r}
melt(two.iris, measure.vars = measure(value.name, dim, sep="."))
```

En utilisant le code ci-dessus, nous obtenons une colonne de valeurs par partie de fleur. Si nous voulons une colonne de valeurs pour chaque dimension de mesure, nous pouvons procéder comme suit

```{r}
melt(two.iris, measure.vars = measure(part, value.name, sep="."))
```

En revenant à l'exemple des données sur les familles et les enfants, nous pouvons voir une utilisation plus complexe de `measure`, impliquant une fonction qui est utilisée pour convertir les valeurs de la chaîne `child` en nombres entiers :

```{r}
DT.m3 = melt(DT, measure = measure(value.name, child=as.integer, sep="_child"))
DT.m3
```

Dans le code ci-dessus, nous avons utilisé `sep="_child"`, ce qui a pour effet de faire fondre uniquement les colonnes qui contiennent cette chaîne (six noms de colonnes divisés en deux groupes chacun). L'argument `child=as.integer` signifie que le second groupe donnera lieu à une colonne de sortie nommée `child` avec des valeurs définies en insérant les chaînes de caractères de ce groupe dans la fonction `as.integer`.

Enfin, nous considérons un exemple (emprunté au paquet tidyr) dans lequel nous devons définir les groupes en utilisant une expression régulière plutôt qu'un séparateur.

```{r}
(who <- data.table(id=1, new_sp_m5564=2, newrel_f65=3))
melt(who, measure.vars = measure(
  diagnosis, gender, ages, pattern="new_?(.*)_(.)(.*)"))
```

Lorsque vous utilisez l'argument `pattern`, il doit s'agir d'une expression rationnelle compatible avec Perl contenant le même nombre de groupes de capture (sous-expressions entre parenthèses) que le nombre d'autres arguments (noms de groupes). Le code ci-dessous montre comment utiliser une expression rationnelle plus complexe avec cinq groupes, deux colonnes de sortie numériques et une fonction de conversion de type anonyme,

```{r}
melt(who, measure.vars = measure(
  diagnosis, gender, age,
  ymin=as.numeric,
  ymax=function(y) ifelse(nzchar(y), as.numeric(y), Inf),
  pattern="new_?(.*)_(.)(([0-9]{2})([0-9]{0,2}))"
))
```

### b) Amélioration de la diffusion

D'accord, c'est génial ! Nous pouvons maintenant fusionner plusieurs colonnes simultanément. Maintenant, étant donné l'ensemble de données `DT.m2` tel que montré ci-dessus, comment pouvons-nous revenir au même format que les données originales avec lesquelles nous avons commencé ?

Si nous utilisons la fonctionnalité actuelle de `dcast`, alors nous devrions faire deux castings et lier les résultats ensemble. Mais c'est une fois de plus verbeux, pas simple et inefficace.

#### - Casting de plusieurs `value.var`s simultanément

Nous pouvons maintenant fournir **plusieurs colonnes `value.var`** à `dcast` pour `data.table`s directement afin que les opérations soient prises en charge de manière interne et efficace.

```{r}
## nouvelle fonctionnalité 'cast' - plusieurs value.vars
DT.c2 = dcast(DT.m2, family_id + age_mother ~ variable, value.var = c("dob", "gender"))
DT.c2
```

* Les attributs sont préservés dans le résultat dans la mesure du possible.

* Tout est pris en charge de manière interne et efficace. En plus d'être rapide, il est également très économe en mémoire.

# 

#### Plusieurs fonctions pour `fun.aggregate` :

Vous pouvez également fournir des *fonctions multiples* à `fun.aggregate` à `dcast` pour *data.tables*. Consultez les exemples dans `?dcast` qui illustrent cette fonctionnalité.

```{r, echo=FALSE}
setDTthreads(.old.th)
```

# 

***
