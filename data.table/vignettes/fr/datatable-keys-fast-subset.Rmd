---
title: "Sous-ensemble basé sur les clés et la recherche binaire rapide"
date: "`r Sys.Date()`"
output:
  markdown::html_format
vignette: >
  %\VignetteIndexEntry{Sous-ensemble basé sur les clés et la recherche binaire rapide}
  %\VignetteEngine{knitr::knitr}
  \usepackage[utf8]{inputenc}
---

```{r, echo = FALSE, message = FALSE}
require(data.table)
knitr::opts_chunk$set(
  comment = "#",
    error = FALSE,
     tidy = FALSE,
    cache = FALSE,
 collapse = TRUE)
.old.th = setDTthreads(1)
```

Cette vignette est destinée à ceux qui sont déjà familiers avec la syntaxe de *data.table*, sa forme générale, la façon de sous-ensembler des lignes dans `i`, sélectionner et calculer sur des colonnes, ajouter/modifier/supprimer des colonnes *par référence* dans `j` et grouper en utilisant `by`. Si vous n'êtes pas familier avec ces concepts, veuillez d'abord lire les vignettes *"Introduction à data.table "* et *"Sémantique de référence "*.

***

## Données {#data}

Nous utiliserons les mêmes données `flights` que dans la vignette *"Introduction à data.table"*.

```{r echo = FALSE}
options(with = 100L)
```

```{r}
flights <- fread("../flights14.csv")
head(flights)
dim(flights)
```

## Introduction

Dans cette vignette, nous allons

* introduit d'abord le concept de "clé" dans *data.table*, et définit et utilise des clés pour effectuer une *recherche binaire rapide* basée sur des sous-ensembles dans `i`,

* voyez que nous pouvons combiner des sous-ensembles basés sur des clés avec `j` et `by` exactement de la même manière que précédemment,

* consultez d'autres arguments utiles - `mult` et `nomatch`,

* et enfin conclure en examinant l'avantage de définir des clés - effectuer des *sous-ensembles basés sur la recherche binaire rapide* et comparer avec l'approche traditionnelle du balayage vectoriel.

## 1. Clés

### a) Qu'est-ce qu'une *clé* ?

Dans la vignette *"Introduction à data.table "*, nous avons vu comment sous-diviser des lignes dans `i` en utilisant des expressions logiques, des numéros de lignes et en utilisant `order()`. Dans cette section, nous allons voir une autre façon de faire des sous-ensembles incroyablement rapides - en utilisant des *clés*.

Mais tout d'abord, commençons par examiner les *data.frames*. Tous les *data.frames* ont un attribut row names. Considérons le *data.frame* `DF` ci-dessous.

```{r}
set.seed(1L)
DF = data.frame(ID1 = sample(letters[1:2], 10, TRUE),
                ID2 = sample(1:3, 10, TRUE),
                val = sample(10),
                stringsAsFactors = FALSE,
                row.names = sample(LETTERS[1:10]))
DF

rownames(DF)
```

Nous pouvons *sous-ensemble* une ligne particulière en utilisant son nom de ligne comme indiqué ci-dessous :

```{r}
DF["C", ]
```

c'est-à-dire que les noms de lignes sont plus ou moins *un index* des lignes d'un *data.frame*. Cependant,

1. Chaque ligne est limitée à *exactement* un nom de ligne.

    Mais une personne (par exemple) a au moins deux noms - un *prénom* et un *second* nom. Il est utile d'organiser un annuaire téléphonique par *nom* puis *prénom*.

2. Et les noms de ligne doivent être *uniques*.

    ```{r eval = FALSE}
    rownames(DF) = sample(LETTERS[1:5], 10, TRUE)
    # Warning : non-unique values when setting 'row.names' : 'C', 'D'
    # Erreur dans `.rowNamesDF<-`(x, value = value) : les 'row.names' dupliqués ne sont pas autorisés
    ```

Nous allons maintenant le convertir en *data.table*.

```{r}
DT = as.data.table(DF)
DT

rownames(DT)
```

* Notez que les noms des lignes ont été réinitialisés.

* *data.tables* n'utilise jamais de noms de ligne. Puisque *data.tables* **hérite** de *data.frames*, il possède toujours l'attribut row names. Mais il ne les utilise jamais. Nous verrons dans un instant pourquoi.

    Si vous souhaitez conserver les noms des lignes, utilisez `keep.rownames = TRUE` dans `as.data.table()` - cela créera une nouvelle colonne appelée `rn` et attribuera les noms des lignes à cette colonne.

Au lieu de cela, dans *data.tables*, nous définissons et utilisons des `clés`. Pensez aux `clés` comme à des **noms de domaine surchargés**.

#### Les clés et leurs propriétés {#key-properties}

1. Nous pouvons définir des clés sur *plusieurs colonnes* et la colonne peut être de *différents types* -- *intégral*, *numérique*, *caractère*, *facteur*, *intégral64* etc. *les types liste* et *complexe* ne sont pas encore supportés.

2. L'unicité n'est pas imposée, c'est-à-dire que les valeurs de clé dupliquées sont autorisées. Les lignes étant triées par clé, tout doublon dans les colonnes de la clé apparaîtra consécutivement.

3. La définition d'une `clé` fait *deux* choses : 

    a. réorganise physiquement les lignes du *tableau de données* en fonction des colonnes fournies *par référence*, toujours dans un ordre *incrémentiel*.
    
    b. marque ces colonnes comme des colonnes *clés* en définissant un attribut appelé `sorted` à *data.table*.
    
    Puisque les lignes sont réordonnées, un *data.table* ne peut avoir qu'une seule clé car il ne peut pas être trié de plus d'une façon.

Pour le reste de la vignette, nous travaillerons avec le jeu de données `flights`.

### b) Définir, obtenir et utiliser des clés sur une *table.données*

#### -- Comment définir la colonne `origin` comme clé dans le *data.table* `flights` ?

```{r}
setkey(flights, origin)
head(flights)

## nous pouvons aussi fournir des vecteurs de caractères à la fonction 'setkeyv()'
# setkeyv(flights, "origin") # utile pour la programmation
```

* Vous pouvez utiliser la fonction `setkey()` et fournir les noms des colonnes (sans les citer). Ceci est utile lors d'une utilisation interactive.

* Vous pouvez également passer un vecteur de caractères de noms de colonnes à la fonction `setkeyv()`. Ceci est particulièrement utile lors de la conception de fonctions permettant de passer les colonnes sur lesquelles la clé doit être définie en tant qu'arguments de fonction.

* Notez que nous n'avons pas eu besoin d'assigner le résultat à une variable. C'est parce que, comme la fonction `:=` que nous avons vue dans la vignette *"Sémantique de référence "*, `setkey()` et `setkeyv()` modifient l'entrée *data.table* *par référence*. Elles renvoient le résultat de manière invisible.

* Le *data.table* est maintenant réordonné (ou trié) par la colonne que nous avons fournie - `origin`. Puisque nous réordonnons par référence, nous n'avons besoin que de la mémoire supplémentaire d'une colonne de longueur égale au nombre de lignes dans *data.table*, et c'est donc très efficace en termes de mémoire.

* Vous pouvez également définir les clés directement lors de la création de *tableaux de données* en utilisant la fonction `data.table()` avec l'argument `key`. Elle prend un vecteur de caractères de noms de colonnes.

#### set* et `:=` :

Dans *data.table*, l'opérateur `:=` et toutes les fonctions `set*` (par exemple, `setkey`, `setorder`, `setnames` etc.) sont les seules qui modifient l'objet d'entrée *par référence*.

Une fois que vous avez *clé* une *data.table* par certaines colonnes, vous pouvez la sous-sélectionner en interrogeant ces colonnes clés en utilisant la notation `.()` dans `i`. Rappelez-vous que `.()` est un *alias de `list()`.

#### -- Utilisez la colonne clé `origin` pour regrouper toutes les lignes dont l'aéroport d'origine correspond à *"JFK "*

```{r}
flights[.("JFK")]

## ou alors :
# flights[J("JFK")] (ou)
# flights[list("JFK")]
```

* La colonne *key* a déjà été définie comme `origin`. Il suffit donc de fournir la valeur, ici *"JFK "*, directement. La syntaxe `.()` permet d'identifier que la tâche nécessite de rechercher la valeur *"JFK "* dans la colonne clé de *data.table* (ici la colonne `origin` de `flights` *data.table*).

* Les *indices de ligne* correspondant à la valeur *"JFK "* dans `origin` sont obtenus en premier. Et comme il n'y a pas d'expression dans `j`, toutes les colonnes correspondant à ces indices de ligne sont renvoyées.

* Sur une clé à colonne unique de type *caractère*, vous pouvez abandonner la notation `.()` et utiliser les valeurs directement lors du sous-ensemble, comme le sous-ensemble utilisant les noms de ligne sur *data.frames*.

    ```{r eval = FALSE}
    flights["JFK"] ## identique à flights[.("JFK")]
    ```

* Nous pouvons sous-évaluer n'importe quel nombre de valeurs selon les besoins

    ```{r eval = FALSE}
    flights[c("JFK", "LGA")] ## same as flights[.(c("JFK", "LGA"))]
    ```
    
    Ceci renvoie toutes les colonnes correspondant aux lignes où la colonne `origin` correspond à *"JFK "* ou *"LGA "*.

#### -- Comment obtenir la (les) colonne(s) d'une *data.table* ?

Utilisation de la fonction `key()`.

```{r}
key(flights)
```

* Il renvoie un vecteur de caractères de toutes les colonnes clés.

* Si aucune clé n'est définie, il renvoie `NULL`.

### c) Clés et colonnes multiples

Pour rafraîchir, les *clés* sont comme des noms de ligne *superchargés*. Nous pouvons définir des clés sur plusieurs colonnes et elles peuvent être de plusieurs types.

#### -- Comment puis-je définir des clés sur les colonnes `origin` *et* `dest` ?

```{r}
setkey(flights, origin, dest)
head(flights)

## ou alors :
# setkeyv(flights, c("origin", "dest")) # fournir un vecteur de caractères pour les noms de colonnes

key(flights)
```

* Il trie les *data.table* d'abord par la colonne `origin` et ensuite par `dest` *par référence*.

#### -- Sous-ensemble de toutes les lignes utilisant des colonnes clés dont la première colonne clé `origin` correspond à *"JFK "* et la deuxième colonne clé `dest` correspond à *"MIA "*

```{r}
flights[.("JFK", "MIA")]
```

#### Comment fonctionne le sous-ensemble ? {#multiple-key-point}

* Il est important de comprendre comment cela fonctionne en interne. *"JFK "* est d'abord comparé à la première colonne clé `origin`. Et *dans ces lignes correspondantes*, *"MIA "* est comparé à la deuxième colonne clé `dest` pour obtenir des *indices de ligne* où `origin` et `dest` correspondent aux valeurs données.

* Comme aucun `j` n'est fourni, nous renvoyons simplement *toutes les colonnes* correspondant à ces indices de ligne.

#### -- Sous-ensemble de toutes les lignes dont la première colonne clé `origin` correspond à *"JFK "*

```{r}
key(flights)

flights[.("JFK")] ## ou dans ce cas simplement flights["JFK"], par commodité
```

* Puisque nous n'avons pas fourni de valeurs pour la deuxième colonne clé `dest`, il fait simplement correspondre *"JFK "* à la première colonne clé `origin` et renvoie toutes les lignes correspondantes.

#### -- Sous-ensemble de toutes les lignes dont la deuxième colonne clé `dest` correspond à *"MIA "*

```{r}
flights[.(unique(origin), "MIA")]
```

#### Que se passe-t-il ici ?

* Relisez [this](#multiple-key-point). La valeur fournie pour la deuxième colonne clé *"MIA "* doit trouver les valeurs correspondantes dans la colonne clé `dest` *sur les lignes correspondantes fournies par la première colonne clé `origin`*. Nous ne pouvons pas ignorer les valeurs des colonnes clés *avant*. Par conséquent, nous fournissons *toutes* les valeurs uniques de la colonne clé `origin`.

* *"MIA "* est automatiquement recyclé pour s'adapter à la longueur de `unique(origin)` qui est *3*.

## 2. Combinaison de clés avec `j` et `by`

Tout ce que nous avons vu jusqu'à présent est le même concept -- obtenir les *indices de rangée* dans `i`, mais juste en utilisant une méthode différente -- en utilisant `keys`. Il ne devrait pas être surprenant que nous puissions faire exactement la même chose dans `j` et `by`, comme nous l'avons vu dans les vignettes précédentes. Nous allons le montrer avec quelques exemples.

### b) Sélection dans `j`

#### -- Retourne la colonne `arr_delay` sous forme de *data.table* correspondant à `origin = "LGA"` et `dest = "TPA"`.

```{r}
key(flights)
flights[.("LGA", "TPA"), .(arr_delay)]
```

* Les *indices de ligne* correspondant à `origin == "LGA"` et `dest == "TPA"` sont obtenus à l'aide d'un *sous-ensemble basé sur une clé*.

* Une fois que nous avons les indices de ligne, nous regardons `j` qui ne nécessite que la colonne `arr_delay`. Nous sélectionnons donc simplement la colonne `arr_delay` pour ces *index de ligne* de la même manière que nous l'avons vu dans *Introduction à data.table* vignette.

* Nous aurions pu renvoyer le résultat en utilisant `with = FALSE` également.

    ```{r eval = FALSE}
    flights[.("LGA", "TPA"), "arr_delay", with = FALSE]
    ```

### b) Chaînage

#### -- Sur la base du résultat obtenu ci-dessus, utilisez le chaînage pour classer la colonne par ordre décroissant.

```{r}
flights[.("LGA", "TPA"), .(arr_delay)][order(-arr_delay)]
```

### c) Calculer ou *faire* dans `j`

#### -- Trouvez le délai d'arrivée maximal correspondant à `origin = "LGA"` et `dest = "TPA"`.

```{r}
flights[.("LGA", "TPA"), max(arr_delay)]
```

* Nous pouvons vérifier que le résultat est identique à la première valeur (486) de l'exemple précédent.

### d) *sous-assignation* par référence en utilisant `:=` dans `j`

Nous avons déjà vu cet exemple dans la vignette *Sémantique des références*. Regardons toutes les `heures` disponibles dans le *data.table* `flights` :

```{r}
# récupère toutes les 'hours' de flights
flights[, sort(unique(hour))]
```

Nous constatons qu'il y a au total `25` valeurs uniques dans les données. Les heures *0* et *24* semblent être présentes. Remplaçons *24* par *0*, mais cette fois en utilisant *key*.

```{r}
setkey(flights, hour)
key(flights)
flights[.(24), hour := 0L]
key(flights)
```

* Nous mettons d'abord `key` à `hour`. Cela permet de réorganiser `flights` en fonction de la colonne `hour` et de marquer cette colonne comme étant la colonne `key`.

* Nous pouvons maintenant effectuer un sous-ensemble sur `hour` en utilisant la notation `.()`. Nous effectuons un sous-ensemble pour la valeur *24* et obtenons les *indices de rangée* correspondants.

* Et sur ces indices de ligne, nous remplaçons la colonne `key` par la valeur `0`.

* Puisque nous avons remplacé les valeurs de la colonne *key*, la *data.table* `flights` n'est plus triée par `hour`. Par conséquent, la clé a été automatiquement supprimée en la mettant à NULL.

Maintenant, il ne devrait pas y avoir de *24* dans la colonne `hour`.

```{r}
flights[, sort(unique(hour))]
```

### e) Agrégation à l'aide de `by`

Commençons par remettre la clé à `origin, dest`.

```{r}
setkey(flights, origin, dest)
key(flights)
```

#### -- Obtenir le retard maximum au départ pour chaque `mois` correspondant à `origine = "JFK"`. Classer les résultats par `mois`

```{r}
ans <- flights["JFK", max(dep_delay), keyby = month]
head(ans)
key(ans)
```

* Nous effectuons un sous-ensemble sur la colonne *origine* de la `clé` pour obtenir les *indices de ligne* correspondant à *"JFK "*.

* Une fois que nous avons obtenu les indices de ligne, nous n'avons besoin que de deux colonnes - `month` pour grouper et `dep_delay` pour obtenir `max()` pour chaque groupe. *l'optimisation des requêtes de data.table ne sous-ensemble donc que les deux colonnes correspondant aux *index de ligne* obtenus dans `i`, pour des raisons de rapidité et d'efficacité de la mémoire.

* Et sur ce sous-ensemble, nous regroupons par *mois* et calculons `max(dep_delay)`.

* Nous utilisons `keyby` pour classer automatiquement ce résultat par *mois*. Nous comprenons maintenant ce que cela signifie. En plus de l'ordre, cela définit *month* comme la colonne `key`.

## 3. Arguments supplémentaires - `mult` et `nomatch`

### g) L'argument *mult*

Nous pouvons choisir, pour chaque requête, si *"toutes "* les lignes correspondantes doivent être retournées, ou seulement la *"première "* ou la *"dernière "* en utilisant l'argument `mult`. La valeur par défaut est *"all "* - ce que nous avons vu jusqu'à présent.

#### -- Sous-ensemble de la première ligne correspondant à toutes les lignes où `origin` correspond à *"JFK "* et `dest` correspond à *"MIA "*

```{r}
flights[.("JFK", "MIA"), mult = "first"]
```

#### -- Sous-ensemble uniquement la dernière ligne correspondante de toutes les lignes où `origin` correspond à *"LGA", "JFK", "EWR "* et `dest` correspond à *"XNA "*

```{r}
flights[.(c("LGA", "JFK", "EWR"), "XNA"), mult = "last"]
```

* La requête *"JFK", "XNA "* ne correspond à aucune ligne dans `flights` et renvoie donc `NA`.

* Une fois de plus, la requête pour la deuxième colonne clé `dest`, *"XNA "*, est recyclée pour correspondre à la longueur de la requête pour la première colonne clé `origin`, qui est d'une longueur de 3.

### b) L'argument *nomatch

Nous pouvons choisir si les requêtes qui ne correspondent pas doivent retourner `NA` ou être ignorées en utilisant l'argument `nomatch`.

#### -- D'après l'exemple précédent, le sous-ensemble de toutes les lignes n'est pris en compte que s'il y a une correspondance

```{r}
flights[.(c("LGA", "JFK", "EWR"), "XNA"), mult = "last", nomatch = NULL]
```

* La valeur par défaut de `nomatch` est `NA`. Le réglage de `nomatch = NULL` permet d'ignorer les requêtes qui n'ont pas de correspondance.

* La requête "JFK", "XNA" ne correspond à aucune ligne dans les vols et est donc ignorée.

## 4. recherche binaire et balayage vectoriel

Nous avons vu jusqu'à présent comment définir et utiliser des clés pour sous-ensembler. Mais quel est l'avantage ? Par exemple, au lieu de faire :

```{r eval = FALSE}
# clé par origin,dest columns
flights[.("JFK", "MIA")]
```

que nous aurions pu faire :

```{r eval = FALSE}
flights[origin == "JFK" & dest == "MIA"]
```

L'un des avantages est très probablement une syntaxe plus courte. Mais plus encore, les *sous-ensembles basés sur la recherche binaire* sont **incroyablement rapides**.

Au fil du temps, `data.table` reçoit de nouvelles optimisations et actuellement le dernier appel est automatiquement optimisé pour utiliser la *recherche binaire*. Pour utiliser le lent *vector scan*, la clé doit être supprimée.

```{r eval = FALSE}
setkey(flights, NULL)
flights[origin == "JFK" & dest == "MIA"]
```

### a) Performance de l'approche par recherche binaire

Pour illustrer notre propos, créons un exemple de *data.table* avec 20 millions de lignes et trois colonnes, avec pour clé les colonnes `x` et `y`.

```{r}
set.seed(2L)
N = 2e7L
DT = data.table(x = sample(letters, N, TRUE),
                y = sample(1000L, N, TRUE),
                val = runif(N))
print(object.size(DT), units = "Mb")
```

`DT` est de ~380MB. Ce n'est pas vraiment énorme, mais cela suffira à illustrer le propos.

D'après ce que nous avons vu dans la section Introduction à data.table, nous pouvons subdiviser les lignes où les colonnes `x = "g"` et `y = 877` comme suit :

```{r}
key(DT)
## (1) Méthode habituelle de sous-ensemble - approche par balayage vectoriel
t1 <- system.time(ans1 <- DT[x == "g" & y == 877L])
t1
head(ans1)
dim(ans1)
```

Essayons maintenant d'effectuer un sous-ensemble en utilisant des clés.

```{r}
setkeyv(DT, c("x", "y"))
key(DT)
## (2) Sous-ensemble à l'aide de clés
t2 <- system.time(ans2 <- DT[.("g", 877L)])
t2
head(ans2)
dim(ans2)

identical(ans1$val, ans2$val)
```

* L'accélération est **~`r round(t1[3]/max(t2[3], .001))`x**!

### b) Pourquoi l'utilisation d'une clé dans une *table.données* permet-elle d'obtenir des sous-ensembles extrêmement rapides ?

Pour comprendre cela, voyons d'abord ce que fait l'approche par balayage vectoriel (méthode 1).

#### Approche par balayage vectoriel

* La colonne `x` est recherchée pour la valeur *"g "* ligne par ligne, sur les 20 millions d'entre elles. Il en résulte un *vecteur logique* de taille 20 millions, avec les valeurs `TRUE, FALSE ou NA` correspondant à la valeur de `x`.

* De même, la colonne `y` est recherchée `877` sur les 20 millions de lignes, une par une, et stockée dans un autre vecteur logique.

* Les opérations `&` par élément sont effectuées sur les vecteurs logiques intermédiaires et toutes les lignes où l'expression est évaluée à `TRUE` sont renvoyées.

C'est ce que nous appelons une *approche par balayage vectoriel*. Cette méthode est assez inefficace, en particulier pour les grandes tables et lorsque l'on a besoin d'un sous-ensemble répété, parce qu'il faut parcourir toutes les lignes à chaque fois.

Examinons maintenant l'approche de la recherche binaire (méthode 2). Rappelons que dans [Propriétés des clés](#propriétésdesclés) - *la définition des clés réordonne le tableau data.table par colonnes de clés*. Puisque les données sont triées, nous n'avons pas besoin de *rechercher sur toute la longueur de la colonne* ! Nous pouvons utiliser *la recherche binaire* pour rechercher une valeur en `O(log n)` au lieu de `O(n)` dans le cas de *l'approche par balayage vectoriel*, où `n` est le nombre de lignes dans *la table de données*.

#### Approche par recherche binaire

Voici une illustration très simple. Considérons les nombres (triés) ci-dessous :

```
1, 5, 10, 19, 22, 23, 30
```

Supposons que nous voulions trouver la position correspondante de la valeur *1*, en utilisant la recherche binaire, voici comment nous procéderions - parce que nous savons que les données sont *triées*.

* Commencez par la valeur du milieu = 19. Est-ce que 1 == 19 ? Non. 1 < 19.

* Puisque la valeur que nous cherchons est plus petite que 19, elle devrait se trouver quelque part avant 19. Nous pouvons donc écarter le reste de la moitié qui est >= 19.

* Notre jeu est maintenant réduit à *1, 5, 10*. Prenons à nouveau la valeur centrale = 5. Est-ce que 1 == 5 ? Non. 1 < 5.

* Notre ensemble est réduit à *1*. Est-ce que 1 == 1 ? Oui. L'indice correspondant est également 1. Et c'est la seule correspondance.

Une approche par balayage vectoriel, en revanche, devrait parcourir toutes les valeurs (ici, 7).

On peut constater qu'à chaque recherche, le nombre de recherches est réduit de moitié. C'est pourquoi les sous-ensembles basés sur la recherche binaire sont **incroyablement rapides**. Comme les lignes de chaque colonne de *data.tables* ont des emplacements contigus en mémoire, les opérations sont effectuées d'une manière très efficace au niveau du cache (ce qui contribue également à la *vitesse*).

En outre, comme nous obtenons directement les indices des lignes correspondantes sans avoir à créer ces énormes vecteurs logiques (égaux au nombre de lignes d'un *table.données*), cette méthode est également très **économiquement efficace en termes de mémoire**.

## Résumé

Dans cette vignette, nous avons appris une autre méthode pour subdiviser les lignes dans `i` en utilisant les clés d'un *data.table*. Définir des clés nous permet d'effectuer des sous-ensembles très rapidement en utilisant la *recherche binaire*. En particulier, nous avons vu comment

* set key and subset using the key on a *data.table*.

* sous-ensemble utilisant des clés qui récupère les *index de ligne* dans `i`, mais beaucoup plus rapidement.

* combine les sous-ensembles basés sur les clés avec `j` et `by`. Notez que les opérations `j` et `by` sont exactement les mêmes que précédemment.

Les sous-ensembles basés sur les clés sont **incroyablement rapides** et sont particulièrement utiles lorsque la tâche implique des *sous-ensembles répétés*. Mais il n'est pas toujours souhaitable de définir une clé et de réorganiser physiquement la *table de données*. Dans la prochaine vignette, nous aborderons ce problème en utilisant une *nouvelle* fonctionnalité -- les *index secondaires*.

```{r, echo=FALSE}
setDTthreads(.old.th)
```
